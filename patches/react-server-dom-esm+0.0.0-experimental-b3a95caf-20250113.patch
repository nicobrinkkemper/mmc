diff --git a/node_modules/react-server-dom-esm/LICENSE b/node_modules/react-server-dom-esm/LICENSE
new file mode 100644
index 0000000..b93be90
--- /dev/null
+++ b/node_modules/react-server-dom-esm/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) Meta Platforms, Inc. and affiliates.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/node_modules/react-server-dom-esm/README.md b/node_modules/react-server-dom-esm/README.md
new file mode 100644
index 0000000..71c61b3
--- /dev/null
+++ b/node_modules/react-server-dom-esm/README.md
@@ -0,0 +1,5 @@
+# react-server-dom-esm
+
+Experimental React Flight bindings for DOM using ESM.
+
+**Use it at your own risk.**
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.development.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.development.js
new file mode 100644
index 0000000..67b508f
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.development.js
@@ -0,0 +1,2921 @@
+/**
+ * @license React
+ * react-server-dom-esm-client.browser.development.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+"production" !== process.env.NODE_ENV &&
+  (function () {
+    function _defineProperty(obj, key, value) {
+      key in obj
+        ? Object.defineProperty(obj, key, {
+            value: value,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+          })
+        : (obj[key] = value);
+      return obj;
+    }
+    function resolveServerReference(config, id) {
+      var idx = id.lastIndexOf("#"),
+        exportName = id.slice(idx + 1);
+      id = id.slice(0, idx);
+      if (!id.startsWith(config))
+        throw Error(
+          "Attempted to load a Server Reference outside the hosted root."
+        );
+      return { specifier: id, name: exportName };
+    }
+    function preloadModule(metadata) {
+      var existingPromise = asyncModuleCache.get(metadata.specifier);
+      if (existingPromise)
+        return "fulfilled" === existingPromise.status ? null : existingPromise;
+      var modulePromise = import(metadata.specifier);
+      modulePromise.then(
+        function (value) {
+          modulePromise.status = "fulfilled";
+          modulePromise.value = value;
+        },
+        function (reason) {
+          modulePromise.status = "rejected";
+          modulePromise.reason = reason;
+        }
+      );
+      asyncModuleCache.set(metadata.specifier, modulePromise);
+      return modulePromise;
+    }
+    function requireModule(metadata) {
+      var moduleExports = asyncModuleCache.get(metadata.specifier);
+      if ("fulfilled" === moduleExports.status)
+        moduleExports = moduleExports.value;
+      else throw moduleExports.reason;
+      return moduleExports[metadata.name];
+    }
+    function getIteratorFn(maybeIterable) {
+      if (null === maybeIterable || "object" !== typeof maybeIterable)
+        return null;
+      maybeIterable =
+        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+        maybeIterable["@@iterator"];
+      return "function" === typeof maybeIterable ? maybeIterable : null;
+    }
+    function isObjectPrototype(object) {
+      if (!object) return !1;
+      var ObjectPrototype = Object.prototype;
+      if (object === ObjectPrototype) return !0;
+      if (getPrototypeOf(object)) return !1;
+      object = Object.getOwnPropertyNames(object);
+      for (var i = 0; i < object.length; i++)
+        if (!(object[i] in ObjectPrototype)) return !1;
+      return !0;
+    }
+    function isSimpleObject(object) {
+      if (!isObjectPrototype(getPrototypeOf(object))) return !1;
+      for (
+        var names = Object.getOwnPropertyNames(object), i = 0;
+        i < names.length;
+        i++
+      ) {
+        var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+        if (
+          !descriptor ||
+          (!descriptor.enumerable &&
+            (("key" !== names[i] && "ref" !== names[i]) ||
+              "function" !== typeof descriptor.get))
+        )
+          return !1;
+      }
+      return !0;
+    }
+    function objectName(object) {
+      return Object.prototype.toString
+        .call(object)
+        .replace(/^\[object (.*)\]$/, function (m, p0) {
+          return p0;
+        });
+    }
+    function describeKeyForErrorMessage(key) {
+      var encodedKey = JSON.stringify(key);
+      return '"' + key + '"' === encodedKey ? key : encodedKey;
+    }
+    function describeValueForErrorMessage(value) {
+      switch (typeof value) {
+        case "string":
+          return JSON.stringify(
+            10 >= value.length ? value : value.slice(0, 10) + "..."
+          );
+        case "object":
+          if (isArrayImpl(value)) return "[...]";
+          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
+            return "client";
+          value = objectName(value);
+          return "Object" === value ? "{...}" : value;
+        case "function":
+          return value.$$typeof === CLIENT_REFERENCE_TAG
+            ? "client"
+            : (value = value.displayName || value.name)
+              ? "function " + value
+              : "function";
+        default:
+          return String(value);
+      }
+    }
+    function describeElementType(type) {
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (type.$$typeof) {
+          case REACT_FORWARD_REF_TYPE:
+            return describeElementType(type.render);
+          case REACT_MEMO_TYPE:
+            return describeElementType(type.type);
+          case REACT_LAZY_TYPE:
+            var payload = type._payload;
+            type = type._init;
+            try {
+              return describeElementType(type(payload));
+            } catch (x) {}
+        }
+      return "";
+    }
+    function describeObjectForErrorMessage(objectOrArray, expandedName) {
+      var objKind = objectName(objectOrArray);
+      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      var start = -1,
+        length = 0;
+      if (isArrayImpl(objectOrArray))
+        if (jsxChildrenParents.has(objectOrArray)) {
+          var type = jsxChildrenParents.get(objectOrArray);
+          objKind = "<" + describeElementType(type) + ">";
+          for (var i = 0; i < objectOrArray.length; i++) {
+            var value = objectOrArray[i];
+            value =
+              "string" === typeof value
+                ? value
+                : "object" === typeof value && null !== value
+                  ? "{" + describeObjectForErrorMessage(value) + "}"
+                  : "{" + describeValueForErrorMessage(value) + "}";
+            "" + i === expandedName
+              ? ((start = objKind.length),
+                (length = value.length),
+                (objKind += value))
+              : (objKind =
+                  15 > value.length && 40 > objKind.length + value.length
+                    ? objKind + value
+                    : objKind + "{...}");
+          }
+          objKind += "</" + describeElementType(type) + ">";
+        } else {
+          objKind = "[";
+          for (type = 0; type < objectOrArray.length; type++)
+            0 < type && (objKind += ", "),
+              (i = objectOrArray[type]),
+              (i =
+                "object" === typeof i && null !== i
+                  ? describeObjectForErrorMessage(i)
+                  : describeValueForErrorMessage(i)),
+              "" + type === expandedName
+                ? ((start = objKind.length),
+                  (length = i.length),
+                  (objKind += i))
+                : (objKind =
+                    10 > i.length && 40 > objKind.length + i.length
+                      ? objKind + i
+                      : objKind + "...");
+          objKind += "]";
+        }
+      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
+        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+      else {
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (jsxPropsParents.has(objectOrArray)) {
+          objKind = jsxPropsParents.get(objectOrArray);
+          objKind = "<" + (describeElementType(objKind) || "...");
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++) {
+            objKind += " ";
+            value = type[i];
+            objKind += describeKeyForErrorMessage(value) + "=";
+            var _value2 = objectOrArray[value];
+            var _substr2 =
+              value === expandedName &&
+              "object" === typeof _value2 &&
+              null !== _value2
+                ? describeObjectForErrorMessage(_value2)
+                : describeValueForErrorMessage(_value2);
+            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            value === expandedName
+              ? ((start = objKind.length),
+                (length = _substr2.length),
+                (objKind += _substr2))
+              : (objKind =
+                  10 > _substr2.length && 40 > objKind.length + _substr2.length
+                    ? objKind + _substr2
+                    : objKind + "...");
+          }
+          objKind += ">";
+        } else {
+          objKind = "{";
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++)
+            0 < i && (objKind += ", "),
+              (value = type[i]),
+              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (_value2 = objectOrArray[value]),
+              (_value2 =
+                "object" === typeof _value2 && null !== _value2
+                  ? describeObjectForErrorMessage(_value2)
+                  : describeValueForErrorMessage(_value2)),
+              value === expandedName
+                ? ((start = objKind.length),
+                  (length = _value2.length),
+                  (objKind += _value2))
+                : (objKind =
+                    10 > _value2.length && 40 > objKind.length + _value2.length
+                      ? objKind + _value2
+                      : objKind + "...");
+          objKind += "}";
+        }
+      }
+      return void 0 === expandedName
+        ? objKind
+        : -1 < start && 0 < length
+          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
+            "\n  " + objKind + "\n  " + objectOrArray)
+          : "\n  " + objKind;
+    }
+    function serializeNumber(number) {
+      return Number.isFinite(number)
+        ? 0 === number && -Infinity === 1 / number
+          ? "$-0"
+          : number
+        : Infinity === number
+          ? "$Infinity"
+          : -Infinity === number
+            ? "$-Infinity"
+            : "$NaN";
+    }
+    function processReply(
+      root,
+      formFieldPrefix,
+      temporaryReferences,
+      resolve,
+      reject
+    ) {
+      function serializeTypedArray(tag, typedArray) {
+        typedArray = new Blob([
+          new Uint8Array(
+            typedArray.buffer,
+            typedArray.byteOffset,
+            typedArray.byteLength
+          )
+        ]);
+        var blobId = nextPartId++;
+        null === formData && (formData = new FormData());
+        formData.append(formFieldPrefix + blobId, typedArray);
+        return "$" + tag + blobId.toString(16);
+      }
+      function serializeBinaryReader(reader) {
+        function progress(entry) {
+          entry.done
+            ? ((entry = nextPartId++),
+              data.append(formFieldPrefix + entry, new Blob(buffer)),
+              data.append(
+                formFieldPrefix + streamId,
+                '"$o' + entry.toString(16) + '"'
+              ),
+              data.append(formFieldPrefix + streamId, "C"),
+              pendingParts--,
+              0 === pendingParts && resolve(data))
+            : (buffer.push(entry.value),
+              reader.read(new Uint8Array(1024)).then(progress, reject));
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++,
+          buffer = [];
+        reader.read(new Uint8Array(1024)).then(progress, reject);
+        return "$r" + streamId.toString(16);
+      }
+      function serializeReader(reader) {
+        function progress(entry) {
+          if (entry.done)
+            data.append(formFieldPrefix + streamId, "C"),
+              pendingParts--,
+              0 === pendingParts && resolve(data);
+          else
+            try {
+              var partJSON = JSON.stringify(entry.value, resolveToJSON);
+              data.append(formFieldPrefix + streamId, partJSON);
+              reader.read().then(progress, reject);
+            } catch (x) {
+              reject(x);
+            }
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++;
+        reader.read().then(progress, reject);
+        return "$R" + streamId.toString(16);
+      }
+      function serializeReadableStream(stream) {
+        try {
+          var binaryReader = stream.getReader({ mode: "byob" });
+        } catch (x) {
+          return serializeReader(stream.getReader());
+        }
+        return serializeBinaryReader(binaryReader);
+      }
+      function serializeAsyncIterable(iterable, iterator) {
+        function progress(entry) {
+          if (entry.done) {
+            if (void 0 === entry.value)
+              data.append(formFieldPrefix + streamId, "C");
+            else
+              try {
+                var partJSON = JSON.stringify(entry.value, resolveToJSON);
+                data.append(formFieldPrefix + streamId, "C" + partJSON);
+              } catch (x) {
+                reject(x);
+                return;
+              }
+            pendingParts--;
+            0 === pendingParts && resolve(data);
+          } else
+            try {
+              var _partJSON = JSON.stringify(entry.value, resolveToJSON);
+              data.append(formFieldPrefix + streamId, _partJSON);
+              iterator.next().then(progress, reject);
+            } catch (x$0) {
+              reject(x$0);
+            }
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++;
+        iterable = iterable === iterator;
+        iterator.next().then(progress, reject);
+        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+      }
+      function resolveToJSON(key, value) {
+        var originalValue = this[key];
+        "object" !== typeof originalValue ||
+          originalValue === value ||
+          originalValue instanceof Date ||
+          ("Object" !== objectName(originalValue)
+            ? console.error(
+                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                objectName(originalValue),
+                describeObjectForErrorMessage(this, key)
+              )
+            : console.error(
+                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
+                describeObjectForErrorMessage(this, key)
+              ));
+        if (null === value) return null;
+        if ("object" === typeof value) {
+          switch (value.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+                var parentReference = writtenObjects.get(this);
+                if (void 0 !== parentReference)
+                  return (
+                    temporaryReferences.set(parentReference + ":" + key, value),
+                    "$T"
+                  );
+              }
+              throw Error(
+                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
+                  describeObjectForErrorMessage(this, key)
+              );
+            case REACT_LAZY_TYPE:
+              originalValue = value._payload;
+              var init = value._init;
+              null === formData && (formData = new FormData());
+              pendingParts++;
+              try {
+                parentReference = init(originalValue);
+                var lazyId = nextPartId++,
+                  partJSON = serializeModel(parentReference, lazyId);
+                formData.append(formFieldPrefix + lazyId, partJSON);
+                return "$" + lazyId.toString(16);
+              } catch (x) {
+                if (
+                  "object" === typeof x &&
+                  null !== x &&
+                  "function" === typeof x.then
+                ) {
+                  pendingParts++;
+                  var _lazyId = nextPartId++;
+                  parentReference = function () {
+                    try {
+                      var _partJSON2 = serializeModel(value, _lazyId),
+                        _data = formData;
+                      _data.append(formFieldPrefix + _lazyId, _partJSON2);
+                      pendingParts--;
+                      0 === pendingParts && resolve(_data);
+                    } catch (reason) {
+                      reject(reason);
+                    }
+                  };
+                  x.then(parentReference, parentReference);
+                  return "$" + _lazyId.toString(16);
+                }
+                reject(x);
+                return null;
+              } finally {
+                pendingParts--;
+              }
+          }
+          if ("function" === typeof value.then) {
+            null === formData && (formData = new FormData());
+            pendingParts++;
+            var promiseId = nextPartId++;
+            value.then(function (partValue) {
+              try {
+                var _partJSON3 = serializeModel(partValue, promiseId);
+                partValue = formData;
+                partValue.append(formFieldPrefix + promiseId, _partJSON3);
+                pendingParts--;
+                0 === pendingParts && resolve(partValue);
+              } catch (reason) {
+                reject(reason);
+              }
+            }, reject);
+            return "$@" + promiseId.toString(16);
+          }
+          parentReference = writtenObjects.get(value);
+          if (void 0 !== parentReference)
+            if (modelRoot === value) modelRoot = null;
+            else return parentReference;
+          else
+            -1 === key.indexOf(":") &&
+              ((parentReference = writtenObjects.get(this)),
+              void 0 !== parentReference &&
+                ((parentReference = parentReference + ":" + key),
+                writtenObjects.set(value, parentReference),
+                void 0 !== temporaryReferences &&
+                  temporaryReferences.set(parentReference, value)));
+          if (isArrayImpl(value)) return value;
+          if (value instanceof FormData) {
+            null === formData && (formData = new FormData());
+            var _data3 = formData;
+            key = nextPartId++;
+            var prefix = formFieldPrefix + key + "_";
+            value.forEach(function (originalValue, originalKey) {
+              _data3.append(prefix + originalKey, originalValue);
+            });
+            return "$K" + key.toString(16);
+          }
+          if (value instanceof Map)
+            return (
+              (key = nextPartId++),
+              (parentReference = serializeModel(Array.from(value), key)),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$Q" + key.toString(16)
+            );
+          if (value instanceof Set)
+            return (
+              (key = nextPartId++),
+              (parentReference = serializeModel(Array.from(value), key)),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$W" + key.toString(16)
+            );
+          if (value instanceof ArrayBuffer)
+            return (
+              (key = new Blob([value])),
+              (parentReference = nextPartId++),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + parentReference, key),
+              "$A" + parentReference.toString(16)
+            );
+          if (value instanceof Int8Array)
+            return serializeTypedArray("O", value);
+          if (value instanceof Uint8Array)
+            return serializeTypedArray("o", value);
+          if (value instanceof Uint8ClampedArray)
+            return serializeTypedArray("U", value);
+          if (value instanceof Int16Array)
+            return serializeTypedArray("S", value);
+          if (value instanceof Uint16Array)
+            return serializeTypedArray("s", value);
+          if (value instanceof Int32Array)
+            return serializeTypedArray("L", value);
+          if (value instanceof Uint32Array)
+            return serializeTypedArray("l", value);
+          if (value instanceof Float32Array)
+            return serializeTypedArray("G", value);
+          if (value instanceof Float64Array)
+            return serializeTypedArray("g", value);
+          if (value instanceof BigInt64Array)
+            return serializeTypedArray("M", value);
+          if (value instanceof BigUint64Array)
+            return serializeTypedArray("m", value);
+          if (value instanceof DataView) return serializeTypedArray("V", value);
+          if ("function" === typeof Blob && value instanceof Blob)
+            return (
+              null === formData && (formData = new FormData()),
+              (key = nextPartId++),
+              formData.append(formFieldPrefix + key, value),
+              "$B" + key.toString(16)
+            );
+          if ((parentReference = getIteratorFn(value)))
+            return (
+              (parentReference = parentReference.call(value)),
+              parentReference === value
+                ? ((key = nextPartId++),
+                  (parentReference = serializeModel(
+                    Array.from(parentReference),
+                    key
+                  )),
+                  null === formData && (formData = new FormData()),
+                  formData.append(formFieldPrefix + key, parentReference),
+                  "$i" + key.toString(16))
+                : Array.from(parentReference)
+            );
+          if (
+            "function" === typeof ReadableStream &&
+            value instanceof ReadableStream
+          )
+            return serializeReadableStream(value);
+          parentReference = value[ASYNC_ITERATOR];
+          if ("function" === typeof parentReference)
+            return serializeAsyncIterable(value, parentReference.call(value));
+          parentReference = getPrototypeOf(value);
+          if (
+            parentReference !== ObjectPrototype &&
+            (null === parentReference ||
+              null !== getPrototypeOf(parentReference))
+          ) {
+            if (void 0 === temporaryReferences)
+              throw Error(
+                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
+                  describeObjectForErrorMessage(this, key)
+              );
+            return "$T";
+          }
+          value.$$typeof === REACT_CONTEXT_TYPE
+            ? console.error(
+                "React Context Providers cannot be passed to Server Functions from the Client.%s",
+                describeObjectForErrorMessage(this, key)
+              )
+            : "Object" !== objectName(value)
+              ? console.error(
+                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  objectName(value),
+                  describeObjectForErrorMessage(this, key)
+                )
+              : isSimpleObject(value)
+                ? Object.getOwnPropertySymbols &&
+                  ((parentReference = Object.getOwnPropertySymbols(value)),
+                  0 < parentReference.length &&
+                    console.error(
+                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      parentReference[0].description,
+                      describeObjectForErrorMessage(this, key)
+                    ))
+                : console.error(
+                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
+                    describeObjectForErrorMessage(this, key)
+                  );
+          return value;
+        }
+        if ("string" === typeof value) {
+          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
+            return "$D" + value;
+          key = "$" === value[0] ? "$" + value : value;
+          return key;
+        }
+        if ("boolean" === typeof value) return value;
+        if ("number" === typeof value) return serializeNumber(value);
+        if ("undefined" === typeof value) return "$undefined";
+        if ("function" === typeof value) {
+          parentReference = knownServerReferences.get(value);
+          if (void 0 !== parentReference)
+            return (
+              (key = JSON.stringify(parentReference, resolveToJSON)),
+              null === formData && (formData = new FormData()),
+              (parentReference = nextPartId++),
+              formData.set(formFieldPrefix + parentReference, key),
+              "$F" + parentReference.toString(16)
+            );
+          if (
+            void 0 !== temporaryReferences &&
+            -1 === key.indexOf(":") &&
+            ((parentReference = writtenObjects.get(this)),
+            void 0 !== parentReference)
+          )
+            return (
+              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+            );
+          throw Error(
+            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+          );
+        }
+        if ("symbol" === typeof value) {
+          if (
+            void 0 !== temporaryReferences &&
+            -1 === key.indexOf(":") &&
+            ((parentReference = writtenObjects.get(this)),
+            void 0 !== parentReference)
+          )
+            return (
+              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+            );
+          throw Error(
+            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
+              describeObjectForErrorMessage(this, key)
+          );
+        }
+        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        throw Error(
+          "Type " +
+            typeof value +
+            " is not supported as an argument to a Server Function."
+        );
+      }
+      function serializeModel(model, id) {
+        "object" === typeof model &&
+          null !== model &&
+          ((id = "$" + id.toString(16)),
+          writtenObjects.set(model, id),
+          void 0 !== temporaryReferences && temporaryReferences.set(id, model));
+        modelRoot = model;
+        return JSON.stringify(model, resolveToJSON);
+      }
+      var nextPartId = 1,
+        pendingParts = 0,
+        formData = null,
+        writtenObjects = new WeakMap(),
+        modelRoot = root,
+        json = serializeModel(root, 0);
+      null === formData
+        ? resolve(json)
+        : (formData.set(formFieldPrefix + "0", json),
+          0 === pendingParts && resolve(formData));
+      return function () {
+        0 < pendingParts &&
+          ((pendingParts = 0),
+          null === formData ? resolve(json) : resolve(formData));
+      };
+    }
+    function createFakeServerFunction(
+      name,
+      filename,
+      sourceMap,
+      line,
+      col,
+      environmentName,
+      innerFunction
+    ) {
+      name || (name = "<anonymous>");
+      var encodedName = JSON.stringify(name);
+      1 >= line
+        ? ((line = encodedName.length + 7),
+          (col =
+            "s=>({" +
+            encodedName +
+            " ".repeat(col < line ? 0 : col - line) +
+            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+        : (col =
+            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
+            "\n".repeat(line - 2) +
+            "server=>({" +
+            encodedName +
+            ":\n" +
+            " ".repeat(1 > col ? 0 : col - 1) +
+            "(...args) => server(...args)})");
+      filename.startsWith("/") && (filename = "file://" + filename);
+      sourceMap
+        ? ((col +=
+            "\n//# sourceURL=rsc://React/" +
+            encodeURIComponent(environmentName) +
+            "/" +
+            filename +
+            "?s" +
+            fakeServerFunctionIdx++),
+          (col += "\n//# sourceMappingURL=" + sourceMap))
+        : filename && (col += "\n//# sourceURL=" + filename);
+      try {
+        return (0, eval)(col)(innerFunction)[name];
+      } catch (x) {
+        return innerFunction;
+      }
+    }
+    function registerServerReference(proxy, reference) {
+      knownServerReferences.set(proxy, reference);
+    }
+    function createBoundServerReference(
+      metaData,
+      callServer,
+      encodeFormAction,
+      findSourceMapURL
+    ) {
+      function action() {
+        var args = Array.prototype.slice.call(arguments);
+        return bound
+          ? "fulfilled" === bound.status
+            ? callServer(id, bound.value.concat(args))
+            : Promise.resolve(bound).then(function (boundArgs) {
+                return callServer(id, boundArgs.concat(args));
+              })
+          : callServer(id, args);
+      }
+      var id = metaData.id,
+        bound = metaData.bound,
+        location = metaData.location;
+      if (location) {
+        encodeFormAction = metaData.name || "";
+        var filename = location[1],
+          line = location[2];
+        location = location[3];
+        metaData = metaData.env || "Server";
+        findSourceMapURL =
+          null == findSourceMapURL
+            ? null
+            : findSourceMapURL(filename, metaData);
+        action = createFakeServerFunction(
+          encodeFormAction,
+          filename,
+          findSourceMapURL,
+          line,
+          location,
+          metaData,
+          action
+        );
+      }
+      registerServerReference(action, { id: id, bound: bound });
+      return action;
+    }
+    function parseStackLocation(error) {
+      error = error.stack;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      var endOfFirst = error.indexOf("\n");
+      if (-1 !== endOfFirst) {
+        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        endOfFirst =
+          -1 === endOfSecond
+            ? error.slice(endOfFirst + 1)
+            : error.slice(endOfFirst + 1, endOfSecond);
+      } else endOfFirst = error;
+      error = v8FrameRegExp.exec(endOfFirst);
+      if (
+        !error &&
+        ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
+      )
+        return null;
+      endOfFirst = error[1] || "";
+      "<anonymous>" === endOfFirst && (endOfFirst = "");
+      endOfSecond = error[2] || error[5] || "";
+      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      return [
+        endOfFirst,
+        endOfSecond,
+        +(error[3] || error[6]),
+        +(error[4] || error[7])
+      ];
+    }
+    function getComponentNameFromType(type) {
+      if (null == type) return null;
+      if ("function" === typeof type)
+        return type.$$typeof === REACT_CLIENT_REFERENCE
+          ? null
+          : type.displayName || type.name || null;
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_FRAGMENT_TYPE:
+          return "Fragment";
+        case REACT_PORTAL_TYPE:
+          return "Portal";
+        case REACT_PROFILER_TYPE:
+          return "Profiler";
+        case REACT_STRICT_MODE_TYPE:
+          return "StrictMode";
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (
+          ("number" === typeof type.tag &&
+            console.error(
+              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+            ),
+          type.$$typeof)
+        ) {
+          case REACT_CONTEXT_TYPE:
+            return (type.displayName || "Context") + ".Provider";
+          case REACT_CONSUMER_TYPE:
+            return (type._context.displayName || "Context") + ".Consumer";
+          case REACT_FORWARD_REF_TYPE:
+            var innerType = type.render;
+            type = type.displayName;
+            type ||
+              ((type = innerType.displayName || innerType.name || ""),
+              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+            return type;
+          case REACT_MEMO_TYPE:
+            return (
+              (innerType = type.displayName || null),
+              null !== innerType
+                ? innerType
+                : getComponentNameFromType(type.type) || "Memo"
+            );
+          case REACT_LAZY_TYPE:
+            innerType = type._payload;
+            type = type._init;
+            try {
+              return getComponentNameFromType(type(innerType));
+            } catch (x) {}
+        }
+      return null;
+    }
+    function ReactPromise(status, value, reason, response) {
+      this.status = status;
+      this.value = value;
+      this.reason = reason;
+      this._response = response;
+      this._children = [];
+      this._debugInfo = null;
+    }
+    function readChunk(chunk) {
+      switch (chunk.status) {
+        case "resolved_model":
+          initializeModelChunk(chunk);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(chunk);
+      }
+      switch (chunk.status) {
+        case "fulfilled":
+          return chunk.value;
+        case "pending":
+        case "blocked":
+          throw chunk;
+        default:
+          throw chunk.reason;
+      }
+    }
+    function createPendingChunk(response) {
+      return new ReactPromise("pending", null, null, response);
+    }
+    function createErrorChunk(response, error) {
+      return new ReactPromise("rejected", null, error, response);
+    }
+    function wakeChunk(listeners, value) {
+      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+    }
+    function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+      switch (chunk.status) {
+        case "fulfilled":
+          wakeChunk(resolveListeners, chunk.value);
+          break;
+        case "pending":
+        case "blocked":
+          if (chunk.value)
+            for (var i = 0; i < resolveListeners.length; i++)
+              chunk.value.push(resolveListeners[i]);
+          else chunk.value = resolveListeners;
+          if (chunk.reason) {
+            if (rejectListeners)
+              for (
+                resolveListeners = 0;
+                resolveListeners < rejectListeners.length;
+                resolveListeners++
+              )
+                chunk.reason.push(rejectListeners[resolveListeners]);
+          } else chunk.reason = rejectListeners;
+          break;
+        case "rejected":
+          rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+      }
+    }
+    function triggerErrorOnChunk(chunk, error) {
+      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+        chunk.reason.error(error);
+      else {
+        var listeners = chunk.reason;
+        chunk.status = "rejected";
+        chunk.reason = error;
+        null !== listeners && wakeChunk(listeners, error);
+      }
+    }
+    function createResolvedIteratorResultChunk(response, value, done) {
+      return new ReactPromise(
+        "resolved_model",
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}",
+        null,
+        response
+      );
+    }
+    function resolveIteratorResultChunk(chunk, value, done) {
+      resolveModelChunk(
+        chunk,
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}"
+      );
+    }
+    function resolveModelChunk(chunk, value) {
+      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      else {
+        var resolveListeners = chunk.value,
+          rejectListeners = chunk.reason;
+        chunk.status = "resolved_model";
+        chunk.value = value;
+        null !== resolveListeners &&
+          (initializeModelChunk(chunk),
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+      }
+    }
+    function resolveModuleChunk(chunk, value) {
+      if ("pending" === chunk.status || "blocked" === chunk.status) {
+        var resolveListeners = chunk.value,
+          rejectListeners = chunk.reason;
+        chunk.status = "resolved_module";
+        chunk.value = value;
+        null !== resolveListeners &&
+          (initializeModuleChunk(chunk),
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+      }
+    }
+    function initializeModelChunk(chunk) {
+      var prevHandler = initializingHandler,
+        prevChunk = initializingChunk;
+      initializingHandler = null;
+      var resolvedModel = chunk.value;
+      chunk.status = "blocked";
+      chunk.value = null;
+      chunk.reason = null;
+      initializingChunk = chunk;
+      try {
+        var value = JSON.parse(resolvedModel, chunk._response._fromJSON),
+          resolveListeners = chunk.value;
+        null !== resolveListeners &&
+          ((chunk.value = null),
+          (chunk.reason = null),
+          wakeChunk(resolveListeners, value));
+        if (null !== initializingHandler) {
+          if (initializingHandler.errored) throw initializingHandler.value;
+          if (0 < initializingHandler.deps) {
+            initializingHandler.value = value;
+            initializingHandler.chunk = chunk;
+            return;
+          }
+        }
+        chunk.status = "fulfilled";
+        chunk.value = value;
+      } catch (error) {
+        (chunk.status = "rejected"), (chunk.reason = error);
+      } finally {
+        (initializingHandler = prevHandler), (initializingChunk = prevChunk);
+      }
+    }
+    function initializeModuleChunk(chunk) {
+      try {
+        var value = requireModule(chunk.value);
+        chunk.status = "fulfilled";
+        chunk.value = value;
+      } catch (error) {
+        (chunk.status = "rejected"), (chunk.reason = error);
+      }
+    }
+    function reportGlobalError(response, error) {
+      response._closed = !0;
+      response._closedReason = error;
+      response._chunks.forEach(function (chunk) {
+        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+      });
+      supportsUserTiming &&
+        performance.mark("Server Components Track", componentsTrackMarker);
+      flushComponentPerformance(
+        response,
+        getChunk(response, 0),
+        0,
+        -Infinity,
+        -Infinity
+      );
+    }
+    function nullRefGetter() {
+      return null;
+    }
+    function getTaskName(type) {
+      if (type === REACT_FRAGMENT_TYPE) return "<>";
+      if ("function" === typeof type) return '"use client"';
+      if (
+        "object" === typeof type &&
+        null !== type &&
+        type.$$typeof === REACT_LAZY_TYPE
+      )
+        return type._init === readChunk ? '"use client"' : "<...>";
+      try {
+        var name = getComponentNameFromType(type);
+        return name ? "<" + name + ">" : "<...>";
+      } catch (x) {
+        return "<...>";
+      }
+    }
+    function createLazyChunkWrapper(chunk) {
+      var lazyType = {
+        $$typeof: REACT_LAZY_TYPE,
+        _payload: chunk,
+        _init: readChunk
+      };
+      chunk = chunk._debugInfo || (chunk._debugInfo = []);
+      lazyType._debugInfo = chunk;
+      return lazyType;
+    }
+    function getChunk(response, id) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk ||
+        ((chunk = response._closed
+          ? createErrorChunk(response, response._closedReason)
+          : createPendingChunk(response)),
+        chunks.set(id, chunk));
+      return chunk;
+    }
+    function waitForReference(
+      referencedChunk,
+      parentObject,
+      key,
+      response,
+      map,
+      path
+    ) {
+      function fulfill(value) {
+        for (var i = 1; i < path.length; i++) {
+          for (; value.$$typeof === REACT_LAZY_TYPE; )
+            if (((value = value._payload), value === handler.chunk))
+              value = handler.value;
+            else if ("fulfilled" === value.status) value = value.value;
+            else {
+              path.splice(0, i - 1);
+              value.then(fulfill, reject);
+              return;
+            }
+          value = value[path[i]];
+        }
+        i = map(response, value, parentObject, key);
+        parentObject[key] = i;
+        "" === key && null === handler.value && (handler.value = i);
+        if (
+          parentObject[0] === REACT_ELEMENT_TYPE &&
+          "object" === typeof handler.value &&
+          null !== handler.value &&
+          handler.value.$$typeof === REACT_ELEMENT_TYPE
+        )
+          switch (((value = handler.value), key)) {
+            case "3":
+              value.props = i;
+              break;
+            case "4":
+              value._owner = i;
+          }
+        handler.deps--;
+        0 === handler.deps &&
+          ((i = handler.chunk),
+          null !== i &&
+            "blocked" === i.status &&
+            ((value = i.value),
+            (i.status = "fulfilled"),
+            (i.value = handler.value),
+            null !== value && wakeChunk(value, handler.value)));
+      }
+      function reject(error) {
+        if (!handler.errored) {
+          var blockedValue = handler.value;
+          handler.errored = !0;
+          handler.value = error;
+          var chunk = handler.chunk;
+          if (null !== chunk && "blocked" === chunk.status) {
+            if (
+              "object" === typeof blockedValue &&
+              null !== blockedValue &&
+              blockedValue.$$typeof === REACT_ELEMENT_TYPE
+            ) {
+              var erroredComponent = {
+                name: getComponentNameFromType(blockedValue.type) || "",
+                owner: blockedValue._owner
+              };
+              erroredComponent.debugStack = blockedValue._debugStack;
+              supportsCreateTask &&
+                (erroredComponent.debugTask = blockedValue._debugTask);
+              (chunk._debugInfo || (chunk._debugInfo = [])).push(
+                erroredComponent
+              );
+            }
+            triggerErrorOnChunk(chunk, error);
+          }
+        }
+      }
+      if (initializingHandler) {
+        var handler = initializingHandler;
+        handler.deps++;
+      } else
+        handler = initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: null,
+          deps: 1,
+          errored: !1
+        };
+      referencedChunk.then(fulfill, reject);
+      return null;
+    }
+    function loadServerReference(response, metaData, parentObject, key) {
+      if (!response._serverReferenceConfig)
+        return createBoundServerReference(
+          metaData,
+          response._callServer,
+          response._encodeFormAction,
+          response._debugFindSourceMapURL
+        );
+      var serverReference = resolveServerReference(
+        response._serverReferenceConfig,
+        metaData.id
+      );
+      if ((response = preloadModule(serverReference)))
+        metaData.bound && (response = Promise.all([response, metaData.bound]));
+      else if (metaData.bound) response = Promise.resolve(metaData.bound);
+      else return requireModule(serverReference);
+      if (initializingHandler) {
+        var handler = initializingHandler;
+        handler.deps++;
+      } else
+        handler = initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: null,
+          deps: 1,
+          errored: !1
+        };
+      response.then(
+        function () {
+          var resolvedValue = requireModule(serverReference);
+          if (metaData.bound) {
+            var boundArgs = metaData.bound.value.slice(0);
+            boundArgs.unshift(null);
+            resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+          }
+          parentObject[key] = resolvedValue;
+          "" === key &&
+            null === handler.value &&
+            (handler.value = resolvedValue);
+          if (
+            parentObject[0] === REACT_ELEMENT_TYPE &&
+            "object" === typeof handler.value &&
+            null !== handler.value &&
+            handler.value.$$typeof === REACT_ELEMENT_TYPE
+          )
+            switch (((boundArgs = handler.value), key)) {
+              case "3":
+                boundArgs.props = resolvedValue;
+                break;
+              case "4":
+                boundArgs._owner = resolvedValue;
+            }
+          handler.deps--;
+          0 === handler.deps &&
+            ((resolvedValue = handler.chunk),
+            null !== resolvedValue &&
+              "blocked" === resolvedValue.status &&
+              ((boundArgs = resolvedValue.value),
+              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.value = handler.value),
+              null !== boundArgs && wakeChunk(boundArgs, handler.value)));
+        },
+        function (error) {
+          if (!handler.errored) {
+            var blockedValue = handler.value;
+            handler.errored = !0;
+            handler.value = error;
+            var chunk = handler.chunk;
+            if (null !== chunk && "blocked" === chunk.status) {
+              if (
+                "object" === typeof blockedValue &&
+                null !== blockedValue &&
+                blockedValue.$$typeof === REACT_ELEMENT_TYPE
+              ) {
+                var erroredComponent = {
+                  name: getComponentNameFromType(blockedValue.type) || "",
+                  owner: blockedValue._owner
+                };
+                erroredComponent.debugStack = blockedValue._debugStack;
+                supportsCreateTask &&
+                  (erroredComponent.debugTask = blockedValue._debugTask);
+                (chunk._debugInfo || (chunk._debugInfo = [])).push(
+                  erroredComponent
+                );
+              }
+              triggerErrorOnChunk(chunk, error);
+            }
+          }
+        }
+      );
+      return null;
+    }
+    function getOutlinedModel(response, reference, parentObject, key, map) {
+      reference = reference.split(":");
+      var id = parseInt(reference[0], 16);
+      id = getChunk(response, id);
+      null !== initializingChunk &&
+        isArrayImpl(initializingChunk._children) &&
+        initializingChunk._children.push(id);
+      switch (id.status) {
+        case "resolved_model":
+          initializeModelChunk(id);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(id);
+      }
+      switch (id.status) {
+        case "fulfilled":
+          for (var value = id.value, i = 1; i < reference.length; i++) {
+            for (; value.$$typeof === REACT_LAZY_TYPE; )
+              if (((value = value._payload), "fulfilled" === value.status))
+                value = value.value;
+              else
+                return waitForReference(
+                  value,
+                  parentObject,
+                  key,
+                  response,
+                  map,
+                  reference.slice(i - 1)
+                );
+            value = value[reference[i]];
+          }
+          response = map(response, value, parentObject, key);
+          id._debugInfo &&
+            ("object" !== typeof response ||
+              null === response ||
+              (!isArrayImpl(response) &&
+                "function" !== typeof response[ASYNC_ITERATOR] &&
+                response.$$typeof !== REACT_ELEMENT_TYPE) ||
+              response._debugInfo ||
+              Object.defineProperty(response, "_debugInfo", {
+                configurable: !1,
+                enumerable: !1,
+                writable: !0,
+                value: id._debugInfo
+              }));
+          return response;
+        case "pending":
+        case "blocked":
+          return waitForReference(
+            id,
+            parentObject,
+            key,
+            response,
+            map,
+            reference
+          );
+        default:
+          return (
+            initializingHandler
+              ? ((initializingHandler.errored = !0),
+                (initializingHandler.value = id.reason))
+              : (initializingHandler = {
+                  parent: null,
+                  chunk: null,
+                  value: id.reason,
+                  deps: 0,
+                  errored: !0
+                }),
+            null
+          );
+      }
+    }
+    function createMap(response, model) {
+      return new Map(model);
+    }
+    function createSet(response, model) {
+      return new Set(model);
+    }
+    function createBlob(response, model) {
+      return new Blob(model.slice(1), { type: model[0] });
+    }
+    function createFormData(response, model) {
+      response = new FormData();
+      for (var i = 0; i < model.length; i++)
+        response.append(model[i][0], model[i][1]);
+      return response;
+    }
+    function extractIterator(response, model) {
+      return model[Symbol.iterator]();
+    }
+    function createModel(response, model) {
+      return model;
+    }
+    function parseModelString(response, parentObject, key, value) {
+      if ("$" === value[0]) {
+        if ("$" === value)
+          return (
+            null !== initializingHandler &&
+              "0" === key &&
+              (initializingHandler = {
+                parent: initializingHandler,
+                chunk: null,
+                value: null,
+                deps: 0,
+                errored: !1
+              }),
+            REACT_ELEMENT_TYPE
+          );
+        switch (value[1]) {
+          case "$":
+            return value.slice(1);
+          case "L":
+            return (
+              (parentObject = parseInt(value.slice(2), 16)),
+              (response = getChunk(response, parentObject)),
+              null !== initializingChunk &&
+                isArrayImpl(initializingChunk._children) &&
+                initializingChunk._children.push(response),
+              createLazyChunkWrapper(response)
+            );
+          case "@":
+            if (2 === value.length) return new Promise(function () {});
+            parentObject = parseInt(value.slice(2), 16);
+            response = getChunk(response, parentObject);
+            null !== initializingChunk &&
+              isArrayImpl(initializingChunk._children) &&
+              initializingChunk._children.push(response);
+            return response;
+          case "S":
+            return Symbol.for(value.slice(2));
+          case "F":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                loadServerReference
+              )
+            );
+          case "T":
+            parentObject = "$" + value.slice(2);
+            response = response._tempRefs;
+            if (null == response)
+              throw Error(
+                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+              );
+            return response.get(parentObject);
+          case "Q":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createMap)
+            );
+          case "W":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createSet)
+            );
+          case "B":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createBlob)
+            );
+          case "K":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                createFormData
+              )
+            );
+          case "Z":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                resolveErrorDev
+              )
+            );
+          case "i":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                extractIterator
+              )
+            );
+          case "I":
+            return Infinity;
+          case "-":
+            return "$-0" === value ? -0 : -Infinity;
+          case "N":
+            return NaN;
+          case "u":
+            return;
+          case "D":
+            return new Date(Date.parse(value.slice(2)));
+          case "n":
+            return BigInt(value.slice(2));
+          case "E":
+            try {
+              return (0, eval)(value.slice(2));
+            } catch (x) {
+              return function () {};
+            }
+          case "Y":
+            return (
+              Object.defineProperty(parentObject, key, {
+                get: function () {
+                  return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                },
+                enumerable: !0,
+                configurable: !1
+              }),
+              null
+            );
+          default:
+            return (
+              (value = value.slice(1)),
+              getOutlinedModel(response, value, parentObject, key, createModel)
+            );
+        }
+      }
+      return value;
+    }
+    function missingCall() {
+      throw Error(
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+      );
+    }
+    function ResponseInstance(
+      bundlerConfig,
+      serverReferenceConfig,
+      moduleLoading,
+      callServer,
+      encodeFormAction,
+      nonce,
+      temporaryReferences,
+      findSourceMapURL,
+      replayConsole,
+      environmentName
+    ) {
+      var chunks = new Map();
+      this._bundlerConfig = bundlerConfig;
+      this._serverReferenceConfig = serverReferenceConfig;
+      this._moduleLoading = moduleLoading;
+      this._callServer = void 0 !== callServer ? callServer : missingCall;
+      this._encodeFormAction = encodeFormAction;
+      this._nonce = nonce;
+      this._chunks = chunks;
+      this._stringDecoder = new TextDecoder();
+      this._fromJSON = null;
+      this._rowLength = this._rowTag = this._rowID = this._rowState = 0;
+      this._buffer = [];
+      this._closed = !1;
+      this._closedReason = null;
+      this._tempRefs = temporaryReferences;
+      this._timeOrigin = 0;
+      this._debugRootOwner = bundlerConfig =
+        void 0 === ReactSharedInteralsServer ||
+        null === ReactSharedInteralsServer.A
+          ? null
+          : ReactSharedInteralsServer.A.getOwner();
+      this._debugRootStack =
+        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
+      environmentName = void 0 === environmentName ? "Server" : environmentName;
+      supportsCreateTask &&
+        (this._debugRootTask = console.createTask(
+          '"use ' + environmentName.toLowerCase() + '"'
+        ));
+      this._debugFindSourceMapURL = findSourceMapURL;
+      this._replayConsole = replayConsole;
+      this._rootEnvironmentName = environmentName;
+      this._fromJSON = createFromJSONCallback(this);
+    }
+    function resolveModel(response, id, model) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk
+        ? resolveModelChunk(chunk, model)
+        : chunks.set(
+            id,
+            new ReactPromise("resolved_model", model, null, response)
+          );
+    }
+    function resolveText(response, id, text) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(text)
+        : chunks.set(id, new ReactPromise("fulfilled", text, null, response));
+    }
+    function resolveBuffer(response, id, buffer) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(buffer)
+        : chunks.set(id, new ReactPromise("fulfilled", buffer, null, response));
+    }
+    function resolveModule(response, id, model) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      model = JSON.parse(model, response._fromJSON);
+      var clientReference = {
+        specifier: response._bundlerConfig + model[0],
+        name: model[1]
+      };
+      if ((model = preloadModule(clientReference))) {
+        if (chunk) {
+          var blockedChunk = chunk;
+          blockedChunk.status = "blocked";
+        } else
+          (blockedChunk = new ReactPromise("blocked", null, null, response)),
+            chunks.set(id, blockedChunk);
+        model.then(
+          function () {
+            return resolveModuleChunk(blockedChunk, clientReference);
+          },
+          function (error) {
+            return triggerErrorOnChunk(blockedChunk, error);
+          }
+        );
+      } else
+        chunk
+          ? resolveModuleChunk(chunk, clientReference)
+          : chunks.set(
+              id,
+              new ReactPromise(
+                "resolved_module",
+                clientReference,
+                null,
+                response
+              )
+            );
+    }
+    function resolveStream(response, id, stream, controller) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk
+        ? "pending" === chunk.status &&
+          ((response = chunk.value),
+          (chunk.status = "fulfilled"),
+          (chunk.value = stream),
+          (chunk.reason = controller),
+          null !== response && wakeChunk(response, chunk.value))
+        : chunks.set(
+            id,
+            new ReactPromise("fulfilled", stream, controller, response)
+          );
+    }
+    function startReadableStream(response, id, type) {
+      var controller = null;
+      type = new ReadableStream({
+        type: type,
+        start: function (c) {
+          controller = c;
+        }
+      });
+      var previousBlockedChunk = null;
+      resolveStream(response, id, type, {
+        enqueueValue: function (value) {
+          null === previousBlockedChunk
+            ? controller.enqueue(value)
+            : previousBlockedChunk.then(function () {
+                controller.enqueue(value);
+              });
+        },
+        enqueueModel: function (json) {
+          if (null === previousBlockedChunk) {
+            var chunk = new ReactPromise(
+              "resolved_model",
+              json,
+              null,
+              response
+            );
+            initializeModelChunk(chunk);
+            "fulfilled" === chunk.status
+              ? controller.enqueue(chunk.value)
+              : (chunk.then(
+                  function (v) {
+                    return controller.enqueue(v);
+                  },
+                  function (e) {
+                    return controller.error(e);
+                  }
+                ),
+                (previousBlockedChunk = chunk));
+          } else {
+            chunk = previousBlockedChunk;
+            var _chunk3 = createPendingChunk(response);
+            _chunk3.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            );
+            previousBlockedChunk = _chunk3;
+            chunk.then(function () {
+              previousBlockedChunk === _chunk3 && (previousBlockedChunk = null);
+              resolveModelChunk(_chunk3, json);
+            });
+          }
+        },
+        close: function () {
+          if (null === previousBlockedChunk) controller.close();
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.close();
+            });
+          }
+        },
+        error: function (error) {
+          if (null === previousBlockedChunk) controller.error(error);
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.error(error);
+            });
+          }
+        }
+      });
+    }
+    function asyncIterator() {
+      return this;
+    }
+    function createIterator(next) {
+      next = { next: next };
+      next[ASYNC_ITERATOR] = asyncIterator;
+      return next;
+    }
+    function startAsyncIterable(response, id, iterator) {
+      var buffer = [],
+        closed = !1,
+        nextWriteIndex = 0,
+        iterable = _defineProperty({}, ASYNC_ITERATOR, function () {
+          var nextReadIndex = 0;
+          return createIterator(function (arg) {
+            if (void 0 !== arg)
+              throw Error(
+                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              );
+            if (nextReadIndex === buffer.length) {
+              if (closed)
+                return new ReactPromise(
+                  "fulfilled",
+                  { done: !0, value: void 0 },
+                  null,
+                  response
+                );
+              buffer[nextReadIndex] = createPendingChunk(response);
+            }
+            return buffer[nextReadIndex++];
+          });
+        });
+      resolveStream(
+        response,
+        id,
+        iterator ? iterable[ASYNC_ITERATOR]() : iterable,
+        {
+          enqueueValue: function (value) {
+            if (nextWriteIndex === buffer.length)
+              buffer[nextWriteIndex] = new ReactPromise(
+                "fulfilled",
+                { done: !1, value: value },
+                null,
+                response
+              );
+            else {
+              var chunk = buffer[nextWriteIndex],
+                resolveListeners = chunk.value,
+                rejectListeners = chunk.reason;
+              chunk.status = "fulfilled";
+              chunk.value = { done: !1, value: value };
+              null !== resolveListeners &&
+                wakeChunkIfInitialized(
+                  chunk,
+                  resolveListeners,
+                  rejectListeners
+                );
+            }
+            nextWriteIndex++;
+          },
+          enqueueModel: function (value) {
+            nextWriteIndex === buffer.length
+              ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                  response,
+                  value,
+                  !1
+                ))
+              : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+            nextWriteIndex++;
+          },
+          close: function (value) {
+            closed = !0;
+            nextWriteIndex === buffer.length
+              ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                  response,
+                  value,
+                  !0
+                ))
+              : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+            for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+              resolveIteratorResultChunk(
+                buffer[nextWriteIndex++],
+                '"$undefined"',
+                !0
+              );
+          },
+          error: function (error) {
+            closed = !0;
+            for (
+              nextWriteIndex === buffer.length &&
+              (buffer[nextWriteIndex] = createPendingChunk(response));
+              nextWriteIndex < buffer.length;
+
+            )
+              triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+          }
+        }
+      );
+    }
+    function stopStream(response, id, row) {
+      (response = response._chunks.get(id)) &&
+        "fulfilled" === response.status &&
+        response.reason.close("" === row ? '"$undefined"' : row);
+    }
+    function resolveErrorDev(response, errorInfo) {
+      var env = errorInfo.env;
+      errorInfo = buildFakeCallStack(
+        response,
+        errorInfo.stack,
+        env,
+        Error.bind(
+          null,
+          errorInfo.message ||
+            "An error occurred in the Server Components render but no message was provided"
+        )
+      );
+      response = getRootTask(response, env);
+      response = null != response ? response.run(errorInfo) : errorInfo();
+      response.environmentName = env;
+      return response;
+    }
+    function resolvePostponeDev(response, id, reason, stack, env) {
+      reason = buildFakeCallStack(
+        response,
+        stack,
+        env,
+        Error.bind(null, reason || "")
+      );
+      stack = response._debugRootTask;
+      reason = null != stack ? stack.run(reason) : reason();
+      reason.$$typeof = REACT_POSTPONE_TYPE;
+      stack = response._chunks;
+      (env = stack.get(id))
+        ? triggerErrorOnChunk(env, reason)
+        : stack.set(id, createErrorChunk(response, reason));
+    }
+    function resolveHint(response, code, model) {
+      response = JSON.parse(model, response._fromJSON);
+      model = ReactDOMSharedInternals.d;
+      switch (code) {
+        case "D":
+          model.D(response);
+          break;
+        case "C":
+          "string" === typeof response
+            ? model.C(response)
+            : model.C(response[0], response[1]);
+          break;
+        case "L":
+          code = response[0];
+          var as = response[1];
+          3 === response.length
+            ? model.L(code, as, response[2])
+            : model.L(code, as);
+          break;
+        case "m":
+          "string" === typeof response
+            ? model.m(response)
+            : model.m(response[0], response[1]);
+          break;
+        case "X":
+          "string" === typeof response
+            ? model.X(response)
+            : model.X(response[0], response[1]);
+          break;
+        case "S":
+          "string" === typeof response
+            ? model.S(response)
+            : model.S(
+                response[0],
+                0 === response[1] ? void 0 : response[1],
+                3 === response.length ? response[2] : void 0
+              );
+          break;
+        case "M":
+          "string" === typeof response
+            ? model.M(response)
+            : model.M(response[0], response[1]);
+      }
+    }
+    function createFakeFunction(
+      name,
+      filename,
+      sourceMap,
+      line,
+      col,
+      environmentName
+    ) {
+      name || (name = "<anonymous>");
+      var encodedName = JSON.stringify(name);
+      1 >= line
+        ? ((line = encodedName.length + 7),
+          (col =
+            "({" +
+            encodedName +
+            ":_=>" +
+            " ".repeat(col < line ? 0 : col - line) +
+            "_()})\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"))
+        : (col =
+            "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            "\n".repeat(line - 2) +
+            "({" +
+            encodedName +
+            ":_=>\n" +
+            " ".repeat(1 > col ? 0 : col - 1) +
+            "_()})");
+      filename.startsWith("/") && (filename = "file://" + filename);
+      sourceMap
+        ? ((col +=
+            "\n//# sourceURL=rsc://React/" +
+            encodeURIComponent(environmentName) +
+            "/" +
+            encodeURI(filename) +
+            "?" +
+            fakeFunctionIdx++),
+          (col += "\n//# sourceMappingURL=" + sourceMap))
+        : (col = filename
+            ? col + ("\n//# sourceURL=" + encodeURI(filename))
+            : col + "\n//# sourceURL=<anonymous>");
+      try {
+        var fn = (0, eval)(col)[name];
+      } catch (x) {
+        fn = function (_) {
+          return _();
+        };
+      }
+      return fn;
+    }
+    function buildFakeCallStack(response, stack, environmentName, innerCall) {
+      for (var i = 0; i < stack.length; i++) {
+        var frame = stack[i],
+          frameKey = frame.join("-") + "-" + environmentName,
+          fn = fakeFunctionCache.get(frameKey);
+        if (void 0 === fn) {
+          fn = frame[0];
+          var filename = frame[1],
+            line = frame[2];
+          frame = frame[3];
+          var findSourceMapURL = response._debugFindSourceMapURL;
+          findSourceMapURL = findSourceMapURL
+            ? findSourceMapURL(filename, environmentName)
+            : null;
+          fn = createFakeFunction(
+            fn,
+            filename,
+            findSourceMapURL,
+            line,
+            frame,
+            environmentName
+          );
+          fakeFunctionCache.set(frameKey, fn);
+        }
+        innerCall = fn.bind(null, innerCall);
+      }
+      return innerCall;
+    }
+    function getRootTask(response, childEnvironmentName) {
+      var rootTask = response._debugRootTask;
+      return rootTask
+        ? response._rootEnvironmentName !== childEnvironmentName
+          ? ((response = console.createTask.bind(
+              console,
+              '"use ' + childEnvironmentName.toLowerCase() + '"'
+            )),
+            rootTask.run(response))
+          : rootTask
+        : null;
+    }
+    function initializeFakeTask(response, debugInfo, childEnvironmentName) {
+      if (!supportsCreateTask || null == debugInfo.stack) return null;
+      var stack = debugInfo.stack,
+        env =
+          null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
+      if (env !== childEnvironmentName)
+        return (
+          (debugInfo =
+            null == debugInfo.owner
+              ? null
+              : initializeFakeTask(response, debugInfo.owner, env)),
+          buildFakeTask(
+            response,
+            debugInfo,
+            stack,
+            '"use ' + childEnvironmentName.toLowerCase() + '"',
+            env
+          )
+        );
+      childEnvironmentName = debugInfo.debugTask;
+      if (void 0 !== childEnvironmentName) return childEnvironmentName;
+      childEnvironmentName =
+        null == debugInfo.owner
+          ? null
+          : initializeFakeTask(response, debugInfo.owner, env);
+      return (debugInfo.debugTask = buildFakeTask(
+        response,
+        childEnvironmentName,
+        stack,
+        "<" + (debugInfo.name || "...") + ">",
+        env
+      ));
+    }
+    function buildFakeTask(response, ownerTask, stack, taskName, env) {
+      taskName = console.createTask.bind(console, taskName);
+      stack = buildFakeCallStack(response, stack, env, taskName);
+      return null === ownerTask
+        ? ((response = getRootTask(response, env)),
+          null != response ? response.run(stack) : stack())
+        : ownerTask.run(stack);
+    }
+    function fakeJSXCallSite() {
+      return Error("react-stack-top-frame");
+    }
+    function initializeFakeStack(response, debugInfo) {
+      void 0 === debugInfo.debugStack &&
+        (null != debugInfo.stack &&
+          (debugInfo.debugStack = createFakeJSXCallStackInDEV(
+            response,
+            debugInfo.stack,
+            null == debugInfo.env ? "" : debugInfo.env
+          )),
+        null != debugInfo.owner &&
+          initializeFakeStack(response, debugInfo.owner));
+    }
+    function resolveDebugInfo(response, id, debugInfo) {
+      var env =
+        void 0 === debugInfo.env
+          ? response._rootEnvironmentName
+          : debugInfo.env;
+      void 0 !== debugInfo.stack &&
+        initializeFakeTask(response, debugInfo, env);
+      null === debugInfo.owner && null != response._debugRootOwner
+        ? ((env = debugInfo),
+          (env.owner = response._debugRootOwner),
+          (env.debugStack = response._debugRootStack))
+        : void 0 !== debugInfo.stack &&
+          initializeFakeStack(response, debugInfo);
+      "number" === typeof debugInfo.time &&
+        (debugInfo = { time: debugInfo.time + response._timeOrigin });
+      response = getChunk(response, id);
+      (response._debugInfo || (response._debugInfo = [])).push(debugInfo);
+    }
+    function getCurrentStackInDEV() {
+      var owner = currentOwnerInDEV;
+      if (null === owner) return "";
+      try {
+        var info = "";
+        if (owner.owner || "string" !== typeof owner.name) {
+          for (; owner; ) {
+            var ownerStack = owner.debugStack;
+            if (null != ownerStack) {
+              if ((owner = owner.owner)) {
+                var JSCompiler_temp_const = info;
+                var error = ownerStack,
+                  prevPrepareStackTrace = Error.prepareStackTrace;
+                Error.prepareStackTrace = void 0;
+                var stack = error.stack;
+                Error.prepareStackTrace = prevPrepareStackTrace;
+                stack.startsWith("Error: react-stack-top-frame\n") &&
+                  (stack = stack.slice(29));
+                var idx = stack.indexOf("\n");
+                -1 !== idx && (stack = stack.slice(idx + 1));
+                idx = stack.indexOf("react-stack-bottom-frame");
+                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                var JSCompiler_inline_result =
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                info =
+                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+              }
+            } else break;
+          }
+          var JSCompiler_inline_result$jscomp$0 = info;
+        } else {
+          JSCompiler_temp_const = owner.name;
+          if (void 0 === prefix)
+            try {
+              throw Error();
+            } catch (x) {
+              (prefix =
+                ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
+                ""),
+                (suffix =
+                  -1 < x.stack.indexOf("\n    at")
+                    ? " (<anonymous>)"
+                    : -1 < x.stack.indexOf("@")
+                      ? "@unknown:0:0"
+                      : "");
+            }
+          JSCompiler_inline_result$jscomp$0 =
+            "\n" + prefix + JSCompiler_temp_const + suffix;
+        }
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
+    }
+    function resolveConsoleEntry(response, value) {
+      if (response._replayConsole) {
+        var payload = JSON.parse(value, response._fromJSON);
+        value = payload[0];
+        var stackTrace = payload[1],
+          owner = payload[2],
+          env = payload[3];
+        payload = payload.slice(4);
+        replayConsoleWithCallStackInDEV(
+          response,
+          value,
+          stackTrace,
+          owner,
+          env,
+          payload
+        );
+      }
+    }
+    function mergeBuffer(buffer, lastChunk) {
+      for (
+        var l = buffer.length, byteLength = lastChunk.length, i = 0;
+        i < l;
+        i++
+      )
+        byteLength += buffer[i].byteLength;
+      byteLength = new Uint8Array(byteLength);
+      for (var _i2 = (i = 0); _i2 < l; _i2++) {
+        var chunk = buffer[_i2];
+        byteLength.set(chunk, i);
+        i += chunk.byteLength;
+      }
+      byteLength.set(lastChunk, i);
+      return byteLength;
+    }
+    function resolveTypedArray(
+      response,
+      id,
+      buffer,
+      lastChunk,
+      constructor,
+      bytesPerElement
+    ) {
+      buffer =
+        0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
+          ? lastChunk
+          : mergeBuffer(buffer, lastChunk);
+      constructor = new constructor(
+        buffer.buffer,
+        buffer.byteOffset,
+        buffer.byteLength / bytesPerElement
+      );
+      resolveBuffer(response, id, constructor);
+    }
+    function flushComponentPerformance(
+      response,
+      root,
+      trackIdx$jscomp$0,
+      trackTime,
+      parentEndTime
+    ) {
+      if (!isArrayImpl(root._children)) {
+        response = root._children;
+        root = response.endTime;
+        if (
+          -Infinity < parentEndTime &&
+          parentEndTime < root &&
+          null !== response.component
+        ) {
+          var trackIdx = trackIdx$jscomp$0,
+            startTime = parentEndTime;
+          if (supportsUserTiming && 0 <= root && 10 > trackIdx) {
+            var name = response.component.name;
+            reusableComponentDevToolDetails.color = "tertiary-light";
+            reusableComponentDevToolDetails.track = trackNames[trackIdx];
+            reusableComponentOptions.start = 0 > startTime ? 0 : startTime;
+            reusableComponentOptions.end = root;
+            performance.measure(name + " [deduped]", reusableComponentOptions);
+          }
+        }
+        response.track = trackIdx$jscomp$0;
+        return response;
+      }
+      var children = root._children;
+      "resolved_model" === root.status && initializeModelChunk(root);
+      if ((trackIdx = root._debugInfo)) {
+        for (startTime = 1; startTime < trackIdx.length; startTime++)
+          if (
+            "string" === typeof trackIdx[startTime].name &&
+            ((name = trackIdx[startTime - 1]), "number" === typeof name.time)
+          ) {
+            startTime = name.time;
+            startTime < trackTime && trackIdx$jscomp$0++;
+            trackTime = startTime;
+            break;
+          }
+        for (startTime = trackIdx.length - 1; 0 <= startTime; startTime--)
+          (name = trackIdx[startTime]),
+            "number" === typeof name.time &&
+              name.time > parentEndTime &&
+              (parentEndTime = name.time);
+      }
+      startTime = {
+        track: trackIdx$jscomp$0,
+        endTime: -Infinity,
+        component: null
+      };
+      root._children = startTime;
+      name = -Infinity;
+      var childTrackIdx = trackIdx$jscomp$0,
+        childTrackTime = trackTime;
+      for (trackTime = 0; trackTime < children.length; trackTime++) {
+        childTrackTime = flushComponentPerformance(
+          response,
+          children[trackTime],
+          childTrackIdx,
+          childTrackTime,
+          parentEndTime
+        );
+        null !== childTrackTime.component &&
+          (startTime.component = childTrackTime.component);
+        childTrackIdx = childTrackTime.track;
+        var childEndTime = childTrackTime.endTime;
+        childTrackTime = childEndTime;
+        childEndTime > name && (name = childEndTime);
+      }
+      if (trackIdx)
+        for (
+          parentEndTime = 0, childTrackIdx = !0, children = trackIdx.length - 1;
+          0 <= children;
+          children--
+        )
+          if (
+            ((trackTime = trackIdx[children]),
+            "number" === typeof trackTime.time &&
+              ((parentEndTime = trackTime.time),
+              parentEndTime > name && (name = parentEndTime)),
+            "string" === typeof trackTime.name && 0 < children)
+          ) {
+            childTrackTime = trackIdx[children - 1];
+            if ("number" === typeof childTrackTime.time) {
+              childTrackTime = childTrackTime.time;
+              if (
+                childTrackIdx &&
+                "rejected" === root.status &&
+                root.reason !== response._closedReason
+              ) {
+                var componentInfo = trackTime;
+                childTrackIdx = trackIdx$jscomp$0;
+                childEndTime = name;
+                var rootEnv = response._rootEnvironmentName,
+                  error = root.reason;
+                if (supportsUserTiming) {
+                  var properties = [];
+                  properties.push([
+                    "Error",
+                    "object" === typeof error &&
+                    null !== error &&
+                    "string" === typeof error.message
+                      ? String(error.message)
+                      : String(error)
+                  ]);
+                  error = componentInfo.env;
+                  componentInfo = componentInfo.name;
+                  componentInfo =
+                    error === rootEnv || void 0 === error
+                      ? componentInfo
+                      : componentInfo + " [" + error + "]";
+                  performance.measure(componentInfo, {
+                    start: 0 > childTrackTime ? 0 : childTrackTime,
+                    end: childEndTime,
+                    detail: {
+                      devtools: {
+                        color: "error",
+                        track: trackNames[childTrackIdx],
+                        trackGroup: "Server Components \u269b",
+                        tooltipText: componentInfo + " Errored",
+                        properties: properties
+                      }
+                    }
+                  });
+                }
+              } else
+                (childTrackIdx = trackIdx$jscomp$0),
+                  (childEndTime = name),
+                  supportsUserTiming &&
+                    0 <= childEndTime &&
+                    10 > childTrackIdx &&
+                    ((properties = trackTime.env),
+                    (componentInfo = trackTime.name),
+                    (rootEnv = properties === response._rootEnvironmentName),
+                    (error = parentEndTime - childTrackTime),
+                    (reusableComponentDevToolDetails.color =
+                      0.5 > error
+                        ? rootEnv
+                          ? "primary-light"
+                          : "secondary-light"
+                        : 50 > error
+                          ? rootEnv
+                            ? "primary"
+                            : "secondary"
+                          : 500 > error
+                            ? rootEnv
+                              ? "primary-dark"
+                              : "secondary-dark"
+                            : "error"),
+                    (reusableComponentDevToolDetails.track =
+                      trackNames[childTrackIdx]),
+                    (reusableComponentOptions.start =
+                      0 > childTrackTime ? 0 : childTrackTime),
+                    (reusableComponentOptions.end = childEndTime),
+                    performance.measure(
+                      rootEnv || void 0 === properties
+                        ? componentInfo
+                        : componentInfo + " [" + properties + "]",
+                      reusableComponentOptions
+                    ));
+              startTime.component = trackTime;
+            }
+            childTrackIdx = !1;
+          }
+      startTime.endTime = name;
+      return startTime;
+    }
+    function processFullBinaryRow(response, id, tag, buffer, chunk) {
+      switch (tag) {
+        case 65:
+          resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+          return;
+        case 79:
+          resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+          return;
+        case 111:
+          resolveBuffer(
+            response,
+            id,
+            0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+          );
+          return;
+        case 85:
+          resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+          return;
+        case 83:
+          resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+          return;
+        case 115:
+          resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+          return;
+        case 76:
+          resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+          return;
+        case 108:
+          resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+          return;
+        case 71:
+          resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+          return;
+        case 103:
+          resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+          return;
+        case 77:
+          resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+          return;
+        case 109:
+          resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+          return;
+        case 86:
+          resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+          return;
+      }
+      for (
+        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        i < buffer.length;
+        i++
+      )
+        row += stringDecoder.decode(buffer[i], decoderOptions);
+      row += stringDecoder.decode(chunk);
+      processFullStringRow(response, id, tag, row);
+    }
+    function processFullStringRow(response, id, tag, row) {
+      switch (tag) {
+        case 73:
+          resolveModule(response, id, row);
+          break;
+        case 72:
+          resolveHint(response, row[0], row.slice(1));
+          break;
+        case 69:
+          row = JSON.parse(row);
+          tag = resolveErrorDev(response, row);
+          tag.digest = row.digest;
+          row = response._chunks;
+          var chunk = row.get(id);
+          chunk
+            ? triggerErrorOnChunk(chunk, tag)
+            : row.set(id, createErrorChunk(response, tag));
+          break;
+        case 84:
+          resolveText(response, id, row);
+          break;
+        case 78:
+          response._timeOrigin = +row - performance.timeOrigin;
+          break;
+        case 68:
+          tag = new ReactPromise("resolved_model", row, null, response);
+          initializeModelChunk(tag);
+          "fulfilled" === tag.status
+            ? resolveDebugInfo(response, id, tag.value)
+            : tag.then(
+                function (v) {
+                  return resolveDebugInfo(response, id, v);
+                },
+                function () {}
+              );
+          break;
+        case 87:
+          resolveConsoleEntry(response, row);
+          break;
+        case 82:
+          startReadableStream(response, id, void 0);
+          break;
+        case 114:
+          startReadableStream(response, id, "bytes");
+          break;
+        case 88:
+          startAsyncIterable(response, id, !1);
+          break;
+        case 120:
+          startAsyncIterable(response, id, !0);
+          break;
+        case 67:
+          stopStream(response, id, row);
+          break;
+        case 80:
+          tag = JSON.parse(row);
+          resolvePostponeDev(response, id, tag.reason, tag.stack, tag.env);
+          break;
+        default:
+          resolveModel(response, id, row);
+      }
+    }
+    function createFromJSONCallback(response) {
+      return function (key, value) {
+        if ("string" === typeof value)
+          return parseModelString(response, this, key, value);
+        if ("object" === typeof value && null !== value) {
+          if (value[0] === REACT_ELEMENT_TYPE) {
+            var type = value[1];
+            key = value[4];
+            var stack = value[5],
+              validated = value[6];
+            value = {
+              $$typeof: REACT_ELEMENT_TYPE,
+              type: type,
+              key: value[2],
+              props: value[3],
+              _owner: null === key ? response._debugRootOwner : key
+            };
+            Object.defineProperty(value, "ref", {
+              enumerable: !1,
+              get: nullRefGetter
+            });
+            value._store = {};
+            Object.defineProperty(value._store, "validated", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: validated
+            });
+            Object.defineProperty(value, "_debugInfo", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: null
+            });
+            validated = response._rootEnvironmentName;
+            null !== key && null != key.env && (validated = key.env);
+            var normalizedStackTrace = null;
+            null === key && null != response._debugRootStack
+              ? (normalizedStackTrace = response._debugRootStack)
+              : null !== stack &&
+                (normalizedStackTrace = createFakeJSXCallStackInDEV(
+                  response,
+                  stack,
+                  validated
+                ));
+            Object.defineProperty(value, "_debugStack", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: normalizedStackTrace
+            });
+            normalizedStackTrace = null;
+            supportsCreateTask &&
+              null !== stack &&
+              ((type = console.createTask.bind(console, getTaskName(type))),
+              (stack = buildFakeCallStack(response, stack, validated, type)),
+              (type =
+                null === key
+                  ? null
+                  : initializeFakeTask(response, key, validated)),
+              null === type
+                ? ((type = response._debugRootTask),
+                  (normalizedStackTrace =
+                    null != type ? type.run(stack) : stack()))
+                : (normalizedStackTrace = type.run(stack)));
+            Object.defineProperty(value, "_debugTask", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: normalizedStackTrace
+            });
+            null !== key && initializeFakeStack(response, key);
+            null !== initializingHandler
+              ? ((stack = initializingHandler),
+                (initializingHandler = stack.parent),
+                stack.errored
+                  ? ((key = createErrorChunk(response, stack.value)),
+                    (stack = {
+                      name: getComponentNameFromType(value.type) || "",
+                      owner: value._owner
+                    }),
+                    (stack.debugStack = value._debugStack),
+                    supportsCreateTask && (stack.debugTask = value._debugTask),
+                    (key._debugInfo = [stack]),
+                    (value = createLazyChunkWrapper(key)))
+                  : 0 < stack.deps &&
+                    ((key = new ReactPromise("blocked", null, null, response)),
+                    (stack.value = value),
+                    (stack.chunk = key),
+                    (value = Object.freeze.bind(Object, value.props)),
+                    key.then(value, value),
+                    (value = createLazyChunkWrapper(key))))
+              : Object.freeze(value.props);
+          }
+          return value;
+        }
+        return value;
+      };
+    }
+    function createResponseFromOptions(options) {
+      return new ResponseInstance(
+        options && options.moduleBaseURL ? options.moduleBaseURL : "",
+        null,
+        null,
+        options && options.callServer ? options.callServer : void 0,
+        void 0,
+        void 0,
+        options && options.temporaryReferences
+          ? options.temporaryReferences
+          : void 0,
+        options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
+        options ? !1 !== options.replayConsoleLogs : !0,
+        options && options.environmentName ? options.environmentName : void 0
+      );
+    }
+    function startReadingFromStream(response, stream) {
+      function progress(_ref) {
+        var value = _ref.value;
+        if (_ref.done) reportGlobalError(response, Error("Connection closed."));
+        else {
+          var i = 0,
+            rowState = response._rowState;
+          _ref = response._rowID;
+          for (
+            var rowTag = response._rowTag,
+              rowLength = response._rowLength,
+              buffer = response._buffer,
+              chunkLength = value.length;
+            i < chunkLength;
+
+          ) {
+            var lastIdx = -1;
+            switch (rowState) {
+              case 0:
+                lastIdx = value[i++];
+                58 === lastIdx
+                  ? (rowState = 1)
+                  : (_ref =
+                      (_ref << 4) |
+                      (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+                continue;
+              case 1:
+                rowState = value[i];
+                84 === rowState ||
+                65 === rowState ||
+                79 === rowState ||
+                111 === rowState ||
+                85 === rowState ||
+                83 === rowState ||
+                115 === rowState ||
+                76 === rowState ||
+                108 === rowState ||
+                71 === rowState ||
+                103 === rowState ||
+                77 === rowState ||
+                109 === rowState ||
+                86 === rowState
+                  ? ((rowTag = rowState), (rowState = 2), i++)
+                  : (64 < rowState && 91 > rowState) ||
+                      35 === rowState ||
+                      114 === rowState ||
+                      120 === rowState
+                    ? ((rowTag = rowState), (rowState = 3), i++)
+                    : ((rowTag = 0), (rowState = 3));
+                continue;
+              case 2:
+                lastIdx = value[i++];
+                44 === lastIdx
+                  ? (rowState = 4)
+                  : (rowLength =
+                      (rowLength << 4) |
+                      (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+                continue;
+              case 3:
+                lastIdx = value.indexOf(10, i);
+                break;
+              case 4:
+                (lastIdx = i + rowLength),
+                  lastIdx > value.length && (lastIdx = -1);
+            }
+            var offset = value.byteOffset + i;
+            if (-1 < lastIdx)
+              (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),
+                processFullBinaryRow(response, _ref, rowTag, buffer, rowLength),
+                (i = lastIdx),
+                3 === rowState && i++,
+                (rowLength = _ref = rowTag = rowState = 0),
+                (buffer.length = 0);
+            else {
+              value = new Uint8Array(
+                value.buffer,
+                offset,
+                value.byteLength - i
+              );
+              buffer.push(value);
+              rowLength -= value.byteLength;
+              break;
+            }
+          }
+          response._rowState = rowState;
+          response._rowID = _ref;
+          response._rowTag = rowTag;
+          response._rowLength = rowLength;
+          return reader.read().then(progress).catch(error);
+        }
+      }
+      function error(e) {
+        reportGlobalError(response, e);
+      }
+      var reader = stream.getReader();
+      reader.read().then(progress).catch(error);
+    }
+    var React = require("react"),
+      ReactDOM = require("react-dom"),
+      decoderOptions = { stream: !0 },
+      bind = Function.prototype.bind,
+      asyncModuleCache = new Map(),
+      ReactDOMSharedInternals =
+        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
+      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
+      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
+    Symbol.for("react.provider");
+    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
+      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+      REACT_MEMO_TYPE = Symbol.for("react.memo"),
+      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
+      isArrayImpl = Array.isArray,
+      getPrototypeOf = Object.getPrototypeOf,
+      jsxPropsParents = new WeakMap(),
+      jsxChildrenParents = new WeakMap(),
+      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      ObjectPrototype = Object.prototype,
+      knownServerReferences = new WeakMap(),
+      fakeServerFunctionIdx = 0,
+      v8FrameRegExp =
+        /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
+      jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
+      supportsUserTiming =
+        "undefined" !== typeof performance &&
+        "function" === typeof performance.measure,
+      componentsTrackMarker = {
+        startTime: 0.001,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Primary",
+            trackGroup: "Server Components \u269b"
+          }
+        }
+      },
+      reusableComponentDevToolDetails = {
+        color: "primary",
+        track: "",
+        trackGroup: "Server Components \u269b"
+      },
+      reusableComponentOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableComponentDevToolDetails }
+      },
+      trackNames =
+        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
+          " "
+        ),
+      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      prefix,
+      suffix;
+    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    var ReactSharedInteralsServer =
+        React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      ReactSharedInternals =
+        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ||
+        ReactSharedInteralsServer;
+    ReactPromise.prototype = Object.create(Promise.prototype);
+    ReactPromise.prototype.then = function (resolve, reject) {
+      switch (this.status) {
+        case "resolved_model":
+          initializeModelChunk(this);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(this);
+      }
+      switch (this.status) {
+        case "fulfilled":
+          resolve(this.value);
+          break;
+        case "pending":
+        case "blocked":
+          resolve &&
+            (null === this.value && (this.value = []),
+            this.value.push(resolve));
+          reject &&
+            (null === this.reason && (this.reason = []),
+            this.reason.push(reject));
+          break;
+        default:
+          reject && reject(this.reason);
+      }
+    };
+    var initializingHandler = null,
+      initializingChunk = null,
+      supportsCreateTask = !!console.createTask,
+      fakeFunctionCache = new Map(),
+      fakeFunctionIdx = 0,
+      createFakeJSXCallStack = {
+        "react-stack-bottom-frame": function (
+          response,
+          stack,
+          environmentName
+        ) {
+          return buildFakeCallStack(
+            response,
+            stack,
+            environmentName,
+            fakeJSXCallSite
+          )();
+        }
+      },
+      createFakeJSXCallStackInDEV = createFakeJSXCallStack[
+        "react-stack-bottom-frame"
+      ].bind(createFakeJSXCallStack),
+      currentOwnerInDEV = null,
+      replayConsoleWithCallStack = {
+        "react-stack-bottom-frame": function (
+          response,
+          methodName,
+          stackTrace,
+          owner,
+          env,
+          args
+        ) {
+          var prevStack = ReactSharedInternals.getCurrentStack;
+          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
+          currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;
+          try {
+            a: {
+              var offset = 0;
+              switch (methodName) {
+                case "dir":
+                case "dirxml":
+                case "groupEnd":
+                case "table":
+                  var JSCompiler_inline_result = bind.apply(
+                    console[methodName],
+                    [console].concat(args)
+                  );
+                  break a;
+                case "assert":
+                  offset = 1;
+              }
+              var newArgs = args.slice(0);
+              "string" === typeof newArgs[offset]
+                ? newArgs.splice(
+                    offset,
+                    1,
+                    "%c%s%c " + newArgs[offset],
+                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
+                    " " + env + " ",
+                    ""
+                  )
+                : newArgs.splice(
+                    offset,
+                    0,
+                    "%c%s%c ",
+                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
+                    " " + env + " ",
+                    ""
+                  );
+              newArgs.unshift(console);
+              JSCompiler_inline_result = bind.apply(
+                console[methodName],
+                newArgs
+              );
+            }
+            var callStack = buildFakeCallStack(
+              response,
+              stackTrace,
+              env,
+              JSCompiler_inline_result
+            );
+            if (null != owner) {
+              var task = initializeFakeTask(response, owner, env);
+              initializeFakeStack(response, owner);
+              if (null !== task) {
+                task.run(callStack);
+                return;
+              }
+            }
+            var rootTask = getRootTask(response, env);
+            null != rootTask ? rootTask.run(callStack) : callStack();
+          } finally {
+            (currentOwnerInDEV = null),
+              (ReactSharedInternals.getCurrentStack = prevStack);
+          }
+        }
+      },
+      replayConsoleWithCallStackInDEV = replayConsoleWithCallStack[
+        "react-stack-bottom-frame"
+      ].bind(replayConsoleWithCallStack);
+    (function (internals) {
+      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
+      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+      if (hook.isDisabled || !hook.supportsFlight) return !0;
+      try {
+        hook.inject(internals);
+      } catch (err) {
+        console.error("React instrumentation encountered an error: %s.", err);
+      }
+      return hook.checkDCE ? !0 : !1;
+    })({
+      bundleType: 1,
+      version: "19.1.0-experimental-b3a95caf-20250113",
+      rendererPackageName: "react-server-dom-esm",
+      currentDispatcherRef: ReactSharedInternals,
+      reconcilerVersion: "19.1.0-experimental-b3a95caf-20250113",
+      getCurrentComponentInfo: function () {
+        return currentOwnerInDEV;
+      }
+    });
+    exports.createFromFetch = function (promiseForResponse, options) {
+      var response = createResponseFromOptions(options);
+      promiseForResponse.then(
+        function (r) {
+          startReadingFromStream(response, r.body);
+        },
+        function (e) {
+          reportGlobalError(response, e);
+        }
+      );
+      return getChunk(response, 0);
+    };
+    exports.createFromReadableStream = function (stream, options) {
+      options = createResponseFromOptions(options);
+      startReadingFromStream(options, stream);
+      return getChunk(options, 0);
+    };
+    exports.createServerReference = function (
+      id,
+      callServer,
+      encodeFormAction,
+      findSourceMapURL,
+      functionName
+    ) {
+      function action() {
+        var args = Array.prototype.slice.call(arguments);
+        return callServer(id, args);
+      }
+      var location = parseStackLocation(Error("react-stack-top-frame"));
+      if (null !== location) {
+        encodeFormAction = location[1];
+        var line = location[2];
+        location = location[3];
+        findSourceMapURL =
+          null == findSourceMapURL
+            ? null
+            : findSourceMapURL(encodeFormAction, "Client");
+        action = createFakeServerFunction(
+          functionName || "",
+          encodeFormAction,
+          findSourceMapURL,
+          line,
+          location,
+          "Client",
+          action
+        );
+      }
+      registerServerReference(action, { id: id, bound: null });
+      return action;
+    };
+    exports.createTemporaryReferenceSet = function () {
+      return new Map();
+    };
+    exports.encodeReply = function (value, options) {
+      return new Promise(function (resolve, reject) {
+        var abort = processReply(
+          value,
+          "",
+          options && options.temporaryReferences
+            ? options.temporaryReferences
+            : void 0,
+          resolve,
+          reject
+        );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(signal.reason);
+          else {
+            var listener = function () {
+              abort(signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+      });
+    };
+  })();
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.production.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.production.js
new file mode 100644
index 0000000..8866772
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.browser.production.js
@@ -0,0 +1,1594 @@
+/**
+ * @license React
+ * react-server-dom-esm-client.browser.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+var ReactDOM = require("react-dom"),
+  decoderOptions = { stream: !0 };
+function resolveServerReference(config, id) {
+  var idx = id.lastIndexOf("#"),
+    exportName = id.slice(idx + 1);
+  id = id.slice(0, idx);
+  if (!id.startsWith(config))
+    throw Error(
+      "Attempted to load a Server Reference outside the hosted root."
+    );
+  return { specifier: id, name: exportName };
+}
+var asyncModuleCache = new Map();
+function preloadModule(metadata) {
+  var existingPromise = asyncModuleCache.get(metadata.specifier);
+  if (existingPromise)
+    return "fulfilled" === existingPromise.status ? null : existingPromise;
+  var modulePromise = import(metadata.specifier);
+  modulePromise.then(
+    function (value) {
+      modulePromise.status = "fulfilled";
+      modulePromise.value = value;
+    },
+    function (reason) {
+      modulePromise.status = "rejected";
+      modulePromise.reason = reason;
+    }
+  );
+  asyncModuleCache.set(metadata.specifier, modulePromise);
+  return modulePromise;
+}
+function requireModule(metadata) {
+  var moduleExports = asyncModuleCache.get(metadata.specifier);
+  if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
+  else throw moduleExports.reason;
+  return moduleExports[metadata.name];
+}
+var ReactDOMSharedInternals =
+    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+function getIteratorFn(maybeIterable) {
+  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  maybeIterable =
+    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+    maybeIterable["@@iterator"];
+  return "function" === typeof maybeIterable ? maybeIterable : null;
+}
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  isArrayImpl = Array.isArray,
+  getPrototypeOf = Object.getPrototypeOf,
+  ObjectPrototype = Object.prototype,
+  knownServerReferences = new WeakMap();
+function serializeNumber(number) {
+  return Number.isFinite(number)
+    ? 0 === number && -Infinity === 1 / number
+      ? "$-0"
+      : number
+    : Infinity === number
+      ? "$Infinity"
+      : -Infinity === number
+        ? "$-Infinity"
+        : "$NaN";
+}
+function processReply(
+  root,
+  formFieldPrefix,
+  temporaryReferences,
+  resolve,
+  reject
+) {
+  function serializeTypedArray(tag, typedArray) {
+    typedArray = new Blob([
+      new Uint8Array(
+        typedArray.buffer,
+        typedArray.byteOffset,
+        typedArray.byteLength
+      )
+    ]);
+    var blobId = nextPartId++;
+    null === formData && (formData = new FormData());
+    formData.append(formFieldPrefix + blobId, typedArray);
+    return "$" + tag + blobId.toString(16);
+  }
+  function serializeBinaryReader(reader) {
+    function progress(entry) {
+      entry.done
+        ? ((entry = nextPartId++),
+          data.append(formFieldPrefix + entry, new Blob(buffer)),
+          data.append(
+            formFieldPrefix + streamId,
+            '"$o' + entry.toString(16) + '"'
+          ),
+          data.append(formFieldPrefix + streamId, "C"),
+          pendingParts--,
+          0 === pendingParts && resolve(data))
+        : (buffer.push(entry.value),
+          reader.read(new Uint8Array(1024)).then(progress, reject));
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++,
+      buffer = [];
+    reader.read(new Uint8Array(1024)).then(progress, reject);
+    return "$r" + streamId.toString(16);
+  }
+  function serializeReader(reader) {
+    function progress(entry) {
+      if (entry.done)
+        data.append(formFieldPrefix + streamId, "C"),
+          pendingParts--,
+          0 === pendingParts && resolve(data);
+      else
+        try {
+          var partJSON = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON);
+          reader.read().then(progress, reject);
+        } catch (x) {
+          reject(x);
+        }
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+    reader.read().then(progress, reject);
+    return "$R" + streamId.toString(16);
+  }
+  function serializeReadableStream(stream) {
+    try {
+      var binaryReader = stream.getReader({ mode: "byob" });
+    } catch (x) {
+      return serializeReader(stream.getReader());
+    }
+    return serializeBinaryReader(binaryReader);
+  }
+  function serializeAsyncIterable(iterable, iterator) {
+    function progress(entry) {
+      if (entry.done) {
+        if (void 0 === entry.value)
+          data.append(formFieldPrefix + streamId, "C");
+        else
+          try {
+            var partJSON = JSON.stringify(entry.value, resolveToJSON);
+            data.append(formFieldPrefix + streamId, "C" + partJSON);
+          } catch (x) {
+            reject(x);
+            return;
+          }
+        pendingParts--;
+        0 === pendingParts && resolve(data);
+      } else
+        try {
+          var partJSON$22 = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON$22);
+          iterator.next().then(progress, reject);
+        } catch (x$23) {
+          reject(x$23);
+        }
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+    iterable = iterable === iterator;
+    iterator.next().then(progress, reject);
+    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+  }
+  function resolveToJSON(key, value) {
+    if (null === value) return null;
+    if ("object" === typeof value) {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+            var parentReference = writtenObjects.get(this);
+            if (void 0 !== parentReference)
+              return (
+                temporaryReferences.set(parentReference + ":" + key, value),
+                "$T"
+              );
+          }
+          throw Error(
+            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+          );
+        case REACT_LAZY_TYPE:
+          parentReference = value._payload;
+          var init = value._init;
+          null === formData && (formData = new FormData());
+          pendingParts++;
+          try {
+            var resolvedModel = init(parentReference),
+              lazyId = nextPartId++,
+              partJSON = serializeModel(resolvedModel, lazyId);
+            formData.append(formFieldPrefix + lazyId, partJSON);
+            return "$" + lazyId.toString(16);
+          } catch (x) {
+            if (
+              "object" === typeof x &&
+              null !== x &&
+              "function" === typeof x.then
+            ) {
+              pendingParts++;
+              var lazyId$24 = nextPartId++;
+              parentReference = function () {
+                try {
+                  var partJSON$25 = serializeModel(value, lazyId$24),
+                    data$26 = formData;
+                  data$26.append(formFieldPrefix + lazyId$24, partJSON$25);
+                  pendingParts--;
+                  0 === pendingParts && resolve(data$26);
+                } catch (reason) {
+                  reject(reason);
+                }
+              };
+              x.then(parentReference, parentReference);
+              return "$" + lazyId$24.toString(16);
+            }
+            reject(x);
+            return null;
+          } finally {
+            pendingParts--;
+          }
+      }
+      if ("function" === typeof value.then) {
+        null === formData && (formData = new FormData());
+        pendingParts++;
+        var promiseId = nextPartId++;
+        value.then(function (partValue) {
+          try {
+            var partJSON$28 = serializeModel(partValue, promiseId);
+            partValue = formData;
+            partValue.append(formFieldPrefix + promiseId, partJSON$28);
+            pendingParts--;
+            0 === pendingParts && resolve(partValue);
+          } catch (reason) {
+            reject(reason);
+          }
+        }, reject);
+        return "$@" + promiseId.toString(16);
+      }
+      parentReference = writtenObjects.get(value);
+      if (void 0 !== parentReference)
+        if (modelRoot === value) modelRoot = null;
+        else return parentReference;
+      else
+        -1 === key.indexOf(":") &&
+          ((parentReference = writtenObjects.get(this)),
+          void 0 !== parentReference &&
+            ((key = parentReference + ":" + key),
+            writtenObjects.set(value, key),
+            void 0 !== temporaryReferences &&
+              temporaryReferences.set(key, value)));
+      if (isArrayImpl(value)) return value;
+      if (value instanceof FormData) {
+        null === formData && (formData = new FormData());
+        var data$32 = formData;
+        key = nextPartId++;
+        var prefix = formFieldPrefix + key + "_";
+        value.forEach(function (originalValue, originalKey) {
+          data$32.append(prefix + originalKey, originalValue);
+        });
+        return "$K" + key.toString(16);
+      }
+      if (value instanceof Map)
+        return (
+          (key = nextPartId++),
+          (parentReference = serializeModel(Array.from(value), key)),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + key, parentReference),
+          "$Q" + key.toString(16)
+        );
+      if (value instanceof Set)
+        return (
+          (key = nextPartId++),
+          (parentReference = serializeModel(Array.from(value), key)),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + key, parentReference),
+          "$W" + key.toString(16)
+        );
+      if (value instanceof ArrayBuffer)
+        return (
+          (key = new Blob([value])),
+          (parentReference = nextPartId++),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + parentReference, key),
+          "$A" + parentReference.toString(16)
+        );
+      if (value instanceof Int8Array) return serializeTypedArray("O", value);
+      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Uint8ClampedArray)
+        return serializeTypedArray("U", value);
+      if (value instanceof Int16Array) return serializeTypedArray("S", value);
+      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
+      if (value instanceof Int32Array) return serializeTypedArray("L", value);
+      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
+      if (value instanceof Float32Array) return serializeTypedArray("G", value);
+      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+      if (value instanceof BigInt64Array)
+        return serializeTypedArray("M", value);
+      if (value instanceof BigUint64Array)
+        return serializeTypedArray("m", value);
+      if (value instanceof DataView) return serializeTypedArray("V", value);
+      if ("function" === typeof Blob && value instanceof Blob)
+        return (
+          null === formData && (formData = new FormData()),
+          (key = nextPartId++),
+          formData.append(formFieldPrefix + key, value),
+          "$B" + key.toString(16)
+        );
+      if ((key = getIteratorFn(value)))
+        return (
+          (parentReference = key.call(value)),
+          parentReference === value
+            ? ((key = nextPartId++),
+              (parentReference = serializeModel(
+                Array.from(parentReference),
+                key
+              )),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$i" + key.toString(16))
+            : Array.from(parentReference)
+        );
+      if (
+        "function" === typeof ReadableStream &&
+        value instanceof ReadableStream
+      )
+        return serializeReadableStream(value);
+      key = value[ASYNC_ITERATOR];
+      if ("function" === typeof key)
+        return serializeAsyncIterable(value, key.call(value));
+      key = getPrototypeOf(value);
+      if (
+        key !== ObjectPrototype &&
+        (null === key || null !== getPrototypeOf(key))
+      ) {
+        if (void 0 === temporaryReferences)
+          throw Error(
+            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+          );
+        return "$T";
+      }
+      return value;
+    }
+    if ("string" === typeof value) {
+      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
+        return "$D" + value;
+      key = "$" === value[0] ? "$" + value : value;
+      return key;
+    }
+    if ("boolean" === typeof value) return value;
+    if ("number" === typeof value) return serializeNumber(value);
+    if ("undefined" === typeof value) return "$undefined";
+    if ("function" === typeof value) {
+      parentReference = knownServerReferences.get(value);
+      if (void 0 !== parentReference)
+        return (
+          (key = JSON.stringify(parentReference, resolveToJSON)),
+          null === formData && (formData = new FormData()),
+          (parentReference = nextPartId++),
+          formData.set(formFieldPrefix + parentReference, key),
+          "$F" + parentReference.toString(16)
+        );
+      if (
+        void 0 !== temporaryReferences &&
+        -1 === key.indexOf(":") &&
+        ((parentReference = writtenObjects.get(this)),
+        void 0 !== parentReference)
+      )
+        return (
+          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+        );
+      throw Error(
+        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+      );
+    }
+    if ("symbol" === typeof value) {
+      if (
+        void 0 !== temporaryReferences &&
+        -1 === key.indexOf(":") &&
+        ((parentReference = writtenObjects.get(this)),
+        void 0 !== parentReference)
+      )
+        return (
+          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+        );
+      throw Error(
+        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+      );
+    }
+    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    throw Error(
+      "Type " +
+        typeof value +
+        " is not supported as an argument to a Server Function."
+    );
+  }
+  function serializeModel(model, id) {
+    "object" === typeof model &&
+      null !== model &&
+      ((id = "$" + id.toString(16)),
+      writtenObjects.set(model, id),
+      void 0 !== temporaryReferences && temporaryReferences.set(id, model));
+    modelRoot = model;
+    return JSON.stringify(model, resolveToJSON);
+  }
+  var nextPartId = 1,
+    pendingParts = 0,
+    formData = null,
+    writtenObjects = new WeakMap(),
+    modelRoot = root,
+    json = serializeModel(root, 0);
+  null === formData
+    ? resolve(json)
+    : (formData.set(formFieldPrefix + "0", json),
+      0 === pendingParts && resolve(formData));
+  return function () {
+    0 < pendingParts &&
+      ((pendingParts = 0),
+      null === formData ? resolve(json) : resolve(formData));
+  };
+}
+function registerServerReference(proxy, reference) {
+  knownServerReferences.set(proxy, reference);
+}
+function createBoundServerReference(metaData, callServer) {
+  function action() {
+    var args = Array.prototype.slice.call(arguments);
+    return bound
+      ? "fulfilled" === bound.status
+        ? callServer(id, bound.value.concat(args))
+        : Promise.resolve(bound).then(function (boundArgs) {
+            return callServer(id, boundArgs.concat(args));
+          })
+      : callServer(id, args);
+  }
+  var id = metaData.id,
+    bound = metaData.bound;
+  registerServerReference(action, { id: id, bound: bound });
+  return action;
+}
+function ReactPromise(status, value, reason, response) {
+  this.status = status;
+  this.value = value;
+  this.reason = reason;
+  this._response = response;
+}
+ReactPromise.prototype = Object.create(Promise.prototype);
+ReactPromise.prototype.then = function (resolve, reject) {
+  switch (this.status) {
+    case "resolved_model":
+      initializeModelChunk(this);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(this);
+  }
+  switch (this.status) {
+    case "fulfilled":
+      resolve(this.value);
+      break;
+    case "pending":
+    case "blocked":
+      resolve &&
+        (null === this.value && (this.value = []), this.value.push(resolve));
+      reject &&
+        (null === this.reason && (this.reason = []), this.reason.push(reject));
+      break;
+    default:
+      reject && reject(this.reason);
+  }
+};
+function readChunk(chunk) {
+  switch (chunk.status) {
+    case "resolved_model":
+      initializeModelChunk(chunk);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(chunk);
+  }
+  switch (chunk.status) {
+    case "fulfilled":
+      return chunk.value;
+    case "pending":
+    case "blocked":
+      throw chunk;
+    default:
+      throw chunk.reason;
+  }
+}
+function createPendingChunk(response) {
+  return new ReactPromise("pending", null, null, response);
+}
+function createErrorChunk(response, error) {
+  return new ReactPromise("rejected", null, error, response);
+}
+function wakeChunk(listeners, value) {
+  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+}
+function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+  switch (chunk.status) {
+    case "fulfilled":
+      wakeChunk(resolveListeners, chunk.value);
+      break;
+    case "pending":
+    case "blocked":
+      if (chunk.value)
+        for (var i = 0; i < resolveListeners.length; i++)
+          chunk.value.push(resolveListeners[i]);
+      else chunk.value = resolveListeners;
+      if (chunk.reason) {
+        if (rejectListeners)
+          for (
+            resolveListeners = 0;
+            resolveListeners < rejectListeners.length;
+            resolveListeners++
+          )
+            chunk.reason.push(rejectListeners[resolveListeners]);
+      } else chunk.reason = rejectListeners;
+      break;
+    case "rejected":
+      rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+  }
+}
+function triggerErrorOnChunk(chunk, error) {
+  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+    chunk.reason.error(error);
+  else {
+    var listeners = chunk.reason;
+    chunk.status = "rejected";
+    chunk.reason = error;
+    null !== listeners && wakeChunk(listeners, error);
+  }
+}
+function createResolvedIteratorResultChunk(response, value, done) {
+  return new ReactPromise(
+    "resolved_model",
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    null,
+    response
+  );
+}
+function resolveIteratorResultChunk(chunk, value, done) {
+  resolveModelChunk(
+    chunk,
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+  );
+}
+function resolveModelChunk(chunk, value) {
+  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  else {
+    var resolveListeners = chunk.value,
+      rejectListeners = chunk.reason;
+    chunk.status = "resolved_model";
+    chunk.value = value;
+    null !== resolveListeners &&
+      (initializeModelChunk(chunk),
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+  }
+}
+function resolveModuleChunk(chunk, value) {
+  if ("pending" === chunk.status || "blocked" === chunk.status) {
+    var resolveListeners = chunk.value,
+      rejectListeners = chunk.reason;
+    chunk.status = "resolved_module";
+    chunk.value = value;
+    null !== resolveListeners &&
+      (initializeModuleChunk(chunk),
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+  }
+}
+var initializingHandler = null;
+function initializeModelChunk(chunk) {
+  var prevHandler = initializingHandler;
+  initializingHandler = null;
+  var resolvedModel = chunk.value;
+  chunk.status = "blocked";
+  chunk.value = null;
+  chunk.reason = null;
+  try {
+    var value = JSON.parse(resolvedModel, chunk._response._fromJSON),
+      resolveListeners = chunk.value;
+    null !== resolveListeners &&
+      ((chunk.value = null),
+      (chunk.reason = null),
+      wakeChunk(resolveListeners, value));
+    if (null !== initializingHandler) {
+      if (initializingHandler.errored) throw initializingHandler.value;
+      if (0 < initializingHandler.deps) {
+        initializingHandler.value = value;
+        initializingHandler.chunk = chunk;
+        return;
+      }
+    }
+    chunk.status = "fulfilled";
+    chunk.value = value;
+  } catch (error) {
+    (chunk.status = "rejected"), (chunk.reason = error);
+  } finally {
+    initializingHandler = prevHandler;
+  }
+}
+function initializeModuleChunk(chunk) {
+  try {
+    var value = requireModule(chunk.value);
+    chunk.status = "fulfilled";
+    chunk.value = value;
+  } catch (error) {
+    (chunk.status = "rejected"), (chunk.reason = error);
+  }
+}
+function reportGlobalError(response, error) {
+  response._closed = !0;
+  response._closedReason = error;
+  response._chunks.forEach(function (chunk) {
+    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+  });
+}
+function createLazyChunkWrapper(chunk) {
+  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };
+}
+function getChunk(response, id) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk ||
+    ((chunk = response._closed
+      ? createErrorChunk(response, response._closedReason)
+      : createPendingChunk(response)),
+    chunks.set(id, chunk));
+  return chunk;
+}
+function waitForReference(
+  referencedChunk,
+  parentObject,
+  key,
+  response,
+  map,
+  path
+) {
+  function fulfill(value) {
+    for (var i = 1; i < path.length; i++) {
+      for (; value.$$typeof === REACT_LAZY_TYPE; )
+        if (((value = value._payload), value === handler.chunk))
+          value = handler.value;
+        else if ("fulfilled" === value.status) value = value.value;
+        else {
+          path.splice(0, i - 1);
+          value.then(fulfill, reject);
+          return;
+        }
+      value = value[path[i]];
+    }
+    i = map(response, value, parentObject, key);
+    parentObject[key] = i;
+    "" === key && null === handler.value && (handler.value = i);
+    if (
+      parentObject[0] === REACT_ELEMENT_TYPE &&
+      "object" === typeof handler.value &&
+      null !== handler.value &&
+      handler.value.$$typeof === REACT_ELEMENT_TYPE
+    )
+      switch (((value = handler.value), key)) {
+        case "3":
+          value.props = i;
+      }
+    handler.deps--;
+    0 === handler.deps &&
+      ((i = handler.chunk),
+      null !== i &&
+        "blocked" === i.status &&
+        ((value = i.value),
+        (i.status = "fulfilled"),
+        (i.value = handler.value),
+        null !== value && wakeChunk(value, handler.value)));
+  }
+  function reject(error) {
+    if (!handler.errored) {
+      handler.errored = !0;
+      handler.value = error;
+      var chunk = handler.chunk;
+      null !== chunk &&
+        "blocked" === chunk.status &&
+        triggerErrorOnChunk(chunk, error);
+    }
+  }
+  if (initializingHandler) {
+    var handler = initializingHandler;
+    handler.deps++;
+  } else
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: !1
+    };
+  referencedChunk.then(fulfill, reject);
+  return null;
+}
+function loadServerReference(response, metaData, parentObject, key) {
+  if (!response._serverReferenceConfig)
+    return createBoundServerReference(metaData, response._callServer);
+  var serverReference = resolveServerReference(
+    response._serverReferenceConfig,
+    metaData.id
+  );
+  if ((response = preloadModule(serverReference)))
+    metaData.bound && (response = Promise.all([response, metaData.bound]));
+  else if (metaData.bound) response = Promise.resolve(metaData.bound);
+  else return requireModule(serverReference);
+  if (initializingHandler) {
+    var handler = initializingHandler;
+    handler.deps++;
+  } else
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: !1
+    };
+  response.then(
+    function () {
+      var resolvedValue = requireModule(serverReference);
+      if (metaData.bound) {
+        var boundArgs = metaData.bound.value.slice(0);
+        boundArgs.unshift(null);
+        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+      }
+      parentObject[key] = resolvedValue;
+      "" === key && null === handler.value && (handler.value = resolvedValue);
+      if (
+        parentObject[0] === REACT_ELEMENT_TYPE &&
+        "object" === typeof handler.value &&
+        null !== handler.value &&
+        handler.value.$$typeof === REACT_ELEMENT_TYPE
+      )
+        switch (((boundArgs = handler.value), key)) {
+          case "3":
+            boundArgs.props = resolvedValue;
+        }
+      handler.deps--;
+      0 === handler.deps &&
+        ((resolvedValue = handler.chunk),
+        null !== resolvedValue &&
+          "blocked" === resolvedValue.status &&
+          ((boundArgs = resolvedValue.value),
+          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.value = handler.value),
+          null !== boundArgs && wakeChunk(boundArgs, handler.value)));
+    },
+    function (error) {
+      if (!handler.errored) {
+        handler.errored = !0;
+        handler.value = error;
+        var chunk = handler.chunk;
+        null !== chunk &&
+          "blocked" === chunk.status &&
+          triggerErrorOnChunk(chunk, error);
+      }
+    }
+  );
+  return null;
+}
+function getOutlinedModel(response, reference, parentObject, key, map) {
+  reference = reference.split(":");
+  var id = parseInt(reference[0], 16);
+  id = getChunk(response, id);
+  switch (id.status) {
+    case "resolved_model":
+      initializeModelChunk(id);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(id);
+  }
+  switch (id.status) {
+    case "fulfilled":
+      var value = id.value;
+      for (id = 1; id < reference.length; id++) {
+        for (; value.$$typeof === REACT_LAZY_TYPE; )
+          if (((value = value._payload), "fulfilled" === value.status))
+            value = value.value;
+          else
+            return waitForReference(
+              value,
+              parentObject,
+              key,
+              response,
+              map,
+              reference.slice(id - 1)
+            );
+        value = value[reference[id]];
+      }
+      return map(response, value, parentObject, key);
+    case "pending":
+    case "blocked":
+      return waitForReference(id, parentObject, key, response, map, reference);
+    default:
+      return (
+        initializingHandler
+          ? ((initializingHandler.errored = !0),
+            (initializingHandler.value = id.reason))
+          : (initializingHandler = {
+              parent: null,
+              chunk: null,
+              value: id.reason,
+              deps: 0,
+              errored: !0
+            }),
+        null
+      );
+  }
+}
+function createMap(response, model) {
+  return new Map(model);
+}
+function createSet(response, model) {
+  return new Set(model);
+}
+function createBlob(response, model) {
+  return new Blob(model.slice(1), { type: model[0] });
+}
+function createFormData(response, model) {
+  response = new FormData();
+  for (var i = 0; i < model.length; i++)
+    response.append(model[i][0], model[i][1]);
+  return response;
+}
+function extractIterator(response, model) {
+  return model[Symbol.iterator]();
+}
+function createModel(response, model) {
+  return model;
+}
+function parseModelString(response, parentObject, key, value) {
+  if ("$" === value[0]) {
+    if ("$" === value)
+      return (
+        null !== initializingHandler &&
+          "0" === key &&
+          (initializingHandler = {
+            parent: initializingHandler,
+            chunk: null,
+            value: null,
+            deps: 0,
+            errored: !1
+          }),
+        REACT_ELEMENT_TYPE
+      );
+    switch (value[1]) {
+      case "$":
+        return value.slice(1);
+      case "L":
+        return (
+          (parentObject = parseInt(value.slice(2), 16)),
+          (response = getChunk(response, parentObject)),
+          createLazyChunkWrapper(response)
+        );
+      case "@":
+        if (2 === value.length) return new Promise(function () {});
+        parentObject = parseInt(value.slice(2), 16);
+        return getChunk(response, parentObject);
+      case "S":
+        return Symbol.for(value.slice(2));
+      case "F":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(
+            response,
+            value,
+            parentObject,
+            key,
+            loadServerReference
+          )
+        );
+      case "T":
+        parentObject = "$" + value.slice(2);
+        response = response._tempRefs;
+        if (null == response)
+          throw Error(
+            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+          );
+        return response.get(parentObject);
+      case "Q":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createMap)
+        );
+      case "W":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createSet)
+        );
+      case "B":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createBlob)
+        );
+      case "K":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createFormData)
+        );
+      case "Z":
+        return resolveErrorProd();
+      case "i":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, extractIterator)
+        );
+      case "I":
+        return Infinity;
+      case "-":
+        return "$-0" === value ? -0 : -Infinity;
+      case "N":
+        return NaN;
+      case "u":
+        return;
+      case "D":
+        return new Date(Date.parse(value.slice(2)));
+      case "n":
+        return BigInt(value.slice(2));
+      default:
+        return (
+          (value = value.slice(1)),
+          getOutlinedModel(response, value, parentObject, key, createModel)
+        );
+    }
+  }
+  return value;
+}
+function missingCall() {
+  throw Error(
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+  );
+}
+function ResponseInstance(
+  bundlerConfig,
+  serverReferenceConfig,
+  moduleLoading,
+  callServer,
+  encodeFormAction,
+  nonce,
+  temporaryReferences
+) {
+  var chunks = new Map();
+  this._bundlerConfig = bundlerConfig;
+  this._serverReferenceConfig = serverReferenceConfig;
+  this._moduleLoading = moduleLoading;
+  this._callServer = void 0 !== callServer ? callServer : missingCall;
+  this._encodeFormAction = encodeFormAction;
+  this._nonce = nonce;
+  this._chunks = chunks;
+  this._stringDecoder = new TextDecoder();
+  this._fromJSON = null;
+  this._rowLength = this._rowTag = this._rowID = this._rowState = 0;
+  this._buffer = [];
+  this._closed = !1;
+  this._closedReason = null;
+  this._tempRefs = temporaryReferences;
+  this._fromJSON = createFromJSONCallback(this);
+}
+function resolveBuffer(response, id, buffer) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk && "pending" !== chunk.status
+    ? chunk.reason.enqueueValue(buffer)
+    : chunks.set(id, new ReactPromise("fulfilled", buffer, null, response));
+}
+function resolveModule(response, id, model) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  model = JSON.parse(model, response._fromJSON);
+  var clientReference = {
+    specifier: response._bundlerConfig + model[0],
+    name: model[1]
+  };
+  if ((model = preloadModule(clientReference))) {
+    if (chunk) {
+      var blockedChunk = chunk;
+      blockedChunk.status = "blocked";
+    } else
+      (blockedChunk = new ReactPromise("blocked", null, null, response)),
+        chunks.set(id, blockedChunk);
+    model.then(
+      function () {
+        return resolveModuleChunk(blockedChunk, clientReference);
+      },
+      function (error) {
+        return triggerErrorOnChunk(blockedChunk, error);
+      }
+    );
+  } else
+    chunk
+      ? resolveModuleChunk(chunk, clientReference)
+      : chunks.set(
+          id,
+          new ReactPromise("resolved_module", clientReference, null, response)
+        );
+}
+function resolveStream(response, id, stream, controller) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk
+    ? "pending" === chunk.status &&
+      ((response = chunk.value),
+      (chunk.status = "fulfilled"),
+      (chunk.value = stream),
+      (chunk.reason = controller),
+      null !== response && wakeChunk(response, chunk.value))
+    : chunks.set(
+        id,
+        new ReactPromise("fulfilled", stream, controller, response)
+      );
+}
+function startReadableStream(response, id, type) {
+  var controller = null;
+  type = new ReadableStream({
+    type: type,
+    start: function (c) {
+      controller = c;
+    }
+  });
+  var previousBlockedChunk = null;
+  resolveStream(response, id, type, {
+    enqueueValue: function (value) {
+      null === previousBlockedChunk
+        ? controller.enqueue(value)
+        : previousBlockedChunk.then(function () {
+            controller.enqueue(value);
+          });
+    },
+    enqueueModel: function (json) {
+      if (null === previousBlockedChunk) {
+        var chunk = new ReactPromise("resolved_model", json, null, response);
+        initializeModelChunk(chunk);
+        "fulfilled" === chunk.status
+          ? controller.enqueue(chunk.value)
+          : (chunk.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            ),
+            (previousBlockedChunk = chunk));
+      } else {
+        chunk = previousBlockedChunk;
+        var chunk$52 = createPendingChunk(response);
+        chunk$52.then(
+          function (v) {
+            return controller.enqueue(v);
+          },
+          function (e) {
+            return controller.error(e);
+          }
+        );
+        previousBlockedChunk = chunk$52;
+        chunk.then(function () {
+          previousBlockedChunk === chunk$52 && (previousBlockedChunk = null);
+          resolveModelChunk(chunk$52, json);
+        });
+      }
+    },
+    close: function () {
+      if (null === previousBlockedChunk) controller.close();
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.close();
+        });
+      }
+    },
+    error: function (error) {
+      if (null === previousBlockedChunk) controller.error(error);
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.error(error);
+        });
+      }
+    }
+  });
+}
+function asyncIterator() {
+  return this;
+}
+function createIterator(next) {
+  next = { next: next };
+  next[ASYNC_ITERATOR] = asyncIterator;
+  return next;
+}
+function startAsyncIterable(response, id, iterator) {
+  var buffer = [],
+    closed = !1,
+    nextWriteIndex = 0,
+    $jscomp$compprop0 = {};
+  $jscomp$compprop0 =
+    (($jscomp$compprop0[ASYNC_ITERATOR] = function () {
+      var nextReadIndex = 0;
+      return createIterator(function (arg) {
+        if (void 0 !== arg)
+          throw Error(
+            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          );
+        if (nextReadIndex === buffer.length) {
+          if (closed)
+            return new ReactPromise(
+              "fulfilled",
+              { done: !0, value: void 0 },
+              null,
+              response
+            );
+          buffer[nextReadIndex] = createPendingChunk(response);
+        }
+        return buffer[nextReadIndex++];
+      });
+    }),
+    $jscomp$compprop0);
+  resolveStream(
+    response,
+    id,
+    iterator ? $jscomp$compprop0[ASYNC_ITERATOR]() : $jscomp$compprop0,
+    {
+      enqueueValue: function (value) {
+        if (nextWriteIndex === buffer.length)
+          buffer[nextWriteIndex] = new ReactPromise(
+            "fulfilled",
+            { done: !1, value: value },
+            null,
+            response
+          );
+        else {
+          var chunk = buffer[nextWriteIndex],
+            resolveListeners = chunk.value,
+            rejectListeners = chunk.reason;
+          chunk.status = "fulfilled";
+          chunk.value = { done: !1, value: value };
+          null !== resolveListeners &&
+            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+        }
+        nextWriteIndex++;
+      },
+      enqueueModel: function (value) {
+        nextWriteIndex === buffer.length
+          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+              response,
+              value,
+              !1
+            ))
+          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+        nextWriteIndex++;
+      },
+      close: function (value) {
+        closed = !0;
+        nextWriteIndex === buffer.length
+          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+              response,
+              value,
+              !0
+            ))
+          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+        for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+          resolveIteratorResultChunk(
+            buffer[nextWriteIndex++],
+            '"$undefined"',
+            !0
+          );
+      },
+      error: function (error) {
+        closed = !0;
+        for (
+          nextWriteIndex === buffer.length &&
+          (buffer[nextWriteIndex] = createPendingChunk(response));
+          nextWriteIndex < buffer.length;
+
+        )
+          triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+      }
+    }
+  );
+}
+function resolveErrorProd() {
+  var error = Error(
+    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+  );
+  error.stack = "Error: " + error.message;
+  return error;
+}
+function mergeBuffer(buffer, lastChunk) {
+  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)
+    byteLength += buffer[i].byteLength;
+  byteLength = new Uint8Array(byteLength);
+  for (var i$53 = (i = 0); i$53 < l; i$53++) {
+    var chunk = buffer[i$53];
+    byteLength.set(chunk, i);
+    i += chunk.byteLength;
+  }
+  byteLength.set(lastChunk, i);
+  return byteLength;
+}
+function resolveTypedArray(
+  response,
+  id,
+  buffer,
+  lastChunk,
+  constructor,
+  bytesPerElement
+) {
+  buffer =
+    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
+      ? lastChunk
+      : mergeBuffer(buffer, lastChunk);
+  constructor = new constructor(
+    buffer.buffer,
+    buffer.byteOffset,
+    buffer.byteLength / bytesPerElement
+  );
+  resolveBuffer(response, id, constructor);
+}
+function processFullBinaryRow(response, id, tag, buffer, chunk) {
+  switch (tag) {
+    case 65:
+      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+      return;
+    case 79:
+      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+      return;
+    case 111:
+      resolveBuffer(
+        response,
+        id,
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+      );
+      return;
+    case 85:
+      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+      return;
+    case 83:
+      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+      return;
+    case 115:
+      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+      return;
+    case 76:
+      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+      return;
+    case 108:
+      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+      return;
+    case 71:
+      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+      return;
+    case 103:
+      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+      return;
+    case 77:
+      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+      return;
+    case 109:
+      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+      return;
+    case 86:
+      resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+      return;
+  }
+  for (
+    var stringDecoder = response._stringDecoder, row = "", i = 0;
+    i < buffer.length;
+    i++
+  )
+    row += stringDecoder.decode(buffer[i], decoderOptions);
+  buffer = row += stringDecoder.decode(chunk);
+  switch (tag) {
+    case 73:
+      resolveModule(response, id, buffer);
+      break;
+    case 72:
+      id = buffer[0];
+      buffer = buffer.slice(1);
+      response = JSON.parse(buffer, response._fromJSON);
+      buffer = ReactDOMSharedInternals.d;
+      switch (id) {
+        case "D":
+          buffer.D(response);
+          break;
+        case "C":
+          "string" === typeof response
+            ? buffer.C(response)
+            : buffer.C(response[0], response[1]);
+          break;
+        case "L":
+          id = response[0];
+          tag = response[1];
+          3 === response.length
+            ? buffer.L(id, tag, response[2])
+            : buffer.L(id, tag);
+          break;
+        case "m":
+          "string" === typeof response
+            ? buffer.m(response)
+            : buffer.m(response[0], response[1]);
+          break;
+        case "X":
+          "string" === typeof response
+            ? buffer.X(response)
+            : buffer.X(response[0], response[1]);
+          break;
+        case "S":
+          "string" === typeof response
+            ? buffer.S(response)
+            : buffer.S(
+                response[0],
+                0 === response[1] ? void 0 : response[1],
+                3 === response.length ? response[2] : void 0
+              );
+          break;
+        case "M":
+          "string" === typeof response
+            ? buffer.M(response)
+            : buffer.M(response[0], response[1]);
+      }
+      break;
+    case 69:
+      tag = JSON.parse(buffer);
+      buffer = resolveErrorProd();
+      buffer.digest = tag.digest;
+      tag = response._chunks;
+      (chunk = tag.get(id))
+        ? triggerErrorOnChunk(chunk, buffer)
+        : tag.set(id, createErrorChunk(response, buffer));
+      break;
+    case 84:
+      tag = response._chunks;
+      (chunk = tag.get(id)) && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(buffer)
+        : tag.set(id, new ReactPromise("fulfilled", buffer, null, response));
+      break;
+    case 78:
+    case 68:
+    case 87:
+      throw Error(
+        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+      );
+    case 82:
+      startReadableStream(response, id, void 0);
+      break;
+    case 114:
+      startReadableStream(response, id, "bytes");
+      break;
+    case 88:
+      startAsyncIterable(response, id, !1);
+      break;
+    case 120:
+      startAsyncIterable(response, id, !0);
+      break;
+    case 67:
+      (response = response._chunks.get(id)) &&
+        "fulfilled" === response.status &&
+        response.reason.close("" === buffer ? '"$undefined"' : buffer);
+      break;
+    case 80:
+      buffer = Error(
+        "A Server Component was postponed. The reason is omitted in production builds to avoid leaking sensitive details."
+      );
+      buffer.$$typeof = REACT_POSTPONE_TYPE;
+      buffer.stack = "Error: " + buffer.message;
+      tag = response._chunks;
+      (chunk = tag.get(id))
+        ? triggerErrorOnChunk(chunk, buffer)
+        : tag.set(id, createErrorChunk(response, buffer));
+      break;
+    default:
+      (tag = response._chunks),
+        (chunk = tag.get(id))
+          ? resolveModelChunk(chunk, buffer)
+          : tag.set(
+              id,
+              new ReactPromise("resolved_model", buffer, null, response)
+            );
+  }
+}
+function createFromJSONCallback(response) {
+  return function (key, value) {
+    if ("string" === typeof value)
+      return parseModelString(response, this, key, value);
+    if ("object" === typeof value && null !== value) {
+      if (value[0] === REACT_ELEMENT_TYPE) {
+        if (
+          ((key = {
+            $$typeof: REACT_ELEMENT_TYPE,
+            type: value[1],
+            key: value[2],
+            ref: null,
+            props: value[3]
+          }),
+          null !== initializingHandler)
+        )
+          if (
+            ((value = initializingHandler),
+            (initializingHandler = value.parent),
+            value.errored)
+          )
+            (key = createErrorChunk(response, value.value)),
+              (key = createLazyChunkWrapper(key));
+          else if (0 < value.deps) {
+            var blockedChunk = new ReactPromise(
+              "blocked",
+              null,
+              null,
+              response
+            );
+            value.value = key;
+            value.chunk = blockedChunk;
+            key = createLazyChunkWrapper(blockedChunk);
+          }
+      } else key = value;
+      return key;
+    }
+    return value;
+  };
+}
+function createResponseFromOptions(options) {
+  return new ResponseInstance(
+    options && options.moduleBaseURL ? options.moduleBaseURL : "",
+    null,
+    null,
+    options && options.callServer ? options.callServer : void 0,
+    void 0,
+    void 0,
+    options && options.temporaryReferences
+      ? options.temporaryReferences
+      : void 0
+  );
+}
+function startReadingFromStream(response, stream) {
+  function progress(_ref) {
+    var value = _ref.value;
+    if (_ref.done) reportGlobalError(response, Error("Connection closed."));
+    else {
+      var i = 0,
+        rowState = response._rowState;
+      _ref = response._rowID;
+      for (
+        var rowTag = response._rowTag,
+          rowLength = response._rowLength,
+          buffer = response._buffer,
+          chunkLength = value.length;
+        i < chunkLength;
+
+      ) {
+        var lastIdx = -1;
+        switch (rowState) {
+          case 0:
+            lastIdx = value[i++];
+            58 === lastIdx
+              ? (rowState = 1)
+              : (_ref =
+                  (_ref << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+            continue;
+          case 1:
+            rowState = value[i];
+            84 === rowState ||
+            65 === rowState ||
+            79 === rowState ||
+            111 === rowState ||
+            85 === rowState ||
+            83 === rowState ||
+            115 === rowState ||
+            76 === rowState ||
+            108 === rowState ||
+            71 === rowState ||
+            103 === rowState ||
+            77 === rowState ||
+            109 === rowState ||
+            86 === rowState
+              ? ((rowTag = rowState), (rowState = 2), i++)
+              : (64 < rowState && 91 > rowState) ||
+                  35 === rowState ||
+                  114 === rowState ||
+                  120 === rowState
+                ? ((rowTag = rowState), (rowState = 3), i++)
+                : ((rowTag = 0), (rowState = 3));
+            continue;
+          case 2:
+            lastIdx = value[i++];
+            44 === lastIdx
+              ? (rowState = 4)
+              : (rowLength =
+                  (rowLength << 4) |
+                  (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+            continue;
+          case 3:
+            lastIdx = value.indexOf(10, i);
+            break;
+          case 4:
+            (lastIdx = i + rowLength), lastIdx > value.length && (lastIdx = -1);
+        }
+        var offset = value.byteOffset + i;
+        if (-1 < lastIdx)
+          (rowLength = new Uint8Array(value.buffer, offset, lastIdx - i)),
+            processFullBinaryRow(response, _ref, rowTag, buffer, rowLength),
+            (i = lastIdx),
+            3 === rowState && i++,
+            (rowLength = _ref = rowTag = rowState = 0),
+            (buffer.length = 0);
+        else {
+          value = new Uint8Array(value.buffer, offset, value.byteLength - i);
+          buffer.push(value);
+          rowLength -= value.byteLength;
+          break;
+        }
+      }
+      response._rowState = rowState;
+      response._rowID = _ref;
+      response._rowTag = rowTag;
+      response._rowLength = rowLength;
+      return reader.read().then(progress).catch(error);
+    }
+  }
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+  var reader = stream.getReader();
+  reader.read().then(progress).catch(error);
+}
+exports.createFromFetch = function (promiseForResponse, options) {
+  var response = createResponseFromOptions(options);
+  promiseForResponse.then(
+    function (r) {
+      startReadingFromStream(response, r.body);
+    },
+    function (e) {
+      reportGlobalError(response, e);
+    }
+  );
+  return getChunk(response, 0);
+};
+exports.createFromReadableStream = function (stream, options) {
+  options = createResponseFromOptions(options);
+  startReadingFromStream(options, stream);
+  return getChunk(options, 0);
+};
+exports.createServerReference = function (id, callServer) {
+  function action() {
+    var args = Array.prototype.slice.call(arguments);
+    return callServer(id, args);
+  }
+  registerServerReference(action, { id: id, bound: null });
+  return action;
+};
+exports.createTemporaryReferenceSet = function () {
+  return new Map();
+};
+exports.encodeReply = function (value, options) {
+  return new Promise(function (resolve, reject) {
+    var abort = processReply(
+      value,
+      "",
+      options && options.temporaryReferences
+        ? options.temporaryReferences
+        : void 0,
+      resolve,
+      reject
+    );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(signal.reason);
+      else {
+        var listener = function () {
+          abort(signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+  });
+};
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.development.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.development.js
new file mode 100644
index 0000000..47353a0
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.development.js
@@ -0,0 +1,3040 @@
+/**
+ * @license React
+ * react-server-dom-esm-client.node.development.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+"production" !== process.env.NODE_ENV &&
+  (function () {
+    function _defineProperty(obj, key, value) {
+      key in obj
+        ? Object.defineProperty(obj, key, {
+            value: value,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+          })
+        : (obj[key] = value);
+      return obj;
+    }
+    function resolveServerReference(config, id) {
+      var idx = id.lastIndexOf("#"),
+        exportName = id.slice(idx + 1);
+      id = id.slice(0, idx);
+      if (!id.startsWith(config))
+        throw Error(
+          "Attempted to load a Server Reference outside the hosted root."
+        );
+      return { specifier: id, name: exportName };
+    }
+    function preloadModule(metadata) {
+      var existingPromise = asyncModuleCache.get(metadata.specifier);
+      if (existingPromise)
+        return "fulfilled" === existingPromise.status ? null : existingPromise;
+      var modulePromise = import(metadata.specifier);
+      modulePromise.then(
+        function (value) {
+          modulePromise.status = "fulfilled";
+          modulePromise.value = value;
+        },
+        function (reason) {
+          modulePromise.status = "rejected";
+          modulePromise.reason = reason;
+        }
+      );
+      asyncModuleCache.set(metadata.specifier, modulePromise);
+      return modulePromise;
+    }
+    function requireModule(metadata) {
+      var moduleExports = asyncModuleCache.get(metadata.specifier);
+      if ("fulfilled" === moduleExports.status)
+        moduleExports = moduleExports.value;
+      else throw moduleExports.reason;
+      return moduleExports[metadata.name];
+    }
+    function prepareDestinationForModuleImpl(moduleLoading, mod, nonce) {
+      "string" === typeof moduleLoading
+        ? ReactDOMSharedInternals.d.M(moduleLoading + mod, {
+            crossOrigin: getCrossOriginString(void 0),
+            nonce: nonce
+          })
+        : null !== moduleLoading &&
+          ReactDOMSharedInternals.d.M(moduleLoading.prefix + mod, {
+            crossOrigin: getCrossOriginString(moduleLoading.crossOrigin),
+            nonce: nonce
+          });
+    }
+    function getCrossOriginString(input) {
+      if ("string" === typeof input)
+        return "use-credentials" === input ? input : "";
+    }
+    function getIteratorFn(maybeIterable) {
+      if (null === maybeIterable || "object" !== typeof maybeIterable)
+        return null;
+      maybeIterable =
+        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+        maybeIterable["@@iterator"];
+      return "function" === typeof maybeIterable ? maybeIterable : null;
+    }
+    function isObjectPrototype(object) {
+      if (!object) return !1;
+      var ObjectPrototype = Object.prototype;
+      if (object === ObjectPrototype) return !0;
+      if (getPrototypeOf(object)) return !1;
+      object = Object.getOwnPropertyNames(object);
+      for (var i = 0; i < object.length; i++)
+        if (!(object[i] in ObjectPrototype)) return !1;
+      return !0;
+    }
+    function isSimpleObject(object) {
+      if (!isObjectPrototype(getPrototypeOf(object))) return !1;
+      for (
+        var names = Object.getOwnPropertyNames(object), i = 0;
+        i < names.length;
+        i++
+      ) {
+        var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+        if (
+          !descriptor ||
+          (!descriptor.enumerable &&
+            (("key" !== names[i] && "ref" !== names[i]) ||
+              "function" !== typeof descriptor.get))
+        )
+          return !1;
+      }
+      return !0;
+    }
+    function objectName(object) {
+      return Object.prototype.toString
+        .call(object)
+        .replace(/^\[object (.*)\]$/, function (m, p0) {
+          return p0;
+        });
+    }
+    function describeKeyForErrorMessage(key) {
+      var encodedKey = JSON.stringify(key);
+      return '"' + key + '"' === encodedKey ? key : encodedKey;
+    }
+    function describeValueForErrorMessage(value) {
+      switch (typeof value) {
+        case "string":
+          return JSON.stringify(
+            10 >= value.length ? value : value.slice(0, 10) + "..."
+          );
+        case "object":
+          if (isArrayImpl(value)) return "[...]";
+          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
+            return "client";
+          value = objectName(value);
+          return "Object" === value ? "{...}" : value;
+        case "function":
+          return value.$$typeof === CLIENT_REFERENCE_TAG
+            ? "client"
+            : (value = value.displayName || value.name)
+              ? "function " + value
+              : "function";
+        default:
+          return String(value);
+      }
+    }
+    function describeElementType(type) {
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (type.$$typeof) {
+          case REACT_FORWARD_REF_TYPE:
+            return describeElementType(type.render);
+          case REACT_MEMO_TYPE:
+            return describeElementType(type.type);
+          case REACT_LAZY_TYPE:
+            var payload = type._payload;
+            type = type._init;
+            try {
+              return describeElementType(type(payload));
+            } catch (x) {}
+        }
+      return "";
+    }
+    function describeObjectForErrorMessage(objectOrArray, expandedName) {
+      var objKind = objectName(objectOrArray);
+      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      var start = -1,
+        length = 0;
+      if (isArrayImpl(objectOrArray))
+        if (jsxChildrenParents.has(objectOrArray)) {
+          var type = jsxChildrenParents.get(objectOrArray);
+          objKind = "<" + describeElementType(type) + ">";
+          for (var i = 0; i < objectOrArray.length; i++) {
+            var value = objectOrArray[i];
+            value =
+              "string" === typeof value
+                ? value
+                : "object" === typeof value && null !== value
+                  ? "{" + describeObjectForErrorMessage(value) + "}"
+                  : "{" + describeValueForErrorMessage(value) + "}";
+            "" + i === expandedName
+              ? ((start = objKind.length),
+                (length = value.length),
+                (objKind += value))
+              : (objKind =
+                  15 > value.length && 40 > objKind.length + value.length
+                    ? objKind + value
+                    : objKind + "{...}");
+          }
+          objKind += "</" + describeElementType(type) + ">";
+        } else {
+          objKind = "[";
+          for (type = 0; type < objectOrArray.length; type++)
+            0 < type && (objKind += ", "),
+              (i = objectOrArray[type]),
+              (i =
+                "object" === typeof i && null !== i
+                  ? describeObjectForErrorMessage(i)
+                  : describeValueForErrorMessage(i)),
+              "" + type === expandedName
+                ? ((start = objKind.length),
+                  (length = i.length),
+                  (objKind += i))
+                : (objKind =
+                    10 > i.length && 40 > objKind.length + i.length
+                      ? objKind + i
+                      : objKind + "...");
+          objKind += "]";
+        }
+      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
+        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+      else {
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (jsxPropsParents.has(objectOrArray)) {
+          objKind = jsxPropsParents.get(objectOrArray);
+          objKind = "<" + (describeElementType(objKind) || "...");
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++) {
+            objKind += " ";
+            value = type[i];
+            objKind += describeKeyForErrorMessage(value) + "=";
+            var _value2 = objectOrArray[value];
+            var _substr2 =
+              value === expandedName &&
+              "object" === typeof _value2 &&
+              null !== _value2
+                ? describeObjectForErrorMessage(_value2)
+                : describeValueForErrorMessage(_value2);
+            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            value === expandedName
+              ? ((start = objKind.length),
+                (length = _substr2.length),
+                (objKind += _substr2))
+              : (objKind =
+                  10 > _substr2.length && 40 > objKind.length + _substr2.length
+                    ? objKind + _substr2
+                    : objKind + "...");
+          }
+          objKind += ">";
+        } else {
+          objKind = "{";
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++)
+            0 < i && (objKind += ", "),
+              (value = type[i]),
+              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (_value2 = objectOrArray[value]),
+              (_value2 =
+                "object" === typeof _value2 && null !== _value2
+                  ? describeObjectForErrorMessage(_value2)
+                  : describeValueForErrorMessage(_value2)),
+              value === expandedName
+                ? ((start = objKind.length),
+                  (length = _value2.length),
+                  (objKind += _value2))
+                : (objKind =
+                    10 > _value2.length && 40 > objKind.length + _value2.length
+                      ? objKind + _value2
+                      : objKind + "...");
+          objKind += "}";
+        }
+      }
+      return void 0 === expandedName
+        ? objKind
+        : -1 < start && 0 < length
+          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
+            "\n  " + objKind + "\n  " + objectOrArray)
+          : "\n  " + objKind;
+    }
+    function serializeNumber(number) {
+      return Number.isFinite(number)
+        ? 0 === number && -Infinity === 1 / number
+          ? "$-0"
+          : number
+        : Infinity === number
+          ? "$Infinity"
+          : -Infinity === number
+            ? "$-Infinity"
+            : "$NaN";
+    }
+    function processReply(
+      root,
+      formFieldPrefix,
+      temporaryReferences,
+      resolve,
+      reject
+    ) {
+      function serializeTypedArray(tag, typedArray) {
+        typedArray = new Blob([
+          new Uint8Array(
+            typedArray.buffer,
+            typedArray.byteOffset,
+            typedArray.byteLength
+          )
+        ]);
+        var blobId = nextPartId++;
+        null === formData && (formData = new FormData());
+        formData.append(formFieldPrefix + blobId, typedArray);
+        return "$" + tag + blobId.toString(16);
+      }
+      function serializeBinaryReader(reader) {
+        function progress(entry) {
+          entry.done
+            ? ((entry = nextPartId++),
+              data.append(formFieldPrefix + entry, new Blob(buffer)),
+              data.append(
+                formFieldPrefix + streamId,
+                '"$o' + entry.toString(16) + '"'
+              ),
+              data.append(formFieldPrefix + streamId, "C"),
+              pendingParts--,
+              0 === pendingParts && resolve(data))
+            : (buffer.push(entry.value),
+              reader.read(new Uint8Array(1024)).then(progress, reject));
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++,
+          buffer = [];
+        reader.read(new Uint8Array(1024)).then(progress, reject);
+        return "$r" + streamId.toString(16);
+      }
+      function serializeReader(reader) {
+        function progress(entry) {
+          if (entry.done)
+            data.append(formFieldPrefix + streamId, "C"),
+              pendingParts--,
+              0 === pendingParts && resolve(data);
+          else
+            try {
+              var partJSON = JSON.stringify(entry.value, resolveToJSON);
+              data.append(formFieldPrefix + streamId, partJSON);
+              reader.read().then(progress, reject);
+            } catch (x) {
+              reject(x);
+            }
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++;
+        reader.read().then(progress, reject);
+        return "$R" + streamId.toString(16);
+      }
+      function serializeReadableStream(stream) {
+        try {
+          var binaryReader = stream.getReader({ mode: "byob" });
+        } catch (x) {
+          return serializeReader(stream.getReader());
+        }
+        return serializeBinaryReader(binaryReader);
+      }
+      function serializeAsyncIterable(iterable, iterator) {
+        function progress(entry) {
+          if (entry.done) {
+            if (void 0 === entry.value)
+              data.append(formFieldPrefix + streamId, "C");
+            else
+              try {
+                var partJSON = JSON.stringify(entry.value, resolveToJSON);
+                data.append(formFieldPrefix + streamId, "C" + partJSON);
+              } catch (x) {
+                reject(x);
+                return;
+              }
+            pendingParts--;
+            0 === pendingParts && resolve(data);
+          } else
+            try {
+              var _partJSON = JSON.stringify(entry.value, resolveToJSON);
+              data.append(formFieldPrefix + streamId, _partJSON);
+              iterator.next().then(progress, reject);
+            } catch (x$0) {
+              reject(x$0);
+            }
+        }
+        null === formData && (formData = new FormData());
+        var data = formData;
+        pendingParts++;
+        var streamId = nextPartId++;
+        iterable = iterable === iterator;
+        iterator.next().then(progress, reject);
+        return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+      }
+      function resolveToJSON(key, value) {
+        var originalValue = this[key];
+        "object" !== typeof originalValue ||
+          originalValue === value ||
+          originalValue instanceof Date ||
+          ("Object" !== objectName(originalValue)
+            ? console.error(
+                "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                objectName(originalValue),
+                describeObjectForErrorMessage(this, key)
+              )
+            : console.error(
+                "Only plain objects can be passed to Server Functions from the Client. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
+                describeObjectForErrorMessage(this, key)
+              ));
+        if (null === value) return null;
+        if ("object" === typeof value) {
+          switch (value.$$typeof) {
+            case REACT_ELEMENT_TYPE:
+              if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+                var parentReference = writtenObjects.get(this);
+                if (void 0 !== parentReference)
+                  return (
+                    temporaryReferences.set(parentReference + ":" + key, value),
+                    "$T"
+                  );
+              }
+              throw Error(
+                "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
+                  describeObjectForErrorMessage(this, key)
+              );
+            case REACT_LAZY_TYPE:
+              originalValue = value._payload;
+              var init = value._init;
+              null === formData && (formData = new FormData());
+              pendingParts++;
+              try {
+                parentReference = init(originalValue);
+                var lazyId = nextPartId++,
+                  partJSON = serializeModel(parentReference, lazyId);
+                formData.append(formFieldPrefix + lazyId, partJSON);
+                return "$" + lazyId.toString(16);
+              } catch (x) {
+                if (
+                  "object" === typeof x &&
+                  null !== x &&
+                  "function" === typeof x.then
+                ) {
+                  pendingParts++;
+                  var _lazyId = nextPartId++;
+                  parentReference = function () {
+                    try {
+                      var _partJSON2 = serializeModel(value, _lazyId),
+                        _data = formData;
+                      _data.append(formFieldPrefix + _lazyId, _partJSON2);
+                      pendingParts--;
+                      0 === pendingParts && resolve(_data);
+                    } catch (reason) {
+                      reject(reason);
+                    }
+                  };
+                  x.then(parentReference, parentReference);
+                  return "$" + _lazyId.toString(16);
+                }
+                reject(x);
+                return null;
+              } finally {
+                pendingParts--;
+              }
+          }
+          if ("function" === typeof value.then) {
+            null === formData && (formData = new FormData());
+            pendingParts++;
+            var promiseId = nextPartId++;
+            value.then(function (partValue) {
+              try {
+                var _partJSON3 = serializeModel(partValue, promiseId);
+                partValue = formData;
+                partValue.append(formFieldPrefix + promiseId, _partJSON3);
+                pendingParts--;
+                0 === pendingParts && resolve(partValue);
+              } catch (reason) {
+                reject(reason);
+              }
+            }, reject);
+            return "$@" + promiseId.toString(16);
+          }
+          parentReference = writtenObjects.get(value);
+          if (void 0 !== parentReference)
+            if (modelRoot === value) modelRoot = null;
+            else return parentReference;
+          else
+            -1 === key.indexOf(":") &&
+              ((parentReference = writtenObjects.get(this)),
+              void 0 !== parentReference &&
+                ((parentReference = parentReference + ":" + key),
+                writtenObjects.set(value, parentReference),
+                void 0 !== temporaryReferences &&
+                  temporaryReferences.set(parentReference, value)));
+          if (isArrayImpl(value)) return value;
+          if (value instanceof FormData) {
+            null === formData && (formData = new FormData());
+            var _data3 = formData;
+            key = nextPartId++;
+            var prefix = formFieldPrefix + key + "_";
+            value.forEach(function (originalValue, originalKey) {
+              _data3.append(prefix + originalKey, originalValue);
+            });
+            return "$K" + key.toString(16);
+          }
+          if (value instanceof Map)
+            return (
+              (key = nextPartId++),
+              (parentReference = serializeModel(Array.from(value), key)),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$Q" + key.toString(16)
+            );
+          if (value instanceof Set)
+            return (
+              (key = nextPartId++),
+              (parentReference = serializeModel(Array.from(value), key)),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$W" + key.toString(16)
+            );
+          if (value instanceof ArrayBuffer)
+            return (
+              (key = new Blob([value])),
+              (parentReference = nextPartId++),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + parentReference, key),
+              "$A" + parentReference.toString(16)
+            );
+          if (value instanceof Int8Array)
+            return serializeTypedArray("O", value);
+          if (value instanceof Uint8Array)
+            return serializeTypedArray("o", value);
+          if (value instanceof Uint8ClampedArray)
+            return serializeTypedArray("U", value);
+          if (value instanceof Int16Array)
+            return serializeTypedArray("S", value);
+          if (value instanceof Uint16Array)
+            return serializeTypedArray("s", value);
+          if (value instanceof Int32Array)
+            return serializeTypedArray("L", value);
+          if (value instanceof Uint32Array)
+            return serializeTypedArray("l", value);
+          if (value instanceof Float32Array)
+            return serializeTypedArray("G", value);
+          if (value instanceof Float64Array)
+            return serializeTypedArray("g", value);
+          if (value instanceof BigInt64Array)
+            return serializeTypedArray("M", value);
+          if (value instanceof BigUint64Array)
+            return serializeTypedArray("m", value);
+          if (value instanceof DataView) return serializeTypedArray("V", value);
+          if ("function" === typeof Blob && value instanceof Blob)
+            return (
+              null === formData && (formData = new FormData()),
+              (key = nextPartId++),
+              formData.append(formFieldPrefix + key, value),
+              "$B" + key.toString(16)
+            );
+          if ((parentReference = getIteratorFn(value)))
+            return (
+              (parentReference = parentReference.call(value)),
+              parentReference === value
+                ? ((key = nextPartId++),
+                  (parentReference = serializeModel(
+                    Array.from(parentReference),
+                    key
+                  )),
+                  null === formData && (formData = new FormData()),
+                  formData.append(formFieldPrefix + key, parentReference),
+                  "$i" + key.toString(16))
+                : Array.from(parentReference)
+            );
+          if (
+            "function" === typeof ReadableStream &&
+            value instanceof ReadableStream
+          )
+            return serializeReadableStream(value);
+          parentReference = value[ASYNC_ITERATOR];
+          if ("function" === typeof parentReference)
+            return serializeAsyncIterable(value, parentReference.call(value));
+          parentReference = getPrototypeOf(value);
+          if (
+            parentReference !== ObjectPrototype &&
+            (null === parentReference ||
+              null !== getPrototypeOf(parentReference))
+          ) {
+            if (void 0 === temporaryReferences)
+              throw Error(
+                "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported." +
+                  describeObjectForErrorMessage(this, key)
+              );
+            return "$T";
+          }
+          value.$$typeof === REACT_CONTEXT_TYPE
+            ? console.error(
+                "React Context Providers cannot be passed to Server Functions from the Client.%s",
+                describeObjectForErrorMessage(this, key)
+              )
+            : "Object" !== objectName(value)
+              ? console.error(
+                  "Only plain objects can be passed to Server Functions from the Client. %s objects are not supported.%s",
+                  objectName(value),
+                  describeObjectForErrorMessage(this, key)
+                )
+              : isSimpleObject(value)
+                ? Object.getOwnPropertySymbols &&
+                  ((parentReference = Object.getOwnPropertySymbols(value)),
+                  0 < parentReference.length &&
+                    console.error(
+                      "Only plain objects can be passed to Server Functions from the Client. Objects with symbol properties like %s are not supported.%s",
+                      parentReference[0].description,
+                      describeObjectForErrorMessage(this, key)
+                    ))
+                : console.error(
+                    "Only plain objects can be passed to Server Functions from the Client. Classes or other objects with methods are not supported.%s",
+                    describeObjectForErrorMessage(this, key)
+                  );
+          return value;
+        }
+        if ("string" === typeof value) {
+          if ("Z" === value[value.length - 1] && this[key] instanceof Date)
+            return "$D" + value;
+          key = "$" === value[0] ? "$" + value : value;
+          return key;
+        }
+        if ("boolean" === typeof value) return value;
+        if ("number" === typeof value) return serializeNumber(value);
+        if ("undefined" === typeof value) return "$undefined";
+        if ("function" === typeof value) {
+          parentReference = knownServerReferences.get(value);
+          if (void 0 !== parentReference)
+            return (
+              (key = JSON.stringify(parentReference, resolveToJSON)),
+              null === formData && (formData = new FormData()),
+              (parentReference = nextPartId++),
+              formData.set(formFieldPrefix + parentReference, key),
+              "$F" + parentReference.toString(16)
+            );
+          if (
+            void 0 !== temporaryReferences &&
+            -1 === key.indexOf(":") &&
+            ((parentReference = writtenObjects.get(this)),
+            void 0 !== parentReference)
+          )
+            return (
+              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+            );
+          throw Error(
+            "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+          );
+        }
+        if ("symbol" === typeof value) {
+          if (
+            void 0 !== temporaryReferences &&
+            -1 === key.indexOf(":") &&
+            ((parentReference = writtenObjects.get(this)),
+            void 0 !== parentReference)
+          )
+            return (
+              temporaryReferences.set(parentReference + ":" + key, value), "$T"
+            );
+          throw Error(
+            "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options." +
+              describeObjectForErrorMessage(this, key)
+          );
+        }
+        if ("bigint" === typeof value) return "$n" + value.toString(10);
+        throw Error(
+          "Type " +
+            typeof value +
+            " is not supported as an argument to a Server Function."
+        );
+      }
+      function serializeModel(model, id) {
+        "object" === typeof model &&
+          null !== model &&
+          ((id = "$" + id.toString(16)),
+          writtenObjects.set(model, id),
+          void 0 !== temporaryReferences && temporaryReferences.set(id, model));
+        modelRoot = model;
+        return JSON.stringify(model, resolveToJSON);
+      }
+      var nextPartId = 1,
+        pendingParts = 0,
+        formData = null,
+        writtenObjects = new WeakMap(),
+        modelRoot = root,
+        json = serializeModel(root, 0);
+      null === formData
+        ? resolve(json)
+        : (formData.set(formFieldPrefix + "0", json),
+          0 === pendingParts && resolve(formData));
+      return function () {
+        0 < pendingParts &&
+          ((pendingParts = 0),
+          null === formData ? resolve(json) : resolve(formData));
+      };
+    }
+    function encodeFormData(reference) {
+      var resolve,
+        reject,
+        thenable = new Promise(function (res, rej) {
+          resolve = res;
+          reject = rej;
+        });
+      processReply(
+        reference,
+        "",
+        void 0,
+        function (body) {
+          if ("string" === typeof body) {
+            var data = new FormData();
+            data.append("0", body);
+            body = data;
+          }
+          thenable.status = "fulfilled";
+          thenable.value = body;
+          resolve(body);
+        },
+        function (e) {
+          thenable.status = "rejected";
+          thenable.reason = e;
+          reject(e);
+        }
+      );
+      return thenable;
+    }
+    function defaultEncodeFormAction(identifierPrefix) {
+      var reference = knownServerReferences.get(this);
+      if (!reference)
+        throw Error(
+          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+        );
+      var data = null;
+      if (null !== reference.bound) {
+        data = boundCache.get(reference);
+        data ||
+          ((data = encodeFormData(reference)), boundCache.set(reference, data));
+        if ("rejected" === data.status) throw data.reason;
+        if ("fulfilled" !== data.status) throw data;
+        reference = data.value;
+        var prefixedData = new FormData();
+        reference.forEach(function (value, key) {
+          prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+        });
+        data = prefixedData;
+        reference = "$ACTION_REF_" + identifierPrefix;
+      } else reference = "$ACTION_ID_" + reference.id;
+      return {
+        name: reference,
+        method: "POST",
+        encType: "multipart/form-data",
+        data: data
+      };
+    }
+    function isSignatureEqual(referenceId, numberOfBoundArgs) {
+      var reference = knownServerReferences.get(this);
+      if (!reference)
+        throw Error(
+          "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+        );
+      if (reference.id !== referenceId) return !1;
+      var boundPromise = reference.bound;
+      if (null === boundPromise) return 0 === numberOfBoundArgs;
+      switch (boundPromise.status) {
+        case "fulfilled":
+          return boundPromise.value.length === numberOfBoundArgs;
+        case "pending":
+          throw boundPromise;
+        case "rejected":
+          throw boundPromise.reason;
+        default:
+          throw (
+            ("string" !== typeof boundPromise.status &&
+              ((boundPromise.status = "pending"),
+              boundPromise.then(
+                function (boundArgs) {
+                  boundPromise.status = "fulfilled";
+                  boundPromise.value = boundArgs;
+                },
+                function (error) {
+                  boundPromise.status = "rejected";
+                  boundPromise.reason = error;
+                }
+              )),
+            boundPromise)
+          );
+      }
+    }
+    function createFakeServerFunction(
+      name,
+      filename,
+      sourceMap,
+      line,
+      col,
+      environmentName,
+      innerFunction
+    ) {
+      name || (name = "<anonymous>");
+      var encodedName = JSON.stringify(name);
+      1 >= line
+        ? ((line = encodedName.length + 7),
+          (col =
+            "s=>({" +
+            encodedName +
+            " ".repeat(col < line ? 0 : col - line) +
+            ":(...args) => s(...args)})\n/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */"))
+        : (col =
+            "/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */" +
+            "\n".repeat(line - 2) +
+            "server=>({" +
+            encodedName +
+            ":\n" +
+            " ".repeat(1 > col ? 0 : col - 1) +
+            "(...args) => server(...args)})");
+      filename.startsWith("/") && (filename = "file://" + filename);
+      sourceMap
+        ? ((col +=
+            "\n//# sourceURL=rsc://React/" +
+            encodeURIComponent(environmentName) +
+            "/" +
+            filename +
+            "?s" +
+            fakeServerFunctionIdx++),
+          (col += "\n//# sourceMappingURL=" + sourceMap))
+        : filename && (col += "\n//# sourceURL=" + filename);
+      try {
+        return (0, eval)(col)(innerFunction)[name];
+      } catch (x) {
+        return innerFunction;
+      }
+    }
+    function registerServerReference(
+      proxy,
+      reference$jscomp$0,
+      encodeFormAction
+    ) {
+      Object.defineProperties(proxy, {
+        $$FORM_ACTION: {
+          value:
+            void 0 === encodeFormAction
+              ? defaultEncodeFormAction
+              : function () {
+                  var reference = knownServerReferences.get(this);
+                  if (!reference)
+                    throw Error(
+                      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                    );
+                  var boundPromise = reference.bound;
+                  null === boundPromise && (boundPromise = Promise.resolve([]));
+                  return encodeFormAction(reference.id, boundPromise);
+                }
+        },
+        $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
+        bind: { value: bind }
+      });
+      knownServerReferences.set(proxy, reference$jscomp$0);
+    }
+    function bind() {
+      var newFn = FunctionBind.apply(this, arguments),
+        reference = knownServerReferences.get(this);
+      if (reference) {
+        null != arguments[0] &&
+          console.error(
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+          );
+        var args = ArraySlice.call(arguments, 1),
+          boundPromise = null;
+        boundPromise =
+          null !== reference.bound
+            ? Promise.resolve(reference.bound).then(function (boundArgs) {
+                return boundArgs.concat(args);
+              })
+            : Promise.resolve(args);
+        Object.defineProperties(newFn, {
+          $$FORM_ACTION: { value: this.$$FORM_ACTION },
+          $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
+          bind: { value: bind }
+        });
+        knownServerReferences.set(newFn, {
+          id: reference.id,
+          bound: boundPromise
+        });
+      }
+      return newFn;
+    }
+    function createBoundServerReference(
+      metaData,
+      callServer,
+      encodeFormAction,
+      findSourceMapURL
+    ) {
+      function action() {
+        var args = Array.prototype.slice.call(arguments);
+        return bound
+          ? "fulfilled" === bound.status
+            ? callServer(id, bound.value.concat(args))
+            : Promise.resolve(bound).then(function (boundArgs) {
+                return callServer(id, boundArgs.concat(args));
+              })
+          : callServer(id, args);
+      }
+      var id = metaData.id,
+        bound = metaData.bound,
+        location = metaData.location;
+      if (location) {
+        var functionName = metaData.name || "",
+          filename = location[1],
+          line = location[2];
+        location = location[3];
+        metaData = metaData.env || "Server";
+        findSourceMapURL =
+          null == findSourceMapURL
+            ? null
+            : findSourceMapURL(filename, metaData);
+        action = createFakeServerFunction(
+          functionName,
+          filename,
+          findSourceMapURL,
+          line,
+          location,
+          metaData,
+          action
+        );
+      }
+      registerServerReference(
+        action,
+        { id: id, bound: bound },
+        encodeFormAction
+      );
+      return action;
+    }
+    function parseStackLocation(error) {
+      error = error.stack;
+      error.startsWith("Error: react-stack-top-frame\n") &&
+        (error = error.slice(29));
+      var endOfFirst = error.indexOf("\n");
+      if (-1 !== endOfFirst) {
+        var endOfSecond = error.indexOf("\n", endOfFirst + 1);
+        endOfFirst =
+          -1 === endOfSecond
+            ? error.slice(endOfFirst + 1)
+            : error.slice(endOfFirst + 1, endOfSecond);
+      } else endOfFirst = error;
+      error = v8FrameRegExp.exec(endOfFirst);
+      if (
+        !error &&
+        ((error = jscSpiderMonkeyFrameRegExp.exec(endOfFirst)), !error)
+      )
+        return null;
+      endOfFirst = error[1] || "";
+      "<anonymous>" === endOfFirst && (endOfFirst = "");
+      endOfSecond = error[2] || error[5] || "";
+      "<anonymous>" === endOfSecond && (endOfSecond = "");
+      return [
+        endOfFirst,
+        endOfSecond,
+        +(error[3] || error[6]),
+        +(error[4] || error[7])
+      ];
+    }
+    function createServerReference$1(
+      id,
+      callServer,
+      encodeFormAction,
+      findSourceMapURL,
+      functionName
+    ) {
+      function action() {
+        var args = Array.prototype.slice.call(arguments);
+        return callServer(id, args);
+      }
+      var location = parseStackLocation(Error("react-stack-top-frame"));
+      if (null !== location) {
+        var filename = location[1],
+          line = location[2];
+        location = location[3];
+        findSourceMapURL =
+          null == findSourceMapURL
+            ? null
+            : findSourceMapURL(filename, "Client");
+        action = createFakeServerFunction(
+          functionName || "",
+          filename,
+          findSourceMapURL,
+          line,
+          location,
+          "Client",
+          action
+        );
+      }
+      registerServerReference(
+        action,
+        { id: id, bound: null },
+        encodeFormAction
+      );
+      return action;
+    }
+    function getComponentNameFromType(type) {
+      if (null == type) return null;
+      if ("function" === typeof type)
+        return type.$$typeof === REACT_CLIENT_REFERENCE
+          ? null
+          : type.displayName || type.name || null;
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_FRAGMENT_TYPE:
+          return "Fragment";
+        case REACT_PORTAL_TYPE:
+          return "Portal";
+        case REACT_PROFILER_TYPE:
+          return "Profiler";
+        case REACT_STRICT_MODE_TYPE:
+          return "StrictMode";
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (
+          ("number" === typeof type.tag &&
+            console.error(
+              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
+            ),
+          type.$$typeof)
+        ) {
+          case REACT_CONTEXT_TYPE:
+            return (type.displayName || "Context") + ".Provider";
+          case REACT_CONSUMER_TYPE:
+            return (type._context.displayName || "Context") + ".Consumer";
+          case REACT_FORWARD_REF_TYPE:
+            var innerType = type.render;
+            type = type.displayName;
+            type ||
+              ((type = innerType.displayName || innerType.name || ""),
+              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
+            return type;
+          case REACT_MEMO_TYPE:
+            return (
+              (innerType = type.displayName || null),
+              null !== innerType
+                ? innerType
+                : getComponentNameFromType(type.type) || "Memo"
+            );
+          case REACT_LAZY_TYPE:
+            innerType = type._payload;
+            type = type._init;
+            try {
+              return getComponentNameFromType(type(innerType));
+            } catch (x) {}
+        }
+      return null;
+    }
+    function prepareStackTrace(error, structuredStackTrace) {
+      error = (error.name || "Error") + ": " + (error.message || "");
+      for (var i = 0; i < structuredStackTrace.length; i++)
+        error += "\n    at " + structuredStackTrace[i].toString();
+      return error;
+    }
+    function ReactPromise(status, value, reason, response) {
+      this.status = status;
+      this.value = value;
+      this.reason = reason;
+      this._response = response;
+      this._children = [];
+      this._debugInfo = null;
+    }
+    function readChunk(chunk) {
+      switch (chunk.status) {
+        case "resolved_model":
+          initializeModelChunk(chunk);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(chunk);
+      }
+      switch (chunk.status) {
+        case "fulfilled":
+          return chunk.value;
+        case "pending":
+        case "blocked":
+          throw chunk;
+        default:
+          throw chunk.reason;
+      }
+    }
+    function createPendingChunk(response) {
+      return new ReactPromise("pending", null, null, response);
+    }
+    function createErrorChunk(response, error) {
+      return new ReactPromise("rejected", null, error, response);
+    }
+    function wakeChunk(listeners, value) {
+      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+    }
+    function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+      switch (chunk.status) {
+        case "fulfilled":
+          wakeChunk(resolveListeners, chunk.value);
+          break;
+        case "pending":
+        case "blocked":
+          if (chunk.value)
+            for (var i = 0; i < resolveListeners.length; i++)
+              chunk.value.push(resolveListeners[i]);
+          else chunk.value = resolveListeners;
+          if (chunk.reason) {
+            if (rejectListeners)
+              for (
+                resolveListeners = 0;
+                resolveListeners < rejectListeners.length;
+                resolveListeners++
+              )
+                chunk.reason.push(rejectListeners[resolveListeners]);
+          } else chunk.reason = rejectListeners;
+          break;
+        case "rejected":
+          rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+      }
+    }
+    function triggerErrorOnChunk(chunk, error) {
+      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+        chunk.reason.error(error);
+      else {
+        var listeners = chunk.reason;
+        chunk.status = "rejected";
+        chunk.reason = error;
+        null !== listeners && wakeChunk(listeners, error);
+      }
+    }
+    function createResolvedIteratorResultChunk(response, value, done) {
+      return new ReactPromise(
+        "resolved_model",
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}",
+        null,
+        response
+      );
+    }
+    function resolveIteratorResultChunk(chunk, value, done) {
+      resolveModelChunk(
+        chunk,
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}"
+      );
+    }
+    function resolveModelChunk(chunk, value) {
+      if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+      else {
+        var resolveListeners = chunk.value,
+          rejectListeners = chunk.reason;
+        chunk.status = "resolved_model";
+        chunk.value = value;
+        null !== resolveListeners &&
+          (initializeModelChunk(chunk),
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+      }
+    }
+    function resolveModuleChunk(chunk, value) {
+      if ("pending" === chunk.status || "blocked" === chunk.status) {
+        var resolveListeners = chunk.value,
+          rejectListeners = chunk.reason;
+        chunk.status = "resolved_module";
+        chunk.value = value;
+        null !== resolveListeners &&
+          (initializeModuleChunk(chunk),
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+      }
+    }
+    function initializeModelChunk(chunk) {
+      var prevHandler = initializingHandler,
+        prevChunk = initializingChunk;
+      initializingHandler = null;
+      var resolvedModel = chunk.value;
+      chunk.status = "blocked";
+      chunk.value = null;
+      chunk.reason = null;
+      initializingChunk = chunk;
+      try {
+        var value = JSON.parse(resolvedModel, chunk._response._fromJSON),
+          resolveListeners = chunk.value;
+        null !== resolveListeners &&
+          ((chunk.value = null),
+          (chunk.reason = null),
+          wakeChunk(resolveListeners, value));
+        if (null !== initializingHandler) {
+          if (initializingHandler.errored) throw initializingHandler.value;
+          if (0 < initializingHandler.deps) {
+            initializingHandler.value = value;
+            initializingHandler.chunk = chunk;
+            return;
+          }
+        }
+        chunk.status = "fulfilled";
+        chunk.value = value;
+      } catch (error) {
+        (chunk.status = "rejected"), (chunk.reason = error);
+      } finally {
+        (initializingHandler = prevHandler), (initializingChunk = prevChunk);
+      }
+    }
+    function initializeModuleChunk(chunk) {
+      try {
+        var value = requireModule(chunk.value);
+        chunk.status = "fulfilled";
+        chunk.value = value;
+      } catch (error) {
+        (chunk.status = "rejected"), (chunk.reason = error);
+      }
+    }
+    function reportGlobalError(response, error) {
+      response._closed = !0;
+      response._closedReason = error;
+      response._chunks.forEach(function (chunk) {
+        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+      });
+      supportsUserTiming &&
+        performance.mark("Server Components Track", componentsTrackMarker);
+      flushComponentPerformance(
+        response,
+        getChunk(response, 0),
+        0,
+        -Infinity,
+        -Infinity
+      );
+    }
+    function nullRefGetter() {
+      return null;
+    }
+    function getTaskName(type) {
+      if (type === REACT_FRAGMENT_TYPE) return "<>";
+      if ("function" === typeof type) return '"use client"';
+      if (
+        "object" === typeof type &&
+        null !== type &&
+        type.$$typeof === REACT_LAZY_TYPE
+      )
+        return type._init === readChunk ? '"use client"' : "<...>";
+      try {
+        var name = getComponentNameFromType(type);
+        return name ? "<" + name + ">" : "<...>";
+      } catch (x) {
+        return "<...>";
+      }
+    }
+    function createLazyChunkWrapper(chunk) {
+      var lazyType = {
+        $$typeof: REACT_LAZY_TYPE,
+        _payload: chunk,
+        _init: readChunk
+      };
+      chunk = chunk._debugInfo || (chunk._debugInfo = []);
+      lazyType._debugInfo = chunk;
+      return lazyType;
+    }
+    function getChunk(response, id) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk ||
+        ((chunk = response._closed
+          ? createErrorChunk(response, response._closedReason)
+          : createPendingChunk(response)),
+        chunks.set(id, chunk));
+      return chunk;
+    }
+    function waitForReference(
+      referencedChunk,
+      parentObject,
+      key,
+      response,
+      map,
+      path
+    ) {
+      function fulfill(value) {
+        for (var i = 1; i < path.length; i++) {
+          for (; value.$$typeof === REACT_LAZY_TYPE; )
+            if (((value = value._payload), value === handler.chunk))
+              value = handler.value;
+            else if ("fulfilled" === value.status) value = value.value;
+            else {
+              path.splice(0, i - 1);
+              value.then(fulfill, reject);
+              return;
+            }
+          value = value[path[i]];
+        }
+        i = map(response, value, parentObject, key);
+        parentObject[key] = i;
+        "" === key && null === handler.value && (handler.value = i);
+        if (
+          parentObject[0] === REACT_ELEMENT_TYPE &&
+          "object" === typeof handler.value &&
+          null !== handler.value &&
+          handler.value.$$typeof === REACT_ELEMENT_TYPE
+        )
+          switch (((value = handler.value), key)) {
+            case "3":
+              value.props = i;
+              break;
+            case "4":
+              value._owner = i;
+          }
+        handler.deps--;
+        0 === handler.deps &&
+          ((i = handler.chunk),
+          null !== i &&
+            "blocked" === i.status &&
+            ((value = i.value),
+            (i.status = "fulfilled"),
+            (i.value = handler.value),
+            null !== value && wakeChunk(value, handler.value)));
+      }
+      function reject(error) {
+        if (!handler.errored) {
+          var blockedValue = handler.value;
+          handler.errored = !0;
+          handler.value = error;
+          var chunk = handler.chunk;
+          if (null !== chunk && "blocked" === chunk.status) {
+            if (
+              "object" === typeof blockedValue &&
+              null !== blockedValue &&
+              blockedValue.$$typeof === REACT_ELEMENT_TYPE
+            ) {
+              var erroredComponent = {
+                name: getComponentNameFromType(blockedValue.type) || "",
+                owner: blockedValue._owner
+              };
+              erroredComponent.debugStack = blockedValue._debugStack;
+              supportsCreateTask &&
+                (erroredComponent.debugTask = blockedValue._debugTask);
+              (chunk._debugInfo || (chunk._debugInfo = [])).push(
+                erroredComponent
+              );
+            }
+            triggerErrorOnChunk(chunk, error);
+          }
+        }
+      }
+      if (initializingHandler) {
+        var handler = initializingHandler;
+        handler.deps++;
+      } else
+        handler = initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: null,
+          deps: 1,
+          errored: !1
+        };
+      referencedChunk.then(fulfill, reject);
+      return null;
+    }
+    function loadServerReference(response, metaData, parentObject, key) {
+      if (!response._serverReferenceConfig)
+        return createBoundServerReference(
+          metaData,
+          response._callServer,
+          response._encodeFormAction,
+          response._debugFindSourceMapURL
+        );
+      var serverReference = resolveServerReference(
+        response._serverReferenceConfig,
+        metaData.id
+      );
+      if ((response = preloadModule(serverReference)))
+        metaData.bound && (response = Promise.all([response, metaData.bound]));
+      else if (metaData.bound) response = Promise.resolve(metaData.bound);
+      else return requireModule(serverReference);
+      if (initializingHandler) {
+        var handler = initializingHandler;
+        handler.deps++;
+      } else
+        handler = initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: null,
+          deps: 1,
+          errored: !1
+        };
+      response.then(
+        function () {
+          var resolvedValue = requireModule(serverReference);
+          if (metaData.bound) {
+            var boundArgs = metaData.bound.value.slice(0);
+            boundArgs.unshift(null);
+            resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+          }
+          parentObject[key] = resolvedValue;
+          "" === key &&
+            null === handler.value &&
+            (handler.value = resolvedValue);
+          if (
+            parentObject[0] === REACT_ELEMENT_TYPE &&
+            "object" === typeof handler.value &&
+            null !== handler.value &&
+            handler.value.$$typeof === REACT_ELEMENT_TYPE
+          )
+            switch (((boundArgs = handler.value), key)) {
+              case "3":
+                boundArgs.props = resolvedValue;
+                break;
+              case "4":
+                boundArgs._owner = resolvedValue;
+            }
+          handler.deps--;
+          0 === handler.deps &&
+            ((resolvedValue = handler.chunk),
+            null !== resolvedValue &&
+              "blocked" === resolvedValue.status &&
+              ((boundArgs = resolvedValue.value),
+              (resolvedValue.status = "fulfilled"),
+              (resolvedValue.value = handler.value),
+              null !== boundArgs && wakeChunk(boundArgs, handler.value)));
+        },
+        function (error) {
+          if (!handler.errored) {
+            var blockedValue = handler.value;
+            handler.errored = !0;
+            handler.value = error;
+            var chunk = handler.chunk;
+            if (null !== chunk && "blocked" === chunk.status) {
+              if (
+                "object" === typeof blockedValue &&
+                null !== blockedValue &&
+                blockedValue.$$typeof === REACT_ELEMENT_TYPE
+              ) {
+                var erroredComponent = {
+                  name: getComponentNameFromType(blockedValue.type) || "",
+                  owner: blockedValue._owner
+                };
+                erroredComponent.debugStack = blockedValue._debugStack;
+                supportsCreateTask &&
+                  (erroredComponent.debugTask = blockedValue._debugTask);
+                (chunk._debugInfo || (chunk._debugInfo = [])).push(
+                  erroredComponent
+                );
+              }
+              triggerErrorOnChunk(chunk, error);
+            }
+          }
+        }
+      );
+      return null;
+    }
+    function getOutlinedModel(response, reference, parentObject, key, map) {
+      reference = reference.split(":");
+      var id = parseInt(reference[0], 16);
+      id = getChunk(response, id);
+      null !== initializingChunk &&
+        isArrayImpl(initializingChunk._children) &&
+        initializingChunk._children.push(id);
+      switch (id.status) {
+        case "resolved_model":
+          initializeModelChunk(id);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(id);
+      }
+      switch (id.status) {
+        case "fulfilled":
+          for (var value = id.value, i = 1; i < reference.length; i++) {
+            for (; value.$$typeof === REACT_LAZY_TYPE; )
+              if (((value = value._payload), "fulfilled" === value.status))
+                value = value.value;
+              else
+                return waitForReference(
+                  value,
+                  parentObject,
+                  key,
+                  response,
+                  map,
+                  reference.slice(i - 1)
+                );
+            value = value[reference[i]];
+          }
+          response = map(response, value, parentObject, key);
+          id._debugInfo &&
+            ("object" !== typeof response ||
+              null === response ||
+              (!isArrayImpl(response) &&
+                "function" !== typeof response[ASYNC_ITERATOR] &&
+                response.$$typeof !== REACT_ELEMENT_TYPE) ||
+              response._debugInfo ||
+              Object.defineProperty(response, "_debugInfo", {
+                configurable: !1,
+                enumerable: !1,
+                writable: !0,
+                value: id._debugInfo
+              }));
+          return response;
+        case "pending":
+        case "blocked":
+          return waitForReference(
+            id,
+            parentObject,
+            key,
+            response,
+            map,
+            reference
+          );
+        default:
+          return (
+            initializingHandler
+              ? ((initializingHandler.errored = !0),
+                (initializingHandler.value = id.reason))
+              : (initializingHandler = {
+                  parent: null,
+                  chunk: null,
+                  value: id.reason,
+                  deps: 0,
+                  errored: !0
+                }),
+            null
+          );
+      }
+    }
+    function createMap(response, model) {
+      return new Map(model);
+    }
+    function createSet(response, model) {
+      return new Set(model);
+    }
+    function createBlob(response, model) {
+      return new Blob(model.slice(1), { type: model[0] });
+    }
+    function createFormData(response, model) {
+      response = new FormData();
+      for (var i = 0; i < model.length; i++)
+        response.append(model[i][0], model[i][1]);
+      return response;
+    }
+    function extractIterator(response, model) {
+      return model[Symbol.iterator]();
+    }
+    function createModel(response, model) {
+      return model;
+    }
+    function parseModelString(response, parentObject, key, value) {
+      if ("$" === value[0]) {
+        if ("$" === value)
+          return (
+            null !== initializingHandler &&
+              "0" === key &&
+              (initializingHandler = {
+                parent: initializingHandler,
+                chunk: null,
+                value: null,
+                deps: 0,
+                errored: !1
+              }),
+            REACT_ELEMENT_TYPE
+          );
+        switch (value[1]) {
+          case "$":
+            return value.slice(1);
+          case "L":
+            return (
+              (parentObject = parseInt(value.slice(2), 16)),
+              (response = getChunk(response, parentObject)),
+              null !== initializingChunk &&
+                isArrayImpl(initializingChunk._children) &&
+                initializingChunk._children.push(response),
+              createLazyChunkWrapper(response)
+            );
+          case "@":
+            if (2 === value.length) return new Promise(function () {});
+            parentObject = parseInt(value.slice(2), 16);
+            response = getChunk(response, parentObject);
+            null !== initializingChunk &&
+              isArrayImpl(initializingChunk._children) &&
+              initializingChunk._children.push(response);
+            return response;
+          case "S":
+            return Symbol.for(value.slice(2));
+          case "F":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                loadServerReference
+              )
+            );
+          case "T":
+            parentObject = "$" + value.slice(2);
+            response = response._tempRefs;
+            if (null == response)
+              throw Error(
+                "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+              );
+            return response.get(parentObject);
+          case "Q":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createMap)
+            );
+          case "W":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createSet)
+            );
+          case "B":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, parentObject, key, createBlob)
+            );
+          case "K":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                createFormData
+              )
+            );
+          case "Z":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                resolveErrorDev
+              )
+            );
+          case "i":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(
+                response,
+                value,
+                parentObject,
+                key,
+                extractIterator
+              )
+            );
+          case "I":
+            return Infinity;
+          case "-":
+            return "$-0" === value ? -0 : -Infinity;
+          case "N":
+            return NaN;
+          case "u":
+            return;
+          case "D":
+            return new Date(Date.parse(value.slice(2)));
+          case "n":
+            return BigInt(value.slice(2));
+          case "E":
+            try {
+              return (0, eval)(value.slice(2));
+            } catch (x) {
+              return function () {};
+            }
+          case "Y":
+            return (
+              Object.defineProperty(parentObject, key, {
+                get: function () {
+                  return "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.";
+                },
+                enumerable: !0,
+                configurable: !1
+              }),
+              null
+            );
+          default:
+            return (
+              (value = value.slice(1)),
+              getOutlinedModel(response, value, parentObject, key, createModel)
+            );
+        }
+      }
+      return value;
+    }
+    function missingCall() {
+      throw Error(
+        'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+      );
+    }
+    function ResponseInstance(
+      bundlerConfig,
+      serverReferenceConfig,
+      moduleLoading,
+      callServer,
+      encodeFormAction,
+      nonce,
+      temporaryReferences,
+      findSourceMapURL,
+      replayConsole,
+      environmentName
+    ) {
+      var chunks = new Map();
+      this._bundlerConfig = bundlerConfig;
+      this._serverReferenceConfig = serverReferenceConfig;
+      this._moduleLoading = moduleLoading;
+      this._callServer = void 0 !== callServer ? callServer : missingCall;
+      this._encodeFormAction = encodeFormAction;
+      this._nonce = nonce;
+      this._chunks = chunks;
+      this._stringDecoder = new util.TextDecoder();
+      this._fromJSON = null;
+      this._rowLength = this._rowTag = this._rowID = this._rowState = 0;
+      this._buffer = [];
+      this._closed = !1;
+      this._closedReason = null;
+      this._tempRefs = temporaryReferences;
+      this._timeOrigin = 0;
+      this._debugRootOwner = bundlerConfig =
+        void 0 === ReactSharedInteralsServer ||
+        null === ReactSharedInteralsServer.A
+          ? null
+          : ReactSharedInteralsServer.A.getOwner();
+      this._debugRootStack =
+        null !== bundlerConfig ? Error("react-stack-top-frame") : null;
+      environmentName = void 0 === environmentName ? "Server" : environmentName;
+      supportsCreateTask &&
+        (this._debugRootTask = console.createTask(
+          '"use ' + environmentName.toLowerCase() + '"'
+        ));
+      this._debugFindSourceMapURL = findSourceMapURL;
+      this._replayConsole = replayConsole;
+      this._rootEnvironmentName = environmentName;
+      this._fromJSON = createFromJSONCallback(this);
+    }
+    function resolveModel(response, id, model) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk
+        ? resolveModelChunk(chunk, model)
+        : chunks.set(
+            id,
+            new ReactPromise("resolved_model", model, null, response)
+          );
+    }
+    function resolveText(response, id, text) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(text)
+        : chunks.set(id, new ReactPromise("fulfilled", text, null, response));
+    }
+    function resolveBuffer(response, id, buffer) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(buffer)
+        : chunks.set(id, new ReactPromise("fulfilled", buffer, null, response));
+    }
+    function resolveModule(response, id, model) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      model = JSON.parse(model, response._fromJSON);
+      var clientReference = {
+        specifier: response._bundlerConfig + model[0],
+        name: model[1]
+      };
+      prepareDestinationForModuleImpl(
+        response._moduleLoading,
+        model[0],
+        response._nonce
+      );
+      if ((model = preloadModule(clientReference))) {
+        if (chunk) {
+          var blockedChunk = chunk;
+          blockedChunk.status = "blocked";
+        } else
+          (blockedChunk = new ReactPromise("blocked", null, null, response)),
+            chunks.set(id, blockedChunk);
+        model.then(
+          function () {
+            return resolveModuleChunk(blockedChunk, clientReference);
+          },
+          function (error) {
+            return triggerErrorOnChunk(blockedChunk, error);
+          }
+        );
+      } else
+        chunk
+          ? resolveModuleChunk(chunk, clientReference)
+          : chunks.set(
+              id,
+              new ReactPromise(
+                "resolved_module",
+                clientReference,
+                null,
+                response
+              )
+            );
+    }
+    function resolveStream(response, id, stream, controller) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk
+        ? "pending" === chunk.status &&
+          ((response = chunk.value),
+          (chunk.status = "fulfilled"),
+          (chunk.value = stream),
+          (chunk.reason = controller),
+          null !== response && wakeChunk(response, chunk.value))
+        : chunks.set(
+            id,
+            new ReactPromise("fulfilled", stream, controller, response)
+          );
+    }
+    function startReadableStream(response, id, type) {
+      var controller = null;
+      type = new ReadableStream({
+        type: type,
+        start: function (c) {
+          controller = c;
+        }
+      });
+      var previousBlockedChunk = null;
+      resolveStream(response, id, type, {
+        enqueueValue: function (value) {
+          null === previousBlockedChunk
+            ? controller.enqueue(value)
+            : previousBlockedChunk.then(function () {
+                controller.enqueue(value);
+              });
+        },
+        enqueueModel: function (json) {
+          if (null === previousBlockedChunk) {
+            var chunk = new ReactPromise(
+              "resolved_model",
+              json,
+              null,
+              response
+            );
+            initializeModelChunk(chunk);
+            "fulfilled" === chunk.status
+              ? controller.enqueue(chunk.value)
+              : (chunk.then(
+                  function (v) {
+                    return controller.enqueue(v);
+                  },
+                  function (e) {
+                    return controller.error(e);
+                  }
+                ),
+                (previousBlockedChunk = chunk));
+          } else {
+            chunk = previousBlockedChunk;
+            var _chunk3 = createPendingChunk(response);
+            _chunk3.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            );
+            previousBlockedChunk = _chunk3;
+            chunk.then(function () {
+              previousBlockedChunk === _chunk3 && (previousBlockedChunk = null);
+              resolveModelChunk(_chunk3, json);
+            });
+          }
+        },
+        close: function () {
+          if (null === previousBlockedChunk) controller.close();
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.close();
+            });
+          }
+        },
+        error: function (error) {
+          if (null === previousBlockedChunk) controller.error(error);
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.error(error);
+            });
+          }
+        }
+      });
+    }
+    function asyncIterator() {
+      return this;
+    }
+    function createIterator(next) {
+      next = { next: next };
+      next[ASYNC_ITERATOR] = asyncIterator;
+      return next;
+    }
+    function startAsyncIterable(response, id, iterator) {
+      var buffer = [],
+        closed = !1,
+        nextWriteIndex = 0,
+        iterable = _defineProperty({}, ASYNC_ITERATOR, function () {
+          var nextReadIndex = 0;
+          return createIterator(function (arg) {
+            if (void 0 !== arg)
+              throw Error(
+                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              );
+            if (nextReadIndex === buffer.length) {
+              if (closed)
+                return new ReactPromise(
+                  "fulfilled",
+                  { done: !0, value: void 0 },
+                  null,
+                  response
+                );
+              buffer[nextReadIndex] = createPendingChunk(response);
+            }
+            return buffer[nextReadIndex++];
+          });
+        });
+      resolveStream(
+        response,
+        id,
+        iterator ? iterable[ASYNC_ITERATOR]() : iterable,
+        {
+          enqueueValue: function (value) {
+            if (nextWriteIndex === buffer.length)
+              buffer[nextWriteIndex] = new ReactPromise(
+                "fulfilled",
+                { done: !1, value: value },
+                null,
+                response
+              );
+            else {
+              var chunk = buffer[nextWriteIndex],
+                resolveListeners = chunk.value,
+                rejectListeners = chunk.reason;
+              chunk.status = "fulfilled";
+              chunk.value = { done: !1, value: value };
+              null !== resolveListeners &&
+                wakeChunkIfInitialized(
+                  chunk,
+                  resolveListeners,
+                  rejectListeners
+                );
+            }
+            nextWriteIndex++;
+          },
+          enqueueModel: function (value) {
+            nextWriteIndex === buffer.length
+              ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                  response,
+                  value,
+                  !1
+                ))
+              : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+            nextWriteIndex++;
+          },
+          close: function (value) {
+            closed = !0;
+            nextWriteIndex === buffer.length
+              ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                  response,
+                  value,
+                  !0
+                ))
+              : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+            for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+              resolveIteratorResultChunk(
+                buffer[nextWriteIndex++],
+                '"$undefined"',
+                !0
+              );
+          },
+          error: function (error) {
+            closed = !0;
+            for (
+              nextWriteIndex === buffer.length &&
+              (buffer[nextWriteIndex] = createPendingChunk(response));
+              nextWriteIndex < buffer.length;
+
+            )
+              triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+          }
+        }
+      );
+    }
+    function stopStream(response, id, row) {
+      (response = response._chunks.get(id)) &&
+        "fulfilled" === response.status &&
+        response.reason.close("" === row ? '"$undefined"' : row);
+    }
+    function resolveErrorDev(response, errorInfo) {
+      var env = errorInfo.env;
+      errorInfo = buildFakeCallStack(
+        response,
+        errorInfo.stack,
+        env,
+        Error.bind(
+          null,
+          errorInfo.message ||
+            "An error occurred in the Server Components render but no message was provided"
+        )
+      );
+      response = getRootTask(response, env);
+      response = null != response ? response.run(errorInfo) : errorInfo();
+      response.environmentName = env;
+      return response;
+    }
+    function resolvePostponeDev(response, id, reason, stack, env) {
+      reason = buildFakeCallStack(
+        response,
+        stack,
+        env,
+        Error.bind(null, reason || "")
+      );
+      stack = response._debugRootTask;
+      reason = null != stack ? stack.run(reason) : reason();
+      reason.$$typeof = REACT_POSTPONE_TYPE;
+      stack = response._chunks;
+      (env = stack.get(id))
+        ? triggerErrorOnChunk(env, reason)
+        : stack.set(id, createErrorChunk(response, reason));
+    }
+    function resolveHint(response, code, model) {
+      response = JSON.parse(model, response._fromJSON);
+      model = ReactDOMSharedInternals.d;
+      switch (code) {
+        case "D":
+          model.D(response);
+          break;
+        case "C":
+          "string" === typeof response
+            ? model.C(response)
+            : model.C(response[0], response[1]);
+          break;
+        case "L":
+          code = response[0];
+          var as = response[1];
+          3 === response.length
+            ? model.L(code, as, response[2])
+            : model.L(code, as);
+          break;
+        case "m":
+          "string" === typeof response
+            ? model.m(response)
+            : model.m(response[0], response[1]);
+          break;
+        case "X":
+          "string" === typeof response
+            ? model.X(response)
+            : model.X(response[0], response[1]);
+          break;
+        case "S":
+          "string" === typeof response
+            ? model.S(response)
+            : model.S(
+                response[0],
+                0 === response[1] ? void 0 : response[1],
+                3 === response.length ? response[2] : void 0
+              );
+          break;
+        case "M":
+          "string" === typeof response
+            ? model.M(response)
+            : model.M(response[0], response[1]);
+      }
+    }
+    function createFakeFunction(
+      name,
+      filename,
+      sourceMap,
+      line,
+      col,
+      environmentName
+    ) {
+      name || (name = "<anonymous>");
+      var encodedName = JSON.stringify(name);
+      1 >= line
+        ? ((line = encodedName.length + 7),
+          (col =
+            "({" +
+            encodedName +
+            ":_=>" +
+            " ".repeat(col < line ? 0 : col - line) +
+            "_()})\n/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */"))
+        : (col =
+            "/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */" +
+            "\n".repeat(line - 2) +
+            "({" +
+            encodedName +
+            ":_=>\n" +
+            " ".repeat(1 > col ? 0 : col - 1) +
+            "_()})");
+      filename.startsWith("/") && (filename = "file://" + filename);
+      sourceMap
+        ? ((col +=
+            "\n//# sourceURL=rsc://React/" +
+            encodeURIComponent(environmentName) +
+            "/" +
+            encodeURI(filename) +
+            "?" +
+            fakeFunctionIdx++),
+          (col += "\n//# sourceMappingURL=" + sourceMap))
+        : (col = filename
+            ? col + ("\n//# sourceURL=" + encodeURI(filename))
+            : col + "\n//# sourceURL=<anonymous>");
+      try {
+        var fn = (0, eval)(col)[name];
+      } catch (x) {
+        fn = function (_) {
+          return _();
+        };
+      }
+      return fn;
+    }
+    function buildFakeCallStack(response, stack, environmentName, innerCall) {
+      for (var i = 0; i < stack.length; i++) {
+        var frame = stack[i],
+          frameKey = frame.join("-") + "-" + environmentName,
+          fn = fakeFunctionCache.get(frameKey);
+        if (void 0 === fn) {
+          fn = frame[0];
+          var filename = frame[1],
+            line = frame[2];
+          frame = frame[3];
+          var findSourceMapURL = response._debugFindSourceMapURL;
+          findSourceMapURL = findSourceMapURL
+            ? findSourceMapURL(filename, environmentName)
+            : null;
+          fn = createFakeFunction(
+            fn,
+            filename,
+            findSourceMapURL,
+            line,
+            frame,
+            environmentName
+          );
+          fakeFunctionCache.set(frameKey, fn);
+        }
+        innerCall = fn.bind(null, innerCall);
+      }
+      return innerCall;
+    }
+    function getRootTask(response, childEnvironmentName) {
+      var rootTask = response._debugRootTask;
+      return rootTask
+        ? response._rootEnvironmentName !== childEnvironmentName
+          ? ((response = console.createTask.bind(
+              console,
+              '"use ' + childEnvironmentName.toLowerCase() + '"'
+            )),
+            rootTask.run(response))
+          : rootTask
+        : null;
+    }
+    function initializeFakeTask(response, debugInfo, childEnvironmentName) {
+      if (!supportsCreateTask || null == debugInfo.stack) return null;
+      var stack = debugInfo.stack,
+        env =
+          null == debugInfo.env ? response._rootEnvironmentName : debugInfo.env;
+      if (env !== childEnvironmentName)
+        return (
+          (debugInfo =
+            null == debugInfo.owner
+              ? null
+              : initializeFakeTask(response, debugInfo.owner, env)),
+          buildFakeTask(
+            response,
+            debugInfo,
+            stack,
+            '"use ' + childEnvironmentName.toLowerCase() + '"',
+            env
+          )
+        );
+      childEnvironmentName = debugInfo.debugTask;
+      if (void 0 !== childEnvironmentName) return childEnvironmentName;
+      childEnvironmentName =
+        null == debugInfo.owner
+          ? null
+          : initializeFakeTask(response, debugInfo.owner, env);
+      return (debugInfo.debugTask = buildFakeTask(
+        response,
+        childEnvironmentName,
+        stack,
+        "<" + (debugInfo.name || "...") + ">",
+        env
+      ));
+    }
+    function buildFakeTask(response, ownerTask, stack, taskName, env) {
+      taskName = console.createTask.bind(console, taskName);
+      stack = buildFakeCallStack(response, stack, env, taskName);
+      return null === ownerTask
+        ? ((response = getRootTask(response, env)),
+          null != response ? response.run(stack) : stack())
+        : ownerTask.run(stack);
+    }
+    function fakeJSXCallSite() {
+      return Error("react-stack-top-frame");
+    }
+    function initializeFakeStack(response, debugInfo) {
+      void 0 === debugInfo.debugStack &&
+        (null != debugInfo.stack &&
+          (debugInfo.debugStack = createFakeJSXCallStackInDEV(
+            response,
+            debugInfo.stack,
+            null == debugInfo.env ? "" : debugInfo.env
+          )),
+        null != debugInfo.owner &&
+          initializeFakeStack(response, debugInfo.owner));
+    }
+    function resolveDebugInfo(response, id, debugInfo) {
+      var env =
+        void 0 === debugInfo.env
+          ? response._rootEnvironmentName
+          : debugInfo.env;
+      void 0 !== debugInfo.stack &&
+        initializeFakeTask(response, debugInfo, env);
+      null === debugInfo.owner && null != response._debugRootOwner
+        ? ((env = debugInfo),
+          (env.owner = response._debugRootOwner),
+          (env.debugStack = response._debugRootStack))
+        : void 0 !== debugInfo.stack &&
+          initializeFakeStack(response, debugInfo);
+      "number" === typeof debugInfo.time &&
+        (debugInfo = { time: debugInfo.time + response._timeOrigin });
+      response = getChunk(response, id);
+      (response._debugInfo || (response._debugInfo = [])).push(debugInfo);
+    }
+    function getCurrentStackInDEV() {
+      var owner = currentOwnerInDEV;
+      if (null === owner) return "";
+      try {
+        var info = "";
+        if (owner.owner || "string" !== typeof owner.name) {
+          for (; owner; ) {
+            var ownerStack = owner.debugStack;
+            if (null != ownerStack) {
+              if ((owner = owner.owner)) {
+                var JSCompiler_temp_const = info;
+                var error = ownerStack,
+                  prevPrepareStackTrace = Error.prepareStackTrace;
+                Error.prepareStackTrace = prepareStackTrace;
+                var stack = error.stack;
+                Error.prepareStackTrace = prevPrepareStackTrace;
+                stack.startsWith("Error: react-stack-top-frame\n") &&
+                  (stack = stack.slice(29));
+                var idx = stack.indexOf("\n");
+                -1 !== idx && (stack = stack.slice(idx + 1));
+                idx = stack.indexOf("react-stack-bottom-frame");
+                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                var JSCompiler_inline_result =
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                info =
+                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+              }
+            } else break;
+          }
+          var JSCompiler_inline_result$jscomp$0 = info;
+        } else {
+          JSCompiler_temp_const = owner.name;
+          if (void 0 === prefix)
+            try {
+              throw Error();
+            } catch (x) {
+              (prefix =
+                ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
+                ""),
+                (suffix =
+                  -1 < x.stack.indexOf("\n    at")
+                    ? " (<anonymous>)"
+                    : -1 < x.stack.indexOf("@")
+                      ? "@unknown:0:0"
+                      : "");
+            }
+          JSCompiler_inline_result$jscomp$0 =
+            "\n" + prefix + JSCompiler_temp_const + suffix;
+        }
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
+    }
+    function resolveConsoleEntry(response, value) {
+      if (response._replayConsole) {
+        var payload = JSON.parse(value, response._fromJSON);
+        value = payload[0];
+        var stackTrace = payload[1],
+          owner = payload[2],
+          env = payload[3];
+        payload = payload.slice(4);
+        replayConsoleWithCallStackInDEV(
+          response,
+          value,
+          stackTrace,
+          owner,
+          env,
+          payload
+        );
+      }
+    }
+    function mergeBuffer(buffer, lastChunk) {
+      for (
+        var l = buffer.length, byteLength = lastChunk.length, i = 0;
+        i < l;
+        i++
+      )
+        byteLength += buffer[i].byteLength;
+      byteLength = new Uint8Array(byteLength);
+      for (var _i2 = (i = 0); _i2 < l; _i2++) {
+        var chunk = buffer[_i2];
+        byteLength.set(chunk, i);
+        i += chunk.byteLength;
+      }
+      byteLength.set(lastChunk, i);
+      return byteLength;
+    }
+    function resolveTypedArray(
+      response,
+      id,
+      buffer,
+      lastChunk,
+      constructor,
+      bytesPerElement
+    ) {
+      buffer =
+        0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
+          ? lastChunk
+          : mergeBuffer(buffer, lastChunk);
+      constructor = new constructor(
+        buffer.buffer,
+        buffer.byteOffset,
+        buffer.byteLength / bytesPerElement
+      );
+      resolveBuffer(response, id, constructor);
+    }
+    function flushComponentPerformance(
+      response,
+      root,
+      trackIdx$jscomp$0,
+      trackTime,
+      parentEndTime
+    ) {
+      if (!isArrayImpl(root._children)) {
+        response = root._children;
+        root = response.endTime;
+        if (
+          -Infinity < parentEndTime &&
+          parentEndTime < root &&
+          null !== response.component
+        ) {
+          var trackIdx = trackIdx$jscomp$0,
+            startTime = parentEndTime;
+          if (supportsUserTiming && 0 <= root && 10 > trackIdx) {
+            var name = response.component.name;
+            reusableComponentDevToolDetails.color = "tertiary-light";
+            reusableComponentDevToolDetails.track = trackNames[trackIdx];
+            reusableComponentOptions.start = 0 > startTime ? 0 : startTime;
+            reusableComponentOptions.end = root;
+            performance.measure(name + " [deduped]", reusableComponentOptions);
+          }
+        }
+        response.track = trackIdx$jscomp$0;
+        return response;
+      }
+      var children = root._children;
+      "resolved_model" === root.status && initializeModelChunk(root);
+      if ((trackIdx = root._debugInfo)) {
+        for (startTime = 1; startTime < trackIdx.length; startTime++)
+          if (
+            "string" === typeof trackIdx[startTime].name &&
+            ((name = trackIdx[startTime - 1]), "number" === typeof name.time)
+          ) {
+            startTime = name.time;
+            startTime < trackTime && trackIdx$jscomp$0++;
+            trackTime = startTime;
+            break;
+          }
+        for (startTime = trackIdx.length - 1; 0 <= startTime; startTime--)
+          (name = trackIdx[startTime]),
+            "number" === typeof name.time &&
+              name.time > parentEndTime &&
+              (parentEndTime = name.time);
+      }
+      startTime = {
+        track: trackIdx$jscomp$0,
+        endTime: -Infinity,
+        component: null
+      };
+      root._children = startTime;
+      name = -Infinity;
+      var childTrackIdx = trackIdx$jscomp$0,
+        childTrackTime = trackTime;
+      for (trackTime = 0; trackTime < children.length; trackTime++) {
+        childTrackTime = flushComponentPerformance(
+          response,
+          children[trackTime],
+          childTrackIdx,
+          childTrackTime,
+          parentEndTime
+        );
+        null !== childTrackTime.component &&
+          (startTime.component = childTrackTime.component);
+        childTrackIdx = childTrackTime.track;
+        var childEndTime = childTrackTime.endTime;
+        childTrackTime = childEndTime;
+        childEndTime > name && (name = childEndTime);
+      }
+      if (trackIdx)
+        for (
+          parentEndTime = 0, childTrackIdx = !0, children = trackIdx.length - 1;
+          0 <= children;
+          children--
+        )
+          if (
+            ((trackTime = trackIdx[children]),
+            "number" === typeof trackTime.time &&
+              ((parentEndTime = trackTime.time),
+              parentEndTime > name && (name = parentEndTime)),
+            "string" === typeof trackTime.name && 0 < children)
+          ) {
+            childTrackTime = trackIdx[children - 1];
+            if ("number" === typeof childTrackTime.time) {
+              childTrackTime = childTrackTime.time;
+              if (
+                childTrackIdx &&
+                "rejected" === root.status &&
+                root.reason !== response._closedReason
+              ) {
+                var componentInfo = trackTime;
+                childTrackIdx = trackIdx$jscomp$0;
+                childEndTime = name;
+                var rootEnv = response._rootEnvironmentName,
+                  error = root.reason;
+                if (supportsUserTiming) {
+                  var properties = [];
+                  properties.push([
+                    "Error",
+                    "object" === typeof error &&
+                    null !== error &&
+                    "string" === typeof error.message
+                      ? String(error.message)
+                      : String(error)
+                  ]);
+                  error = componentInfo.env;
+                  componentInfo = componentInfo.name;
+                  componentInfo =
+                    error === rootEnv || void 0 === error
+                      ? componentInfo
+                      : componentInfo + " [" + error + "]";
+                  performance.measure(componentInfo, {
+                    start: 0 > childTrackTime ? 0 : childTrackTime,
+                    end: childEndTime,
+                    detail: {
+                      devtools: {
+                        color: "error",
+                        track: trackNames[childTrackIdx],
+                        trackGroup: "Server Components \u269b",
+                        tooltipText: componentInfo + " Errored",
+                        properties: properties
+                      }
+                    }
+                  });
+                }
+              } else
+                (childTrackIdx = trackIdx$jscomp$0),
+                  (childEndTime = name),
+                  supportsUserTiming &&
+                    0 <= childEndTime &&
+                    10 > childTrackIdx &&
+                    ((properties = trackTime.env),
+                    (componentInfo = trackTime.name),
+                    (rootEnv = properties === response._rootEnvironmentName),
+                    (error = parentEndTime - childTrackTime),
+                    (reusableComponentDevToolDetails.color =
+                      0.5 > error
+                        ? rootEnv
+                          ? "primary-light"
+                          : "secondary-light"
+                        : 50 > error
+                          ? rootEnv
+                            ? "primary"
+                            : "secondary"
+                          : 500 > error
+                            ? rootEnv
+                              ? "primary-dark"
+                              : "secondary-dark"
+                            : "error"),
+                    (reusableComponentDevToolDetails.track =
+                      trackNames[childTrackIdx]),
+                    (reusableComponentOptions.start =
+                      0 > childTrackTime ? 0 : childTrackTime),
+                    (reusableComponentOptions.end = childEndTime),
+                    performance.measure(
+                      rootEnv || void 0 === properties
+                        ? componentInfo
+                        : componentInfo + " [" + properties + "]",
+                      reusableComponentOptions
+                    ));
+              startTime.component = trackTime;
+            }
+            childTrackIdx = !1;
+          }
+      startTime.endTime = name;
+      return startTime;
+    }
+    function processFullBinaryRow(response, id, tag, buffer, chunk) {
+      switch (tag) {
+        case 65:
+          resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+          return;
+        case 79:
+          resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+          return;
+        case 111:
+          resolveBuffer(
+            response,
+            id,
+            0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+          );
+          return;
+        case 85:
+          resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+          return;
+        case 83:
+          resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+          return;
+        case 115:
+          resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+          return;
+        case 76:
+          resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+          return;
+        case 108:
+          resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+          return;
+        case 71:
+          resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+          return;
+        case 103:
+          resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+          return;
+        case 77:
+          resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+          return;
+        case 109:
+          resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+          return;
+        case 86:
+          resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+          return;
+      }
+      for (
+        var stringDecoder = response._stringDecoder, row = "", i = 0;
+        i < buffer.length;
+        i++
+      )
+        row += stringDecoder.decode(buffer[i], decoderOptions);
+      row += stringDecoder.decode(chunk);
+      processFullStringRow(response, id, tag, row);
+    }
+    function processFullStringRow(response, id, tag, row) {
+      switch (tag) {
+        case 73:
+          resolveModule(response, id, row);
+          break;
+        case 72:
+          resolveHint(response, row[0], row.slice(1));
+          break;
+        case 69:
+          row = JSON.parse(row);
+          tag = resolveErrorDev(response, row);
+          tag.digest = row.digest;
+          row = response._chunks;
+          var chunk = row.get(id);
+          chunk
+            ? triggerErrorOnChunk(chunk, tag)
+            : row.set(id, createErrorChunk(response, tag));
+          break;
+        case 84:
+          resolveText(response, id, row);
+          break;
+        case 78:
+          response._timeOrigin = +row - performance.timeOrigin;
+          break;
+        case 68:
+          tag = new ReactPromise("resolved_model", row, null, response);
+          initializeModelChunk(tag);
+          "fulfilled" === tag.status
+            ? resolveDebugInfo(response, id, tag.value)
+            : tag.then(
+                function (v) {
+                  return resolveDebugInfo(response, id, v);
+                },
+                function () {}
+              );
+          break;
+        case 87:
+          resolveConsoleEntry(response, row);
+          break;
+        case 82:
+          startReadableStream(response, id, void 0);
+          break;
+        case 114:
+          startReadableStream(response, id, "bytes");
+          break;
+        case 88:
+          startAsyncIterable(response, id, !1);
+          break;
+        case 120:
+          startAsyncIterable(response, id, !0);
+          break;
+        case 67:
+          stopStream(response, id, row);
+          break;
+        case 80:
+          tag = JSON.parse(row);
+          resolvePostponeDev(response, id, tag.reason, tag.stack, tag.env);
+          break;
+        default:
+          resolveModel(response, id, row);
+      }
+    }
+    function createFromJSONCallback(response) {
+      return function (key, value) {
+        if ("string" === typeof value)
+          return parseModelString(response, this, key, value);
+        if ("object" === typeof value && null !== value) {
+          if (value[0] === REACT_ELEMENT_TYPE) {
+            var type = value[1];
+            key = value[4];
+            var stack = value[5],
+              validated = value[6];
+            value = {
+              $$typeof: REACT_ELEMENT_TYPE,
+              type: type,
+              key: value[2],
+              props: value[3],
+              _owner: null === key ? response._debugRootOwner : key
+            };
+            Object.defineProperty(value, "ref", {
+              enumerable: !1,
+              get: nullRefGetter
+            });
+            value._store = {};
+            Object.defineProperty(value._store, "validated", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: validated
+            });
+            Object.defineProperty(value, "_debugInfo", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: null
+            });
+            validated = response._rootEnvironmentName;
+            null !== key && null != key.env && (validated = key.env);
+            var normalizedStackTrace = null;
+            null === key && null != response._debugRootStack
+              ? (normalizedStackTrace = response._debugRootStack)
+              : null !== stack &&
+                (normalizedStackTrace = createFakeJSXCallStackInDEV(
+                  response,
+                  stack,
+                  validated
+                ));
+            Object.defineProperty(value, "_debugStack", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: normalizedStackTrace
+            });
+            normalizedStackTrace = null;
+            supportsCreateTask &&
+              null !== stack &&
+              ((type = console.createTask.bind(console, getTaskName(type))),
+              (stack = buildFakeCallStack(response, stack, validated, type)),
+              (type =
+                null === key
+                  ? null
+                  : initializeFakeTask(response, key, validated)),
+              null === type
+                ? ((type = response._debugRootTask),
+                  (normalizedStackTrace =
+                    null != type ? type.run(stack) : stack()))
+                : (normalizedStackTrace = type.run(stack)));
+            Object.defineProperty(value, "_debugTask", {
+              configurable: !1,
+              enumerable: !1,
+              writable: !0,
+              value: normalizedStackTrace
+            });
+            null !== key && initializeFakeStack(response, key);
+            null !== initializingHandler
+              ? ((stack = initializingHandler),
+                (initializingHandler = stack.parent),
+                stack.errored
+                  ? ((key = createErrorChunk(response, stack.value)),
+                    (stack = {
+                      name: getComponentNameFromType(value.type) || "",
+                      owner: value._owner
+                    }),
+                    (stack.debugStack = value._debugStack),
+                    supportsCreateTask && (stack.debugTask = value._debugTask),
+                    (key._debugInfo = [stack]),
+                    (value = createLazyChunkWrapper(key)))
+                  : 0 < stack.deps &&
+                    ((key = new ReactPromise("blocked", null, null, response)),
+                    (stack.value = value),
+                    (stack.chunk = key),
+                    (value = Object.freeze.bind(Object, value.props)),
+                    key.then(value, value),
+                    (value = createLazyChunkWrapper(key))))
+              : Object.freeze(value.props);
+          }
+          return value;
+        }
+        return value;
+      };
+    }
+    function noServerCall() {
+      throw Error(
+        "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+      );
+    }
+    var util = require("util"),
+      ReactDOM = require("react-dom"),
+      React = require("react"),
+      decoderOptions = { stream: !0 },
+      bind$1 = Function.prototype.bind,
+      asyncModuleCache = new Map(),
+      ReactDOMSharedInternals =
+        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
+      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
+      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
+    Symbol.for("react.provider");
+    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
+      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+      REACT_MEMO_TYPE = Symbol.for("react.memo"),
+      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
+      isArrayImpl = Array.isArray,
+      getPrototypeOf = Object.getPrototypeOf,
+      jsxPropsParents = new WeakMap(),
+      jsxChildrenParents = new WeakMap(),
+      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      ObjectPrototype = Object.prototype,
+      knownServerReferences = new WeakMap(),
+      boundCache = new WeakMap(),
+      fakeServerFunctionIdx = 0,
+      FunctionBind = Function.prototype.bind,
+      ArraySlice = Array.prototype.slice,
+      v8FrameRegExp =
+        /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/,
+      jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/,
+      supportsUserTiming =
+        "undefined" !== typeof performance &&
+        "function" === typeof performance.measure,
+      componentsTrackMarker = {
+        startTime: 0.001,
+        detail: {
+          devtools: {
+            color: "primary-light",
+            track: "Primary",
+            trackGroup: "Server Components \u269b"
+          }
+        }
+      },
+      reusableComponentDevToolDetails = {
+        color: "primary",
+        track: "",
+        trackGroup: "Server Components \u269b"
+      },
+      reusableComponentOptions = {
+        start: -0,
+        end: -0,
+        detail: { devtools: reusableComponentDevToolDetails }
+      },
+      trackNames =
+        "Primary Parallel Parallel\u200b Parallel\u200b\u200b Parallel\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b Parallel\u200b\u200b\u200b\u200b\u200b\u200b\u200b\u200b".split(
+          " "
+        ),
+      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
+      prefix,
+      suffix;
+    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    var ReactSharedInteralsServer =
+        React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      ReactSharedInternals =
+        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE ||
+        ReactSharedInteralsServer;
+    ReactPromise.prototype = Object.create(Promise.prototype);
+    ReactPromise.prototype.then = function (resolve, reject) {
+      switch (this.status) {
+        case "resolved_model":
+          initializeModelChunk(this);
+          break;
+        case "resolved_module":
+          initializeModuleChunk(this);
+      }
+      switch (this.status) {
+        case "fulfilled":
+          resolve(this.value);
+          break;
+        case "pending":
+        case "blocked":
+          resolve &&
+            (null === this.value && (this.value = []),
+            this.value.push(resolve));
+          reject &&
+            (null === this.reason && (this.reason = []),
+            this.reason.push(reject));
+          break;
+        default:
+          reject && reject(this.reason);
+      }
+    };
+    var initializingHandler = null,
+      initializingChunk = null,
+      supportsCreateTask = !!console.createTask,
+      fakeFunctionCache = new Map(),
+      fakeFunctionIdx = 0,
+      createFakeJSXCallStack = {
+        "react-stack-bottom-frame": function (
+          response,
+          stack,
+          environmentName
+        ) {
+          return buildFakeCallStack(
+            response,
+            stack,
+            environmentName,
+            fakeJSXCallSite
+          )();
+        }
+      },
+      createFakeJSXCallStackInDEV = createFakeJSXCallStack[
+        "react-stack-bottom-frame"
+      ].bind(createFakeJSXCallStack),
+      currentOwnerInDEV = null,
+      replayConsoleWithCallStack = {
+        "react-stack-bottom-frame": function (
+          response,
+          methodName,
+          stackTrace,
+          owner,
+          env,
+          args
+        ) {
+          var prevStack = ReactSharedInternals.getCurrentStack;
+          ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
+          currentOwnerInDEV = null === owner ? response._debugRootOwner : owner;
+          try {
+            a: {
+              var offset = 0;
+              switch (methodName) {
+                case "dir":
+                case "dirxml":
+                case "groupEnd":
+                case "table":
+                  var JSCompiler_inline_result = bind$1.apply(
+                    console[methodName],
+                    [console].concat(args)
+                  );
+                  break a;
+                case "assert":
+                  offset = 1;
+              }
+              var newArgs = args.slice(0);
+              "string" === typeof newArgs[offset]
+                ? newArgs.splice(
+                    offset,
+                    1,
+                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c " + newArgs[offset],
+                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
+                    " " + env + " ",
+                    ""
+                  )
+                : newArgs.splice(
+                    offset,
+                    0,
+                    "\u001b[0m\u001b[7m%c%s\u001b[0m%c ",
+                    "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
+                    " " + env + " ",
+                    ""
+                  );
+              newArgs.unshift(console);
+              JSCompiler_inline_result = bind$1.apply(
+                console[methodName],
+                newArgs
+              );
+            }
+            var callStack = buildFakeCallStack(
+              response,
+              stackTrace,
+              env,
+              JSCompiler_inline_result
+            );
+            if (null != owner) {
+              var task = initializeFakeTask(response, owner, env);
+              initializeFakeStack(response, owner);
+              if (null !== task) {
+                task.run(callStack);
+                return;
+              }
+            }
+            var rootTask = getRootTask(response, env);
+            null != rootTask ? rootTask.run(callStack) : callStack();
+          } finally {
+            (currentOwnerInDEV = null),
+              (ReactSharedInternals.getCurrentStack = prevStack);
+          }
+        }
+      },
+      replayConsoleWithCallStackInDEV = replayConsoleWithCallStack[
+        "react-stack-bottom-frame"
+      ].bind(replayConsoleWithCallStack);
+    exports.createFromNodeStream = function (
+      stream,
+      moduleRootPath,
+      moduleBaseURL,
+      options
+    ) {
+      var response = new ResponseInstance(
+        moduleRootPath,
+        null,
+        moduleBaseURL,
+        noServerCall,
+        options ? options.encodeFormAction : void 0,
+        options && "string" === typeof options.nonce ? options.nonce : void 0,
+        void 0,
+        options && options.findSourceMapURL ? options.findSourceMapURL : void 0,
+        options ? !0 === options.replayConsoleLogs : !1,
+        options && options.environmentName ? options.environmentName : void 0
+      );
+      stream.on("data", function (chunk) {
+        for (
+          var i = 0,
+            rowState = response._rowState,
+            rowID = response._rowID,
+            rowTag = response._rowTag,
+            rowLength = response._rowLength,
+            buffer = response._buffer,
+            chunkLength = chunk.length;
+          i < chunkLength;
+
+        ) {
+          var lastIdx = -1;
+          switch (rowState) {
+            case 0:
+              lastIdx = chunk[i++];
+              58 === lastIdx
+                ? (rowState = 1)
+                : (rowID =
+                    (rowID << 4) |
+                    (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+              continue;
+            case 1:
+              rowState = chunk[i];
+              84 === rowState ||
+              65 === rowState ||
+              79 === rowState ||
+              111 === rowState ||
+              85 === rowState ||
+              83 === rowState ||
+              115 === rowState ||
+              76 === rowState ||
+              108 === rowState ||
+              71 === rowState ||
+              103 === rowState ||
+              77 === rowState ||
+              109 === rowState ||
+              86 === rowState
+                ? ((rowTag = rowState), (rowState = 2), i++)
+                : (64 < rowState && 91 > rowState) ||
+                    35 === rowState ||
+                    114 === rowState ||
+                    120 === rowState
+                  ? ((rowTag = rowState), (rowState = 3), i++)
+                  : ((rowTag = 0), (rowState = 3));
+              continue;
+            case 2:
+              lastIdx = chunk[i++];
+              44 === lastIdx
+                ? (rowState = 4)
+                : (rowLength =
+                    (rowLength << 4) |
+                    (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+              continue;
+            case 3:
+              lastIdx = chunk.indexOf(10, i);
+              break;
+            case 4:
+              (lastIdx = i + rowLength),
+                lastIdx > chunk.length && (lastIdx = -1);
+          }
+          var offset = chunk.byteOffset + i;
+          if (-1 < lastIdx)
+            (rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i)),
+              processFullBinaryRow(response, rowID, rowTag, buffer, rowLength),
+              (i = lastIdx),
+              3 === rowState && i++,
+              (rowLength = rowID = rowTag = rowState = 0),
+              (buffer.length = 0);
+          else {
+            chunk = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);
+            buffer.push(chunk);
+            rowLength -= chunk.byteLength;
+            break;
+          }
+        }
+        response._rowState = rowState;
+        response._rowID = rowID;
+        response._rowTag = rowTag;
+        response._rowLength = rowLength;
+      });
+      stream.on("error", function (error) {
+        reportGlobalError(response, error);
+      });
+      stream.on("end", function () {
+        reportGlobalError(response, Error("Connection closed."));
+      });
+      return getChunk(response, 0);
+    };
+    exports.createServerReference = function (id) {
+      return createServerReference$1(id, noServerCall);
+    };
+  })();
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.production.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.production.js
new file mode 100644
index 0000000..51e251d
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-client.node.production.js
@@ -0,0 +1,1716 @@
+/**
+ * @license React
+ * react-server-dom-esm-client.node.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+var util = require("util"),
+  ReactDOM = require("react-dom"),
+  decoderOptions = { stream: !0 };
+function resolveServerReference(config, id) {
+  var idx = id.lastIndexOf("#"),
+    exportName = id.slice(idx + 1);
+  id = id.slice(0, idx);
+  if (!id.startsWith(config))
+    throw Error(
+      "Attempted to load a Server Reference outside the hosted root."
+    );
+  return { specifier: id, name: exportName };
+}
+var asyncModuleCache = new Map();
+function preloadModule(metadata) {
+  var existingPromise = asyncModuleCache.get(metadata.specifier);
+  if (existingPromise)
+    return "fulfilled" === existingPromise.status ? null : existingPromise;
+  var modulePromise = import(metadata.specifier);
+  modulePromise.then(
+    function (value) {
+      modulePromise.status = "fulfilled";
+      modulePromise.value = value;
+    },
+    function (reason) {
+      modulePromise.status = "rejected";
+      modulePromise.reason = reason;
+    }
+  );
+  asyncModuleCache.set(metadata.specifier, modulePromise);
+  return modulePromise;
+}
+function requireModule(metadata) {
+  var moduleExports = asyncModuleCache.get(metadata.specifier);
+  if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
+  else throw moduleExports.reason;
+  return moduleExports[metadata.name];
+}
+function prepareDestinationForModuleImpl(moduleLoading, mod, nonce) {
+  "string" === typeof moduleLoading
+    ? ReactDOMSharedInternals.d.M(moduleLoading + mod, {
+        crossOrigin: getCrossOriginString(void 0),
+        nonce: nonce
+      })
+    : null !== moduleLoading &&
+      ReactDOMSharedInternals.d.M(moduleLoading.prefix + mod, {
+        crossOrigin: getCrossOriginString(moduleLoading.crossOrigin),
+        nonce: nonce
+      });
+}
+var ReactDOMSharedInternals =
+  ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+function getCrossOriginString(input) {
+  if ("string" === typeof input)
+    return "use-credentials" === input ? input : "";
+}
+var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+function getIteratorFn(maybeIterable) {
+  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  maybeIterable =
+    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+    maybeIterable["@@iterator"];
+  return "function" === typeof maybeIterable ? maybeIterable : null;
+}
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  isArrayImpl = Array.isArray,
+  getPrototypeOf = Object.getPrototypeOf,
+  ObjectPrototype = Object.prototype,
+  knownServerReferences = new WeakMap();
+function serializeNumber(number) {
+  return Number.isFinite(number)
+    ? 0 === number && -Infinity === 1 / number
+      ? "$-0"
+      : number
+    : Infinity === number
+      ? "$Infinity"
+      : -Infinity === number
+        ? "$-Infinity"
+        : "$NaN";
+}
+function processReply(
+  root,
+  formFieldPrefix,
+  temporaryReferences,
+  resolve,
+  reject
+) {
+  function serializeTypedArray(tag, typedArray) {
+    typedArray = new Blob([
+      new Uint8Array(
+        typedArray.buffer,
+        typedArray.byteOffset,
+        typedArray.byteLength
+      )
+    ]);
+    var blobId = nextPartId++;
+    null === formData && (formData = new FormData());
+    formData.append(formFieldPrefix + blobId, typedArray);
+    return "$" + tag + blobId.toString(16);
+  }
+  function serializeBinaryReader(reader) {
+    function progress(entry) {
+      entry.done
+        ? ((entry = nextPartId++),
+          data.append(formFieldPrefix + entry, new Blob(buffer)),
+          data.append(
+            formFieldPrefix + streamId,
+            '"$o' + entry.toString(16) + '"'
+          ),
+          data.append(formFieldPrefix + streamId, "C"),
+          pendingParts--,
+          0 === pendingParts && resolve(data))
+        : (buffer.push(entry.value),
+          reader.read(new Uint8Array(1024)).then(progress, reject));
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++,
+      buffer = [];
+    reader.read(new Uint8Array(1024)).then(progress, reject);
+    return "$r" + streamId.toString(16);
+  }
+  function serializeReader(reader) {
+    function progress(entry) {
+      if (entry.done)
+        data.append(formFieldPrefix + streamId, "C"),
+          pendingParts--,
+          0 === pendingParts && resolve(data);
+      else
+        try {
+          var partJSON = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON);
+          reader.read().then(progress, reject);
+        } catch (x) {
+          reject(x);
+        }
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+    reader.read().then(progress, reject);
+    return "$R" + streamId.toString(16);
+  }
+  function serializeReadableStream(stream) {
+    try {
+      var binaryReader = stream.getReader({ mode: "byob" });
+    } catch (x) {
+      return serializeReader(stream.getReader());
+    }
+    return serializeBinaryReader(binaryReader);
+  }
+  function serializeAsyncIterable(iterable, iterator) {
+    function progress(entry) {
+      if (entry.done) {
+        if (void 0 === entry.value)
+          data.append(formFieldPrefix + streamId, "C");
+        else
+          try {
+            var partJSON = JSON.stringify(entry.value, resolveToJSON);
+            data.append(formFieldPrefix + streamId, "C" + partJSON);
+          } catch (x) {
+            reject(x);
+            return;
+          }
+        pendingParts--;
+        0 === pendingParts && resolve(data);
+      } else
+        try {
+          var partJSON$22 = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON$22);
+          iterator.next().then(progress, reject);
+        } catch (x$23) {
+          reject(x$23);
+        }
+    }
+    null === formData && (formData = new FormData());
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+    iterable = iterable === iterator;
+    iterator.next().then(progress, reject);
+    return "$" + (iterable ? "x" : "X") + streamId.toString(16);
+  }
+  function resolveToJSON(key, value) {
+    if (null === value) return null;
+    if ("object" === typeof value) {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          if (void 0 !== temporaryReferences && -1 === key.indexOf(":")) {
+            var parentReference = writtenObjects.get(this);
+            if (void 0 !== parentReference)
+              return (
+                temporaryReferences.set(parentReference + ":" + key, value),
+                "$T"
+              );
+          }
+          throw Error(
+            "React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+          );
+        case REACT_LAZY_TYPE:
+          parentReference = value._payload;
+          var init = value._init;
+          null === formData && (formData = new FormData());
+          pendingParts++;
+          try {
+            var resolvedModel = init(parentReference),
+              lazyId = nextPartId++,
+              partJSON = serializeModel(resolvedModel, lazyId);
+            formData.append(formFieldPrefix + lazyId, partJSON);
+            return "$" + lazyId.toString(16);
+          } catch (x) {
+            if (
+              "object" === typeof x &&
+              null !== x &&
+              "function" === typeof x.then
+            ) {
+              pendingParts++;
+              var lazyId$24 = nextPartId++;
+              parentReference = function () {
+                try {
+                  var partJSON$25 = serializeModel(value, lazyId$24),
+                    data$26 = formData;
+                  data$26.append(formFieldPrefix + lazyId$24, partJSON$25);
+                  pendingParts--;
+                  0 === pendingParts && resolve(data$26);
+                } catch (reason) {
+                  reject(reason);
+                }
+              };
+              x.then(parentReference, parentReference);
+              return "$" + lazyId$24.toString(16);
+            }
+            reject(x);
+            return null;
+          } finally {
+            pendingParts--;
+          }
+      }
+      if ("function" === typeof value.then) {
+        null === formData && (formData = new FormData());
+        pendingParts++;
+        var promiseId = nextPartId++;
+        value.then(function (partValue) {
+          try {
+            var partJSON$28 = serializeModel(partValue, promiseId);
+            partValue = formData;
+            partValue.append(formFieldPrefix + promiseId, partJSON$28);
+            pendingParts--;
+            0 === pendingParts && resolve(partValue);
+          } catch (reason) {
+            reject(reason);
+          }
+        }, reject);
+        return "$@" + promiseId.toString(16);
+      }
+      parentReference = writtenObjects.get(value);
+      if (void 0 !== parentReference)
+        if (modelRoot === value) modelRoot = null;
+        else return parentReference;
+      else
+        -1 === key.indexOf(":") &&
+          ((parentReference = writtenObjects.get(this)),
+          void 0 !== parentReference &&
+            ((key = parentReference + ":" + key),
+            writtenObjects.set(value, key),
+            void 0 !== temporaryReferences &&
+              temporaryReferences.set(key, value)));
+      if (isArrayImpl(value)) return value;
+      if (value instanceof FormData) {
+        null === formData && (formData = new FormData());
+        var data$32 = formData;
+        key = nextPartId++;
+        var prefix = formFieldPrefix + key + "_";
+        value.forEach(function (originalValue, originalKey) {
+          data$32.append(prefix + originalKey, originalValue);
+        });
+        return "$K" + key.toString(16);
+      }
+      if (value instanceof Map)
+        return (
+          (key = nextPartId++),
+          (parentReference = serializeModel(Array.from(value), key)),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + key, parentReference),
+          "$Q" + key.toString(16)
+        );
+      if (value instanceof Set)
+        return (
+          (key = nextPartId++),
+          (parentReference = serializeModel(Array.from(value), key)),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + key, parentReference),
+          "$W" + key.toString(16)
+        );
+      if (value instanceof ArrayBuffer)
+        return (
+          (key = new Blob([value])),
+          (parentReference = nextPartId++),
+          null === formData && (formData = new FormData()),
+          formData.append(formFieldPrefix + parentReference, key),
+          "$A" + parentReference.toString(16)
+        );
+      if (value instanceof Int8Array) return serializeTypedArray("O", value);
+      if (value instanceof Uint8Array) return serializeTypedArray("o", value);
+      if (value instanceof Uint8ClampedArray)
+        return serializeTypedArray("U", value);
+      if (value instanceof Int16Array) return serializeTypedArray("S", value);
+      if (value instanceof Uint16Array) return serializeTypedArray("s", value);
+      if (value instanceof Int32Array) return serializeTypedArray("L", value);
+      if (value instanceof Uint32Array) return serializeTypedArray("l", value);
+      if (value instanceof Float32Array) return serializeTypedArray("G", value);
+      if (value instanceof Float64Array) return serializeTypedArray("g", value);
+      if (value instanceof BigInt64Array)
+        return serializeTypedArray("M", value);
+      if (value instanceof BigUint64Array)
+        return serializeTypedArray("m", value);
+      if (value instanceof DataView) return serializeTypedArray("V", value);
+      if ("function" === typeof Blob && value instanceof Blob)
+        return (
+          null === formData && (formData = new FormData()),
+          (key = nextPartId++),
+          formData.append(formFieldPrefix + key, value),
+          "$B" + key.toString(16)
+        );
+      if ((key = getIteratorFn(value)))
+        return (
+          (parentReference = key.call(value)),
+          parentReference === value
+            ? ((key = nextPartId++),
+              (parentReference = serializeModel(
+                Array.from(parentReference),
+                key
+              )),
+              null === formData && (formData = new FormData()),
+              formData.append(formFieldPrefix + key, parentReference),
+              "$i" + key.toString(16))
+            : Array.from(parentReference)
+        );
+      if (
+        "function" === typeof ReadableStream &&
+        value instanceof ReadableStream
+      )
+        return serializeReadableStream(value);
+      key = value[ASYNC_ITERATOR];
+      if ("function" === typeof key)
+        return serializeAsyncIterable(value, key.call(value));
+      key = getPrototypeOf(value);
+      if (
+        key !== ObjectPrototype &&
+        (null === key || null !== getPrototypeOf(key))
+      ) {
+        if (void 0 === temporaryReferences)
+          throw Error(
+            "Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported."
+          );
+        return "$T";
+      }
+      return value;
+    }
+    if ("string" === typeof value) {
+      if ("Z" === value[value.length - 1] && this[key] instanceof Date)
+        return "$D" + value;
+      key = "$" === value[0] ? "$" + value : value;
+      return key;
+    }
+    if ("boolean" === typeof value) return value;
+    if ("number" === typeof value) return serializeNumber(value);
+    if ("undefined" === typeof value) return "$undefined";
+    if ("function" === typeof value) {
+      parentReference = knownServerReferences.get(value);
+      if (void 0 !== parentReference)
+        return (
+          (key = JSON.stringify(parentReference, resolveToJSON)),
+          null === formData && (formData = new FormData()),
+          (parentReference = nextPartId++),
+          formData.set(formFieldPrefix + parentReference, key),
+          "$F" + parentReference.toString(16)
+        );
+      if (
+        void 0 !== temporaryReferences &&
+        -1 === key.indexOf(":") &&
+        ((parentReference = writtenObjects.get(this)),
+        void 0 !== parentReference)
+      )
+        return (
+          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+        );
+      throw Error(
+        "Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again."
+      );
+    }
+    if ("symbol" === typeof value) {
+      if (
+        void 0 !== temporaryReferences &&
+        -1 === key.indexOf(":") &&
+        ((parentReference = writtenObjects.get(this)),
+        void 0 !== parentReference)
+      )
+        return (
+          temporaryReferences.set(parentReference + ":" + key, value), "$T"
+        );
+      throw Error(
+        "Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options."
+      );
+    }
+    if ("bigint" === typeof value) return "$n" + value.toString(10);
+    throw Error(
+      "Type " +
+        typeof value +
+        " is not supported as an argument to a Server Function."
+    );
+  }
+  function serializeModel(model, id) {
+    "object" === typeof model &&
+      null !== model &&
+      ((id = "$" + id.toString(16)),
+      writtenObjects.set(model, id),
+      void 0 !== temporaryReferences && temporaryReferences.set(id, model));
+    modelRoot = model;
+    return JSON.stringify(model, resolveToJSON);
+  }
+  var nextPartId = 1,
+    pendingParts = 0,
+    formData = null,
+    writtenObjects = new WeakMap(),
+    modelRoot = root,
+    json = serializeModel(root, 0);
+  null === formData
+    ? resolve(json)
+    : (formData.set(formFieldPrefix + "0", json),
+      0 === pendingParts && resolve(formData));
+  return function () {
+    0 < pendingParts &&
+      ((pendingParts = 0),
+      null === formData ? resolve(json) : resolve(formData));
+  };
+}
+var boundCache = new WeakMap();
+function encodeFormData(reference) {
+  var resolve,
+    reject,
+    thenable = new Promise(function (res, rej) {
+      resolve = res;
+      reject = rej;
+    });
+  processReply(
+    reference,
+    "",
+    void 0,
+    function (body) {
+      if ("string" === typeof body) {
+        var data = new FormData();
+        data.append("0", body);
+        body = data;
+      }
+      thenable.status = "fulfilled";
+      thenable.value = body;
+      resolve(body);
+    },
+    function (e) {
+      thenable.status = "rejected";
+      thenable.reason = e;
+      reject(e);
+    }
+  );
+  return thenable;
+}
+function defaultEncodeFormAction(identifierPrefix) {
+  var reference = knownServerReferences.get(this);
+  if (!reference)
+    throw Error(
+      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+    );
+  var data = null;
+  if (null !== reference.bound) {
+    data = boundCache.get(reference);
+    data ||
+      ((data = encodeFormData(reference)), boundCache.set(reference, data));
+    if ("rejected" === data.status) throw data.reason;
+    if ("fulfilled" !== data.status) throw data;
+    reference = data.value;
+    var prefixedData = new FormData();
+    reference.forEach(function (value, key) {
+      prefixedData.append("$ACTION_" + identifierPrefix + ":" + key, value);
+    });
+    data = prefixedData;
+    reference = "$ACTION_REF_" + identifierPrefix;
+  } else reference = "$ACTION_ID_" + reference.id;
+  return {
+    name: reference,
+    method: "POST",
+    encType: "multipart/form-data",
+    data: data
+  };
+}
+function isSignatureEqual(referenceId, numberOfBoundArgs) {
+  var reference = knownServerReferences.get(this);
+  if (!reference)
+    throw Error(
+      "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+    );
+  if (reference.id !== referenceId) return !1;
+  var boundPromise = reference.bound;
+  if (null === boundPromise) return 0 === numberOfBoundArgs;
+  switch (boundPromise.status) {
+    case "fulfilled":
+      return boundPromise.value.length === numberOfBoundArgs;
+    case "pending":
+      throw boundPromise;
+    case "rejected":
+      throw boundPromise.reason;
+    default:
+      throw (
+        ("string" !== typeof boundPromise.status &&
+          ((boundPromise.status = "pending"),
+          boundPromise.then(
+            function (boundArgs) {
+              boundPromise.status = "fulfilled";
+              boundPromise.value = boundArgs;
+            },
+            function (error) {
+              boundPromise.status = "rejected";
+              boundPromise.reason = error;
+            }
+          )),
+        boundPromise)
+      );
+  }
+}
+function registerServerReference(proxy, reference$jscomp$0, encodeFormAction) {
+  Object.defineProperties(proxy, {
+    $$FORM_ACTION: {
+      value:
+        void 0 === encodeFormAction
+          ? defaultEncodeFormAction
+          : function () {
+              var reference = knownServerReferences.get(this);
+              if (!reference)
+                throw Error(
+                  "Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React."
+                );
+              var boundPromise = reference.bound;
+              null === boundPromise && (boundPromise = Promise.resolve([]));
+              return encodeFormAction(reference.id, boundPromise);
+            }
+    },
+    $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
+    bind: { value: bind }
+  });
+  knownServerReferences.set(proxy, reference$jscomp$0);
+}
+var FunctionBind = Function.prototype.bind,
+  ArraySlice = Array.prototype.slice;
+function bind() {
+  var newFn = FunctionBind.apply(this, arguments),
+    reference = knownServerReferences.get(this);
+  if (reference) {
+    var args = ArraySlice.call(arguments, 1),
+      boundPromise = null;
+    boundPromise =
+      null !== reference.bound
+        ? Promise.resolve(reference.bound).then(function (boundArgs) {
+            return boundArgs.concat(args);
+          })
+        : Promise.resolve(args);
+    Object.defineProperties(newFn, {
+      $$FORM_ACTION: { value: this.$$FORM_ACTION },
+      $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },
+      bind: { value: bind }
+    });
+    knownServerReferences.set(newFn, { id: reference.id, bound: boundPromise });
+  }
+  return newFn;
+}
+function createBoundServerReference(metaData, callServer, encodeFormAction) {
+  function action() {
+    var args = Array.prototype.slice.call(arguments);
+    return bound
+      ? "fulfilled" === bound.status
+        ? callServer(id, bound.value.concat(args))
+        : Promise.resolve(bound).then(function (boundArgs) {
+            return callServer(id, boundArgs.concat(args));
+          })
+      : callServer(id, args);
+  }
+  var id = metaData.id,
+    bound = metaData.bound;
+  registerServerReference(action, { id: id, bound: bound }, encodeFormAction);
+  return action;
+}
+function createServerReference$1(id, callServer, encodeFormAction) {
+  function action() {
+    var args = Array.prototype.slice.call(arguments);
+    return callServer(id, args);
+  }
+  registerServerReference(action, { id: id, bound: null }, encodeFormAction);
+  return action;
+}
+function ReactPromise(status, value, reason, response) {
+  this.status = status;
+  this.value = value;
+  this.reason = reason;
+  this._response = response;
+}
+ReactPromise.prototype = Object.create(Promise.prototype);
+ReactPromise.prototype.then = function (resolve, reject) {
+  switch (this.status) {
+    case "resolved_model":
+      initializeModelChunk(this);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(this);
+  }
+  switch (this.status) {
+    case "fulfilled":
+      resolve(this.value);
+      break;
+    case "pending":
+    case "blocked":
+      resolve &&
+        (null === this.value && (this.value = []), this.value.push(resolve));
+      reject &&
+        (null === this.reason && (this.reason = []), this.reason.push(reject));
+      break;
+    default:
+      reject && reject(this.reason);
+  }
+};
+function readChunk(chunk) {
+  switch (chunk.status) {
+    case "resolved_model":
+      initializeModelChunk(chunk);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(chunk);
+  }
+  switch (chunk.status) {
+    case "fulfilled":
+      return chunk.value;
+    case "pending":
+    case "blocked":
+      throw chunk;
+    default:
+      throw chunk.reason;
+  }
+}
+function createPendingChunk(response) {
+  return new ReactPromise("pending", null, null, response);
+}
+function createErrorChunk(response, error) {
+  return new ReactPromise("rejected", null, error, response);
+}
+function wakeChunk(listeners, value) {
+  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+}
+function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+  switch (chunk.status) {
+    case "fulfilled":
+      wakeChunk(resolveListeners, chunk.value);
+      break;
+    case "pending":
+    case "blocked":
+      if (chunk.value)
+        for (var i = 0; i < resolveListeners.length; i++)
+          chunk.value.push(resolveListeners[i]);
+      else chunk.value = resolveListeners;
+      if (chunk.reason) {
+        if (rejectListeners)
+          for (
+            resolveListeners = 0;
+            resolveListeners < rejectListeners.length;
+            resolveListeners++
+          )
+            chunk.reason.push(rejectListeners[resolveListeners]);
+      } else chunk.reason = rejectListeners;
+      break;
+    case "rejected":
+      rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+  }
+}
+function triggerErrorOnChunk(chunk, error) {
+  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+    chunk.reason.error(error);
+  else {
+    var listeners = chunk.reason;
+    chunk.status = "rejected";
+    chunk.reason = error;
+    null !== listeners && wakeChunk(listeners, error);
+  }
+}
+function createResolvedIteratorResultChunk(response, value, done) {
+  return new ReactPromise(
+    "resolved_model",
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    null,
+    response
+  );
+}
+function resolveIteratorResultChunk(chunk, value, done) {
+  resolveModelChunk(
+    chunk,
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}"
+  );
+}
+function resolveModelChunk(chunk, value) {
+  if ("pending" !== chunk.status) chunk.reason.enqueueModel(value);
+  else {
+    var resolveListeners = chunk.value,
+      rejectListeners = chunk.reason;
+    chunk.status = "resolved_model";
+    chunk.value = value;
+    null !== resolveListeners &&
+      (initializeModelChunk(chunk),
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+  }
+}
+function resolveModuleChunk(chunk, value) {
+  if ("pending" === chunk.status || "blocked" === chunk.status) {
+    var resolveListeners = chunk.value,
+      rejectListeners = chunk.reason;
+    chunk.status = "resolved_module";
+    chunk.value = value;
+    null !== resolveListeners &&
+      (initializeModuleChunk(chunk),
+      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));
+  }
+}
+var initializingHandler = null;
+function initializeModelChunk(chunk) {
+  var prevHandler = initializingHandler;
+  initializingHandler = null;
+  var resolvedModel = chunk.value;
+  chunk.status = "blocked";
+  chunk.value = null;
+  chunk.reason = null;
+  try {
+    var value = JSON.parse(resolvedModel, chunk._response._fromJSON),
+      resolveListeners = chunk.value;
+    null !== resolveListeners &&
+      ((chunk.value = null),
+      (chunk.reason = null),
+      wakeChunk(resolveListeners, value));
+    if (null !== initializingHandler) {
+      if (initializingHandler.errored) throw initializingHandler.value;
+      if (0 < initializingHandler.deps) {
+        initializingHandler.value = value;
+        initializingHandler.chunk = chunk;
+        return;
+      }
+    }
+    chunk.status = "fulfilled";
+    chunk.value = value;
+  } catch (error) {
+    (chunk.status = "rejected"), (chunk.reason = error);
+  } finally {
+    initializingHandler = prevHandler;
+  }
+}
+function initializeModuleChunk(chunk) {
+  try {
+    var value = requireModule(chunk.value);
+    chunk.status = "fulfilled";
+    chunk.value = value;
+  } catch (error) {
+    (chunk.status = "rejected"), (chunk.reason = error);
+  }
+}
+function reportGlobalError(response, error) {
+  response._closed = !0;
+  response._closedReason = error;
+  response._chunks.forEach(function (chunk) {
+    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+  });
+}
+function createLazyChunkWrapper(chunk) {
+  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };
+}
+function getChunk(response, id) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk ||
+    ((chunk = response._closed
+      ? createErrorChunk(response, response._closedReason)
+      : createPendingChunk(response)),
+    chunks.set(id, chunk));
+  return chunk;
+}
+function waitForReference(
+  referencedChunk,
+  parentObject,
+  key,
+  response,
+  map,
+  path
+) {
+  function fulfill(value) {
+    for (var i = 1; i < path.length; i++) {
+      for (; value.$$typeof === REACT_LAZY_TYPE; )
+        if (((value = value._payload), value === handler.chunk))
+          value = handler.value;
+        else if ("fulfilled" === value.status) value = value.value;
+        else {
+          path.splice(0, i - 1);
+          value.then(fulfill, reject);
+          return;
+        }
+      value = value[path[i]];
+    }
+    i = map(response, value, parentObject, key);
+    parentObject[key] = i;
+    "" === key && null === handler.value && (handler.value = i);
+    if (
+      parentObject[0] === REACT_ELEMENT_TYPE &&
+      "object" === typeof handler.value &&
+      null !== handler.value &&
+      handler.value.$$typeof === REACT_ELEMENT_TYPE
+    )
+      switch (((value = handler.value), key)) {
+        case "3":
+          value.props = i;
+      }
+    handler.deps--;
+    0 === handler.deps &&
+      ((i = handler.chunk),
+      null !== i &&
+        "blocked" === i.status &&
+        ((value = i.value),
+        (i.status = "fulfilled"),
+        (i.value = handler.value),
+        null !== value && wakeChunk(value, handler.value)));
+  }
+  function reject(error) {
+    if (!handler.errored) {
+      handler.errored = !0;
+      handler.value = error;
+      var chunk = handler.chunk;
+      null !== chunk &&
+        "blocked" === chunk.status &&
+        triggerErrorOnChunk(chunk, error);
+    }
+  }
+  if (initializingHandler) {
+    var handler = initializingHandler;
+    handler.deps++;
+  } else
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: !1
+    };
+  referencedChunk.then(fulfill, reject);
+  return null;
+}
+function loadServerReference(response, metaData, parentObject, key) {
+  if (!response._serverReferenceConfig)
+    return createBoundServerReference(
+      metaData,
+      response._callServer,
+      response._encodeFormAction
+    );
+  var serverReference = resolveServerReference(
+    response._serverReferenceConfig,
+    metaData.id
+  );
+  if ((response = preloadModule(serverReference)))
+    metaData.bound && (response = Promise.all([response, metaData.bound]));
+  else if (metaData.bound) response = Promise.resolve(metaData.bound);
+  else return requireModule(serverReference);
+  if (initializingHandler) {
+    var handler = initializingHandler;
+    handler.deps++;
+  } else
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: !1
+    };
+  response.then(
+    function () {
+      var resolvedValue = requireModule(serverReference);
+      if (metaData.bound) {
+        var boundArgs = metaData.bound.value.slice(0);
+        boundArgs.unshift(null);
+        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+      }
+      parentObject[key] = resolvedValue;
+      "" === key && null === handler.value && (handler.value = resolvedValue);
+      if (
+        parentObject[0] === REACT_ELEMENT_TYPE &&
+        "object" === typeof handler.value &&
+        null !== handler.value &&
+        handler.value.$$typeof === REACT_ELEMENT_TYPE
+      )
+        switch (((boundArgs = handler.value), key)) {
+          case "3":
+            boundArgs.props = resolvedValue;
+        }
+      handler.deps--;
+      0 === handler.deps &&
+        ((resolvedValue = handler.chunk),
+        null !== resolvedValue &&
+          "blocked" === resolvedValue.status &&
+          ((boundArgs = resolvedValue.value),
+          (resolvedValue.status = "fulfilled"),
+          (resolvedValue.value = handler.value),
+          null !== boundArgs && wakeChunk(boundArgs, handler.value)));
+    },
+    function (error) {
+      if (!handler.errored) {
+        handler.errored = !0;
+        handler.value = error;
+        var chunk = handler.chunk;
+        null !== chunk &&
+          "blocked" === chunk.status &&
+          triggerErrorOnChunk(chunk, error);
+      }
+    }
+  );
+  return null;
+}
+function getOutlinedModel(response, reference, parentObject, key, map) {
+  reference = reference.split(":");
+  var id = parseInt(reference[0], 16);
+  id = getChunk(response, id);
+  switch (id.status) {
+    case "resolved_model":
+      initializeModelChunk(id);
+      break;
+    case "resolved_module":
+      initializeModuleChunk(id);
+  }
+  switch (id.status) {
+    case "fulfilled":
+      var value = id.value;
+      for (id = 1; id < reference.length; id++) {
+        for (; value.$$typeof === REACT_LAZY_TYPE; )
+          if (((value = value._payload), "fulfilled" === value.status))
+            value = value.value;
+          else
+            return waitForReference(
+              value,
+              parentObject,
+              key,
+              response,
+              map,
+              reference.slice(id - 1)
+            );
+        value = value[reference[id]];
+      }
+      return map(response, value, parentObject, key);
+    case "pending":
+    case "blocked":
+      return waitForReference(id, parentObject, key, response, map, reference);
+    default:
+      return (
+        initializingHandler
+          ? ((initializingHandler.errored = !0),
+            (initializingHandler.value = id.reason))
+          : (initializingHandler = {
+              parent: null,
+              chunk: null,
+              value: id.reason,
+              deps: 0,
+              errored: !0
+            }),
+        null
+      );
+  }
+}
+function createMap(response, model) {
+  return new Map(model);
+}
+function createSet(response, model) {
+  return new Set(model);
+}
+function createBlob(response, model) {
+  return new Blob(model.slice(1), { type: model[0] });
+}
+function createFormData(response, model) {
+  response = new FormData();
+  for (var i = 0; i < model.length; i++)
+    response.append(model[i][0], model[i][1]);
+  return response;
+}
+function extractIterator(response, model) {
+  return model[Symbol.iterator]();
+}
+function createModel(response, model) {
+  return model;
+}
+function parseModelString(response, parentObject, key, value) {
+  if ("$" === value[0]) {
+    if ("$" === value)
+      return (
+        null !== initializingHandler &&
+          "0" === key &&
+          (initializingHandler = {
+            parent: initializingHandler,
+            chunk: null,
+            value: null,
+            deps: 0,
+            errored: !1
+          }),
+        REACT_ELEMENT_TYPE
+      );
+    switch (value[1]) {
+      case "$":
+        return value.slice(1);
+      case "L":
+        return (
+          (parentObject = parseInt(value.slice(2), 16)),
+          (response = getChunk(response, parentObject)),
+          createLazyChunkWrapper(response)
+        );
+      case "@":
+        if (2 === value.length) return new Promise(function () {});
+        parentObject = parseInt(value.slice(2), 16);
+        return getChunk(response, parentObject);
+      case "S":
+        return Symbol.for(value.slice(2));
+      case "F":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(
+            response,
+            value,
+            parentObject,
+            key,
+            loadServerReference
+          )
+        );
+      case "T":
+        parentObject = "$" + value.slice(2);
+        response = response._tempRefs;
+        if (null == response)
+          throw Error(
+            "Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply."
+          );
+        return response.get(parentObject);
+      case "Q":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createMap)
+        );
+      case "W":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createSet)
+        );
+      case "B":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createBlob)
+        );
+      case "K":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, createFormData)
+        );
+      case "Z":
+        return resolveErrorProd();
+      case "i":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, parentObject, key, extractIterator)
+        );
+      case "I":
+        return Infinity;
+      case "-":
+        return "$-0" === value ? -0 : -Infinity;
+      case "N":
+        return NaN;
+      case "u":
+        return;
+      case "D":
+        return new Date(Date.parse(value.slice(2)));
+      case "n":
+        return BigInt(value.slice(2));
+      default:
+        return (
+          (value = value.slice(1)),
+          getOutlinedModel(response, value, parentObject, key, createModel)
+        );
+    }
+  }
+  return value;
+}
+function missingCall() {
+  throw Error(
+    'Trying to call a function from "use server" but the callServer option was not implemented in your router runtime.'
+  );
+}
+function ResponseInstance(
+  bundlerConfig,
+  serverReferenceConfig,
+  moduleLoading,
+  callServer,
+  encodeFormAction,
+  nonce,
+  temporaryReferences
+) {
+  var chunks = new Map();
+  this._bundlerConfig = bundlerConfig;
+  this._serverReferenceConfig = serverReferenceConfig;
+  this._moduleLoading = moduleLoading;
+  this._callServer = void 0 !== callServer ? callServer : missingCall;
+  this._encodeFormAction = encodeFormAction;
+  this._nonce = nonce;
+  this._chunks = chunks;
+  this._stringDecoder = new util.TextDecoder();
+  this._fromJSON = null;
+  this._rowLength = this._rowTag = this._rowID = this._rowState = 0;
+  this._buffer = [];
+  this._closed = !1;
+  this._closedReason = null;
+  this._tempRefs = temporaryReferences;
+  this._fromJSON = createFromJSONCallback(this);
+}
+function resolveBuffer(response, id, buffer) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk && "pending" !== chunk.status
+    ? chunk.reason.enqueueValue(buffer)
+    : chunks.set(id, new ReactPromise("fulfilled", buffer, null, response));
+}
+function resolveModule(response, id, model) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  model = JSON.parse(model, response._fromJSON);
+  var clientReference = {
+    specifier: response._bundlerConfig + model[0],
+    name: model[1]
+  };
+  prepareDestinationForModuleImpl(
+    response._moduleLoading,
+    model[0],
+    response._nonce
+  );
+  if ((model = preloadModule(clientReference))) {
+    if (chunk) {
+      var blockedChunk = chunk;
+      blockedChunk.status = "blocked";
+    } else
+      (blockedChunk = new ReactPromise("blocked", null, null, response)),
+        chunks.set(id, blockedChunk);
+    model.then(
+      function () {
+        return resolveModuleChunk(blockedChunk, clientReference);
+      },
+      function (error) {
+        return triggerErrorOnChunk(blockedChunk, error);
+      }
+    );
+  } else
+    chunk
+      ? resolveModuleChunk(chunk, clientReference)
+      : chunks.set(
+          id,
+          new ReactPromise("resolved_module", clientReference, null, response)
+        );
+}
+function resolveStream(response, id, stream, controller) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk
+    ? "pending" === chunk.status &&
+      ((response = chunk.value),
+      (chunk.status = "fulfilled"),
+      (chunk.value = stream),
+      (chunk.reason = controller),
+      null !== response && wakeChunk(response, chunk.value))
+    : chunks.set(
+        id,
+        new ReactPromise("fulfilled", stream, controller, response)
+      );
+}
+function startReadableStream(response, id, type) {
+  var controller = null;
+  type = new ReadableStream({
+    type: type,
+    start: function (c) {
+      controller = c;
+    }
+  });
+  var previousBlockedChunk = null;
+  resolveStream(response, id, type, {
+    enqueueValue: function (value) {
+      null === previousBlockedChunk
+        ? controller.enqueue(value)
+        : previousBlockedChunk.then(function () {
+            controller.enqueue(value);
+          });
+    },
+    enqueueModel: function (json) {
+      if (null === previousBlockedChunk) {
+        var chunk = new ReactPromise("resolved_model", json, null, response);
+        initializeModelChunk(chunk);
+        "fulfilled" === chunk.status
+          ? controller.enqueue(chunk.value)
+          : (chunk.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            ),
+            (previousBlockedChunk = chunk));
+      } else {
+        chunk = previousBlockedChunk;
+        var chunk$52 = createPendingChunk(response);
+        chunk$52.then(
+          function (v) {
+            return controller.enqueue(v);
+          },
+          function (e) {
+            return controller.error(e);
+          }
+        );
+        previousBlockedChunk = chunk$52;
+        chunk.then(function () {
+          previousBlockedChunk === chunk$52 && (previousBlockedChunk = null);
+          resolveModelChunk(chunk$52, json);
+        });
+      }
+    },
+    close: function () {
+      if (null === previousBlockedChunk) controller.close();
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.close();
+        });
+      }
+    },
+    error: function (error) {
+      if (null === previousBlockedChunk) controller.error(error);
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.error(error);
+        });
+      }
+    }
+  });
+}
+function asyncIterator() {
+  return this;
+}
+function createIterator(next) {
+  next = { next: next };
+  next[ASYNC_ITERATOR] = asyncIterator;
+  return next;
+}
+function startAsyncIterable(response, id, iterator) {
+  var buffer = [],
+    closed = !1,
+    nextWriteIndex = 0,
+    $jscomp$compprop0 = {};
+  $jscomp$compprop0 =
+    (($jscomp$compprop0[ASYNC_ITERATOR] = function () {
+      var nextReadIndex = 0;
+      return createIterator(function (arg) {
+        if (void 0 !== arg)
+          throw Error(
+            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          );
+        if (nextReadIndex === buffer.length) {
+          if (closed)
+            return new ReactPromise(
+              "fulfilled",
+              { done: !0, value: void 0 },
+              null,
+              response
+            );
+          buffer[nextReadIndex] = createPendingChunk(response);
+        }
+        return buffer[nextReadIndex++];
+      });
+    }),
+    $jscomp$compprop0);
+  resolveStream(
+    response,
+    id,
+    iterator ? $jscomp$compprop0[ASYNC_ITERATOR]() : $jscomp$compprop0,
+    {
+      enqueueValue: function (value) {
+        if (nextWriteIndex === buffer.length)
+          buffer[nextWriteIndex] = new ReactPromise(
+            "fulfilled",
+            { done: !1, value: value },
+            null,
+            response
+          );
+        else {
+          var chunk = buffer[nextWriteIndex],
+            resolveListeners = chunk.value,
+            rejectListeners = chunk.reason;
+          chunk.status = "fulfilled";
+          chunk.value = { done: !1, value: value };
+          null !== resolveListeners &&
+            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+        }
+        nextWriteIndex++;
+      },
+      enqueueModel: function (value) {
+        nextWriteIndex === buffer.length
+          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+              response,
+              value,
+              !1
+            ))
+          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+        nextWriteIndex++;
+      },
+      close: function (value) {
+        closed = !0;
+        nextWriteIndex === buffer.length
+          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+              response,
+              value,
+              !0
+            ))
+          : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+        for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+          resolveIteratorResultChunk(
+            buffer[nextWriteIndex++],
+            '"$undefined"',
+            !0
+          );
+      },
+      error: function (error) {
+        closed = !0;
+        for (
+          nextWriteIndex === buffer.length &&
+          (buffer[nextWriteIndex] = createPendingChunk(response));
+          nextWriteIndex < buffer.length;
+
+        )
+          triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+      }
+    }
+  );
+}
+function resolveErrorProd() {
+  var error = Error(
+    "An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error."
+  );
+  error.stack = "Error: " + error.message;
+  return error;
+}
+function mergeBuffer(buffer, lastChunk) {
+  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)
+    byteLength += buffer[i].byteLength;
+  byteLength = new Uint8Array(byteLength);
+  for (var i$53 = (i = 0); i$53 < l; i$53++) {
+    var chunk = buffer[i$53];
+    byteLength.set(chunk, i);
+    i += chunk.byteLength;
+  }
+  byteLength.set(lastChunk, i);
+  return byteLength;
+}
+function resolveTypedArray(
+  response,
+  id,
+  buffer,
+  lastChunk,
+  constructor,
+  bytesPerElement
+) {
+  buffer =
+    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement
+      ? lastChunk
+      : mergeBuffer(buffer, lastChunk);
+  constructor = new constructor(
+    buffer.buffer,
+    buffer.byteOffset,
+    buffer.byteLength / bytesPerElement
+  );
+  resolveBuffer(response, id, constructor);
+}
+function processFullBinaryRow(response, id, tag, buffer, chunk) {
+  switch (tag) {
+    case 65:
+      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+      return;
+    case 79:
+      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+      return;
+    case 111:
+      resolveBuffer(
+        response,
+        id,
+        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)
+      );
+      return;
+    case 85:
+      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+      return;
+    case 83:
+      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+      return;
+    case 115:
+      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+      return;
+    case 76:
+      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+      return;
+    case 108:
+      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+      return;
+    case 71:
+      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+      return;
+    case 103:
+      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+      return;
+    case 77:
+      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+      return;
+    case 109:
+      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+      return;
+    case 86:
+      resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+      return;
+  }
+  for (
+    var stringDecoder = response._stringDecoder, row = "", i = 0;
+    i < buffer.length;
+    i++
+  )
+    row += stringDecoder.decode(buffer[i], decoderOptions);
+  buffer = row += stringDecoder.decode(chunk);
+  switch (tag) {
+    case 73:
+      resolveModule(response, id, buffer);
+      break;
+    case 72:
+      id = buffer[0];
+      buffer = buffer.slice(1);
+      response = JSON.parse(buffer, response._fromJSON);
+      buffer = ReactDOMSharedInternals.d;
+      switch (id) {
+        case "D":
+          buffer.D(response);
+          break;
+        case "C":
+          "string" === typeof response
+            ? buffer.C(response)
+            : buffer.C(response[0], response[1]);
+          break;
+        case "L":
+          id = response[0];
+          tag = response[1];
+          3 === response.length
+            ? buffer.L(id, tag, response[2])
+            : buffer.L(id, tag);
+          break;
+        case "m":
+          "string" === typeof response
+            ? buffer.m(response)
+            : buffer.m(response[0], response[1]);
+          break;
+        case "X":
+          "string" === typeof response
+            ? buffer.X(response)
+            : buffer.X(response[0], response[1]);
+          break;
+        case "S":
+          "string" === typeof response
+            ? buffer.S(response)
+            : buffer.S(
+                response[0],
+                0 === response[1] ? void 0 : response[1],
+                3 === response.length ? response[2] : void 0
+              );
+          break;
+        case "M":
+          "string" === typeof response
+            ? buffer.M(response)
+            : buffer.M(response[0], response[1]);
+      }
+      break;
+    case 69:
+      tag = JSON.parse(buffer);
+      buffer = resolveErrorProd();
+      buffer.digest = tag.digest;
+      tag = response._chunks;
+      (chunk = tag.get(id))
+        ? triggerErrorOnChunk(chunk, buffer)
+        : tag.set(id, createErrorChunk(response, buffer));
+      break;
+    case 84:
+      tag = response._chunks;
+      (chunk = tag.get(id)) && "pending" !== chunk.status
+        ? chunk.reason.enqueueValue(buffer)
+        : tag.set(id, new ReactPromise("fulfilled", buffer, null, response));
+      break;
+    case 78:
+    case 68:
+    case 87:
+      throw Error(
+        "Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client."
+      );
+    case 82:
+      startReadableStream(response, id, void 0);
+      break;
+    case 114:
+      startReadableStream(response, id, "bytes");
+      break;
+    case 88:
+      startAsyncIterable(response, id, !1);
+      break;
+    case 120:
+      startAsyncIterable(response, id, !0);
+      break;
+    case 67:
+      (response = response._chunks.get(id)) &&
+        "fulfilled" === response.status &&
+        response.reason.close("" === buffer ? '"$undefined"' : buffer);
+      break;
+    case 80:
+      buffer = Error(
+        "A Server Component was postponed. The reason is omitted in production builds to avoid leaking sensitive details."
+      );
+      buffer.$$typeof = REACT_POSTPONE_TYPE;
+      buffer.stack = "Error: " + buffer.message;
+      tag = response._chunks;
+      (chunk = tag.get(id))
+        ? triggerErrorOnChunk(chunk, buffer)
+        : tag.set(id, createErrorChunk(response, buffer));
+      break;
+    default:
+      (tag = response._chunks),
+        (chunk = tag.get(id))
+          ? resolveModelChunk(chunk, buffer)
+          : tag.set(
+              id,
+              new ReactPromise("resolved_model", buffer, null, response)
+            );
+  }
+}
+function createFromJSONCallback(response) {
+  return function (key, value) {
+    if ("string" === typeof value)
+      return parseModelString(response, this, key, value);
+    if ("object" === typeof value && null !== value) {
+      if (value[0] === REACT_ELEMENT_TYPE) {
+        if (
+          ((key = {
+            $$typeof: REACT_ELEMENT_TYPE,
+            type: value[1],
+            key: value[2],
+            ref: null,
+            props: value[3]
+          }),
+          null !== initializingHandler)
+        )
+          if (
+            ((value = initializingHandler),
+            (initializingHandler = value.parent),
+            value.errored)
+          )
+            (key = createErrorChunk(response, value.value)),
+              (key = createLazyChunkWrapper(key));
+          else if (0 < value.deps) {
+            var blockedChunk = new ReactPromise(
+              "blocked",
+              null,
+              null,
+              response
+            );
+            value.value = key;
+            value.chunk = blockedChunk;
+            key = createLazyChunkWrapper(blockedChunk);
+          }
+      } else key = value;
+      return key;
+    }
+    return value;
+  };
+}
+function noServerCall() {
+  throw Error(
+    "Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead."
+  );
+}
+exports.createFromNodeStream = function (
+  stream,
+  moduleRootPath,
+  moduleBaseURL,
+  options
+) {
+  var response = new ResponseInstance(
+    moduleRootPath,
+    null,
+    moduleBaseURL,
+    noServerCall,
+    options ? options.encodeFormAction : void 0,
+    options && "string" === typeof options.nonce ? options.nonce : void 0,
+    void 0
+  );
+  stream.on("data", function (chunk) {
+    for (
+      var i = 0,
+        rowState = response._rowState,
+        rowID = response._rowID,
+        rowTag = response._rowTag,
+        rowLength = response._rowLength,
+        buffer = response._buffer,
+        chunkLength = chunk.length;
+      i < chunkLength;
+
+    ) {
+      var lastIdx = -1;
+      switch (rowState) {
+        case 0:
+          lastIdx = chunk[i++];
+          58 === lastIdx
+            ? (rowState = 1)
+            : (rowID =
+                (rowID << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+          continue;
+        case 1:
+          rowState = chunk[i];
+          84 === rowState ||
+          65 === rowState ||
+          79 === rowState ||
+          111 === rowState ||
+          85 === rowState ||
+          83 === rowState ||
+          115 === rowState ||
+          76 === rowState ||
+          108 === rowState ||
+          71 === rowState ||
+          103 === rowState ||
+          77 === rowState ||
+          109 === rowState ||
+          86 === rowState
+            ? ((rowTag = rowState), (rowState = 2), i++)
+            : (64 < rowState && 91 > rowState) ||
+                35 === rowState ||
+                114 === rowState ||
+                120 === rowState
+              ? ((rowTag = rowState), (rowState = 3), i++)
+              : ((rowTag = 0), (rowState = 3));
+          continue;
+        case 2:
+          lastIdx = chunk[i++];
+          44 === lastIdx
+            ? (rowState = 4)
+            : (rowLength =
+                (rowLength << 4) |
+                (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));
+          continue;
+        case 3:
+          lastIdx = chunk.indexOf(10, i);
+          break;
+        case 4:
+          (lastIdx = i + rowLength), lastIdx > chunk.length && (lastIdx = -1);
+      }
+      var offset = chunk.byteOffset + i;
+      if (-1 < lastIdx)
+        (rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i)),
+          processFullBinaryRow(response, rowID, rowTag, buffer, rowLength),
+          (i = lastIdx),
+          3 === rowState && i++,
+          (rowLength = rowID = rowTag = rowState = 0),
+          (buffer.length = 0);
+      else {
+        chunk = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);
+        buffer.push(chunk);
+        rowLength -= chunk.byteLength;
+        break;
+      }
+    }
+    response._rowState = rowState;
+    response._rowID = rowID;
+    response._rowTag = rowTag;
+    response._rowLength = rowLength;
+  });
+  stream.on("error", function (error) {
+    reportGlobalError(response, error);
+  });
+  stream.on("end", function () {
+    reportGlobalError(response, Error("Connection closed."));
+  });
+  return getChunk(response, 0);
+};
+exports.createServerReference = function (id) {
+  return createServerReference$1(id, noServerCall);
+};
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.development.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.development.js
new file mode 100644
index 0000000..1ad3553
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.development.js
@@ -0,0 +1,4085 @@
+/**
+ * @license React
+ * react-server-dom-esm-server.node.development.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+"production" !== process.env.NODE_ENV &&
+  (function () {
+    function voidHandler() {}
+    function _defineProperty(obj, key, value) {
+      key in obj
+        ? Object.defineProperty(obj, key, {
+            value: value,
+            enumerable: !0,
+            configurable: !0,
+            writable: !0
+          })
+        : (obj[key] = value);
+      return obj;
+    }
+    function writeToDestination(destination, view) {
+      destination = destination.write(view);
+      destinationHasCapacity = destinationHasCapacity && destination;
+    }
+    function writeChunkAndReturn(destination, chunk) {
+      if ("string" === typeof chunk) {
+        if (0 !== chunk.length)
+          if (2048 < 3 * chunk.length)
+            0 < writtenBytes &&
+              (writeToDestination(
+                destination,
+                currentView.subarray(0, writtenBytes)
+              ),
+              (currentView = new Uint8Array(2048)),
+              (writtenBytes = 0)),
+              writeToDestination(destination, chunk);
+          else {
+            var target = currentView;
+            0 < writtenBytes && (target = currentView.subarray(writtenBytes));
+            target = textEncoder.encodeInto(chunk, target);
+            var read = target.read;
+            writtenBytes += target.written;
+            read < chunk.length &&
+              (writeToDestination(
+                destination,
+                currentView.subarray(0, writtenBytes)
+              ),
+              (currentView = new Uint8Array(2048)),
+              (writtenBytes = textEncoder.encodeInto(
+                chunk.slice(read),
+                currentView
+              ).written));
+            2048 === writtenBytes &&
+              (writeToDestination(destination, currentView),
+              (currentView = new Uint8Array(2048)),
+              (writtenBytes = 0));
+          }
+      } else
+        0 !== chunk.byteLength &&
+          (2048 < chunk.byteLength
+            ? (0 < writtenBytes &&
+                (writeToDestination(
+                  destination,
+                  currentView.subarray(0, writtenBytes)
+                ),
+                (currentView = new Uint8Array(2048)),
+                (writtenBytes = 0)),
+              writeToDestination(destination, chunk))
+            : ((target = currentView.length - writtenBytes),
+              target < chunk.byteLength &&
+                (0 === target
+                  ? writeToDestination(destination, currentView)
+                  : (currentView.set(chunk.subarray(0, target), writtenBytes),
+                    (writtenBytes += target),
+                    writeToDestination(destination, currentView),
+                    (chunk = chunk.subarray(target))),
+                (currentView = new Uint8Array(2048)),
+                (writtenBytes = 0)),
+              currentView.set(chunk, writtenBytes),
+              (writtenBytes += chunk.byteLength),
+              2048 === writtenBytes &&
+                (writeToDestination(destination, currentView),
+                (currentView = new Uint8Array(2048)),
+                (writtenBytes = 0))));
+      return destinationHasCapacity;
+    }
+    function byteLengthOfChunk(chunk) {
+      return "string" === typeof chunk
+        ? Buffer.byteLength(chunk, "utf8")
+        : chunk.byteLength;
+    }
+    function isClientReference(reference) {
+      return reference.$$typeof === CLIENT_REFERENCE_TAG$1;
+    }
+    function bind() {
+      var newFn = FunctionBind.apply(this, arguments);
+      if (this.$$typeof === SERVER_REFERENCE_TAG) {
+        null != arguments[0] &&
+          console.error(
+            'Cannot bind "this" of a Server Action. Pass null or undefined as the first argument to .bind().'
+          );
+        var args = ArraySlice.call(arguments, 1),
+          $$typeof = { value: SERVER_REFERENCE_TAG },
+          $$id = { value: this.$$id };
+        args = { value: this.$$bound ? this.$$bound.concat(args) : args };
+        return Object.defineProperties(newFn, {
+          $$typeof: $$typeof,
+          $$id: $$id,
+          $$bound: args,
+          $$location: { value: this.$$location, configurable: !0 },
+          bind: { value: bind, configurable: !0 }
+        });
+      }
+      return newFn;
+    }
+    function trimOptions(options) {
+      if (null == options) return null;
+      var hasProperties = !1,
+        trimmed = {},
+        key;
+      for (key in options)
+        null != options[key] &&
+          ((hasProperties = !0), (trimmed[key] = options[key]));
+      return hasProperties ? trimmed : null;
+    }
+    function prepareStackTrace(error, structuredStackTrace) {
+      error = (error.name || "Error") + ": " + (error.message || "");
+      for (var i = 0; i < structuredStackTrace.length; i++)
+        error += "\n    at " + structuredStackTrace[i].toString();
+      return error;
+    }
+    function parseStackTrace(error, skipFrames) {
+      a: {
+        var previousPrepare = Error.prepareStackTrace;
+        Error.prepareStackTrace = prepareStackTrace;
+        try {
+          var stack = String(error.stack);
+          break a;
+        } finally {
+          Error.prepareStackTrace = previousPrepare;
+        }
+        stack = void 0;
+      }
+      stack.startsWith("Error: react-stack-top-frame\n") &&
+        (stack = stack.slice(29));
+      error = stack.indexOf("react-stack-bottom-frame");
+      -1 !== error && (error = stack.lastIndexOf("\n", error));
+      -1 !== error && (stack = stack.slice(0, error));
+      stack = stack.split("\n");
+      for (error = []; skipFrames < stack.length; skipFrames++)
+        if ((previousPrepare = frameRegExp.exec(stack[skipFrames]))) {
+          var name = previousPrepare[1] || "";
+          "<anonymous>" === name && (name = "");
+          var filename = previousPrepare[2] || previousPrepare[5] || "";
+          "<anonymous>" === filename && (filename = "");
+          error.push([
+            name,
+            filename,
+            +(previousPrepare[3] || previousPrepare[6]),
+            +(previousPrepare[4] || previousPrepare[7])
+          ]);
+        }
+      return error;
+    }
+    function createTemporaryReference(temporaryReferences, id) {
+      var reference = Object.defineProperties(
+        function () {
+          throw Error(
+            "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+          );
+        },
+        { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+      );
+      reference = new Proxy(reference, proxyHandlers);
+      temporaryReferences.set(reference, id);
+      return reference;
+    }
+    function getIteratorFn(maybeIterable) {
+      if (null === maybeIterable || "object" !== typeof maybeIterable)
+        return null;
+      maybeIterable =
+        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+        maybeIterable["@@iterator"];
+      return "function" === typeof maybeIterable ? maybeIterable : null;
+    }
+    function noop$1() {}
+    function trackUsedThenable(thenableState, thenable, index) {
+      index = thenableState[index];
+      void 0 === index
+        ? thenableState.push(thenable)
+        : index !== thenable &&
+          (thenable.then(noop$1, noop$1), (thenable = index));
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw thenable.reason;
+        default:
+          "string" === typeof thenable.status
+            ? thenable.then(noop$1, noop$1)
+            : ((thenableState = thenable),
+              (thenableState.status = "pending"),
+              thenableState.then(
+                function (fulfilledValue) {
+                  if ("pending" === thenable.status) {
+                    var fulfilledThenable = thenable;
+                    fulfilledThenable.status = "fulfilled";
+                    fulfilledThenable.value = fulfilledValue;
+                  }
+                },
+                function (error) {
+                  if ("pending" === thenable.status) {
+                    var rejectedThenable = thenable;
+                    rejectedThenable.status = "rejected";
+                    rejectedThenable.reason = error;
+                  }
+                }
+              ));
+          switch (thenable.status) {
+            case "fulfilled":
+              return thenable.value;
+            case "rejected":
+              throw thenable.reason;
+          }
+          suspendedThenable = thenable;
+          throw SuspenseException;
+      }
+    }
+    function getSuspendedThenable() {
+      if (null === suspendedThenable)
+        throw Error(
+          "Expected a suspended thenable. This is a bug in React. Please file an issue."
+        );
+      var thenable = suspendedThenable;
+      suspendedThenable = null;
+      return thenable;
+    }
+    function getThenableStateAfterSuspending() {
+      var state = thenableState || [];
+      state._componentDebugInfo = currentComponentDebugInfo;
+      thenableState = currentComponentDebugInfo = null;
+      return state;
+    }
+    function unsupportedHook() {
+      throw Error("This Hook is not supported in Server Components.");
+    }
+    function unsupportedRefresh() {
+      throw Error(
+        "Refreshing the cache is not supported in Server Components."
+      );
+    }
+    function unsupportedContext() {
+      throw Error("Cannot read a Client Context from a Server Component.");
+    }
+    function resolveOwner() {
+      if (currentOwner) return currentOwner;
+      var owner = componentStorage.getStore();
+      return owner ? owner : null;
+    }
+    function isObjectPrototype(object) {
+      if (!object) return !1;
+      var ObjectPrototype = Object.prototype;
+      if (object === ObjectPrototype) return !0;
+      if (getPrototypeOf(object)) return !1;
+      object = Object.getOwnPropertyNames(object);
+      for (var i = 0; i < object.length; i++)
+        if (!(object[i] in ObjectPrototype)) return !1;
+      return !0;
+    }
+    function isSimpleObject(object) {
+      if (!isObjectPrototype(getPrototypeOf(object))) return !1;
+      for (
+        var names = Object.getOwnPropertyNames(object), i = 0;
+        i < names.length;
+        i++
+      ) {
+        var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+        if (
+          !descriptor ||
+          (!descriptor.enumerable &&
+            (("key" !== names[i] && "ref" !== names[i]) ||
+              "function" !== typeof descriptor.get))
+        )
+          return !1;
+      }
+      return !0;
+    }
+    function objectName(object) {
+      return Object.prototype.toString
+        .call(object)
+        .replace(/^\[object (.*)\]$/, function (m, p0) {
+          return p0;
+        });
+    }
+    function describeKeyForErrorMessage(key) {
+      var encodedKey = JSON.stringify(key);
+      return '"' + key + '"' === encodedKey ? key : encodedKey;
+    }
+    function describeValueForErrorMessage(value) {
+      switch (typeof value) {
+        case "string":
+          return JSON.stringify(
+            10 >= value.length ? value : value.slice(0, 10) + "..."
+          );
+        case "object":
+          if (isArrayImpl(value)) return "[...]";
+          if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
+            return "client";
+          value = objectName(value);
+          return "Object" === value ? "{...}" : value;
+        case "function":
+          return value.$$typeof === CLIENT_REFERENCE_TAG
+            ? "client"
+            : (value = value.displayName || value.name)
+              ? "function " + value
+              : "function";
+        default:
+          return String(value);
+      }
+    }
+    function describeElementType(type) {
+      if ("string" === typeof type) return type;
+      switch (type) {
+        case REACT_SUSPENSE_TYPE:
+          return "Suspense";
+        case REACT_SUSPENSE_LIST_TYPE:
+          return "SuspenseList";
+        case REACT_VIEW_TRANSITION_TYPE:
+          return "ViewTransition";
+      }
+      if ("object" === typeof type)
+        switch (type.$$typeof) {
+          case REACT_FORWARD_REF_TYPE:
+            return describeElementType(type.render);
+          case REACT_MEMO_TYPE:
+            return describeElementType(type.type);
+          case REACT_LAZY_TYPE:
+            var payload = type._payload;
+            type = type._init;
+            try {
+              return describeElementType(type(payload));
+            } catch (x) {}
+        }
+      return "";
+    }
+    function describeObjectForErrorMessage(objectOrArray, expandedName) {
+      var objKind = objectName(objectOrArray);
+      if ("Object" !== objKind && "Array" !== objKind) return objKind;
+      var start = -1,
+        length = 0;
+      if (isArrayImpl(objectOrArray))
+        if (jsxChildrenParents.has(objectOrArray)) {
+          var type = jsxChildrenParents.get(objectOrArray);
+          objKind = "<" + describeElementType(type) + ">";
+          for (var i = 0; i < objectOrArray.length; i++) {
+            var value = objectOrArray[i];
+            value =
+              "string" === typeof value
+                ? value
+                : "object" === typeof value && null !== value
+                  ? "{" + describeObjectForErrorMessage(value) + "}"
+                  : "{" + describeValueForErrorMessage(value) + "}";
+            "" + i === expandedName
+              ? ((start = objKind.length),
+                (length = value.length),
+                (objKind += value))
+              : (objKind =
+                  15 > value.length && 40 > objKind.length + value.length
+                    ? objKind + value
+                    : objKind + "{...}");
+          }
+          objKind += "</" + describeElementType(type) + ">";
+        } else {
+          objKind = "[";
+          for (type = 0; type < objectOrArray.length; type++)
+            0 < type && (objKind += ", "),
+              (i = objectOrArray[type]),
+              (i =
+                "object" === typeof i && null !== i
+                  ? describeObjectForErrorMessage(i)
+                  : describeValueForErrorMessage(i)),
+              "" + type === expandedName
+                ? ((start = objKind.length),
+                  (length = i.length),
+                  (objKind += i))
+                : (objKind =
+                    10 > i.length && 40 > objKind.length + i.length
+                      ? objKind + i
+                      : objKind + "...");
+          objKind += "]";
+        }
+      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
+        objKind = "<" + describeElementType(objectOrArray.type) + "/>";
+      else {
+        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+        if (jsxPropsParents.has(objectOrArray)) {
+          objKind = jsxPropsParents.get(objectOrArray);
+          objKind = "<" + (describeElementType(objKind) || "...");
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++) {
+            objKind += " ";
+            value = type[i];
+            objKind += describeKeyForErrorMessage(value) + "=";
+            var _value2 = objectOrArray[value];
+            var _substr2 =
+              value === expandedName &&
+              "object" === typeof _value2 &&
+              null !== _value2
+                ? describeObjectForErrorMessage(_value2)
+                : describeValueForErrorMessage(_value2);
+            "string" !== typeof _value2 && (_substr2 = "{" + _substr2 + "}");
+            value === expandedName
+              ? ((start = objKind.length),
+                (length = _substr2.length),
+                (objKind += _substr2))
+              : (objKind =
+                  10 > _substr2.length && 40 > objKind.length + _substr2.length
+                    ? objKind + _substr2
+                    : objKind + "...");
+          }
+          objKind += ">";
+        } else {
+          objKind = "{";
+          type = Object.keys(objectOrArray);
+          for (i = 0; i < type.length; i++)
+            0 < i && (objKind += ", "),
+              (value = type[i]),
+              (objKind += describeKeyForErrorMessage(value) + ": "),
+              (_value2 = objectOrArray[value]),
+              (_value2 =
+                "object" === typeof _value2 && null !== _value2
+                  ? describeObjectForErrorMessage(_value2)
+                  : describeValueForErrorMessage(_value2)),
+              value === expandedName
+                ? ((start = objKind.length),
+                  (length = _value2.length),
+                  (objKind += _value2))
+                : (objKind =
+                    10 > _value2.length && 40 > objKind.length + _value2.length
+                      ? objKind + _value2
+                      : objKind + "...");
+          objKind += "}";
+        }
+      }
+      return void 0 === expandedName
+        ? objKind
+        : -1 < start && 0 < length
+          ? ((objectOrArray = " ".repeat(start) + "^".repeat(length)),
+            "\n  " + objKind + "\n  " + objectOrArray)
+          : "\n  " + objKind;
+    }
+    function defaultFilterStackFrame(filename) {
+      return (
+        "" !== filename &&
+        !filename.startsWith("node:") &&
+        !filename.includes("node_modules")
+      );
+    }
+    function filterStackTrace(request, error, skipFrames) {
+      request = request.filterStackFrame;
+      error = parseStackTrace(error, skipFrames);
+      for (skipFrames = 0; skipFrames < error.length; skipFrames++) {
+        var callsite = error[skipFrames],
+          functionName = callsite[0],
+          url = callsite[1];
+        if (url.startsWith("rsc://React/")) {
+          var envIdx = url.indexOf("/", 12),
+            suffixIdx = url.lastIndexOf("?");
+          -1 < envIdx &&
+            -1 < suffixIdx &&
+            (url = callsite[1] = url.slice(envIdx + 1, suffixIdx));
+        }
+        request(url, functionName) ||
+          (error.splice(skipFrames, 1), skipFrames--);
+      }
+      return error;
+    }
+    function patchConsole(consoleInst, methodName) {
+      var descriptor = Object.getOwnPropertyDescriptor(consoleInst, methodName);
+      if (
+        descriptor &&
+        (descriptor.configurable || descriptor.writable) &&
+        "function" === typeof descriptor.value
+      ) {
+        var originalMethod = descriptor.value;
+        descriptor = Object.getOwnPropertyDescriptor(originalMethod, "name");
+        var wrapperMethod = function () {
+          var request = resolveRequest();
+          if (("assert" !== methodName || !arguments[0]) && null !== request) {
+            var stack = filterStackTrace(
+              request,
+              Error("react-stack-top-frame"),
+              1
+            );
+            request.pendingChunks++;
+            var owner = resolveOwner();
+            emitConsoleChunk(request, methodName, owner, stack, arguments);
+          }
+          return originalMethod.apply(this, arguments);
+        };
+        descriptor && Object.defineProperty(wrapperMethod, "name", descriptor);
+        Object.defineProperty(consoleInst, methodName, {
+          value: wrapperMethod
+        });
+      }
+    }
+    function getCurrentStackInDEV() {
+      var owner = resolveOwner();
+      if (null === owner) return "";
+      try {
+        var info = "";
+        if (owner.owner || "string" !== typeof owner.name) {
+          for (; owner; ) {
+            var ownerStack = owner.debugStack;
+            if (null != ownerStack) {
+              if ((owner = owner.owner)) {
+                var JSCompiler_temp_const = info;
+                var error = ownerStack,
+                  prevPrepareStackTrace = Error.prepareStackTrace;
+                Error.prepareStackTrace = prepareStackTrace;
+                var stack = error.stack;
+                Error.prepareStackTrace = prevPrepareStackTrace;
+                stack.startsWith("Error: react-stack-top-frame\n") &&
+                  (stack = stack.slice(29));
+                var idx = stack.indexOf("\n");
+                -1 !== idx && (stack = stack.slice(idx + 1));
+                idx = stack.indexOf("react-stack-bottom-frame");
+                -1 !== idx && (idx = stack.lastIndexOf("\n", idx));
+                var JSCompiler_inline_result =
+                  -1 !== idx ? (stack = stack.slice(0, idx)) : "";
+                info =
+                  JSCompiler_temp_const + ("\n" + JSCompiler_inline_result);
+              }
+            } else break;
+          }
+          var JSCompiler_inline_result$jscomp$0 = info;
+        } else {
+          JSCompiler_temp_const = owner.name;
+          if (void 0 === prefix)
+            try {
+              throw Error();
+            } catch (x) {
+              (prefix =
+                ((error = x.stack.trim().match(/\n( *(at )?)/)) && error[1]) ||
+                ""),
+                (suffix =
+                  -1 < x.stack.indexOf("\n    at")
+                    ? " (<anonymous>)"
+                    : -1 < x.stack.indexOf("@")
+                      ? "@unknown:0:0"
+                      : "");
+            }
+          JSCompiler_inline_result$jscomp$0 =
+            "\n" + prefix + JSCompiler_temp_const + suffix;
+        }
+      } catch (x) {
+        JSCompiler_inline_result$jscomp$0 =
+          "\nError generating stack: " + x.message + "\n" + x.stack;
+      }
+      return JSCompiler_inline_result$jscomp$0;
+    }
+    function throwTaintViolation(message) {
+      throw Error(message);
+    }
+    function cleanupTaintQueue(request) {
+      request = request.taintCleanupQueue;
+      TaintRegistryPendingRequests.delete(request);
+      for (var i = 0; i < request.length; i++) {
+        var entryValue = request[i],
+          entry = TaintRegistryValues.get(entryValue);
+        void 0 !== entry &&
+          (1 === entry.count
+            ? TaintRegistryValues.delete(entryValue)
+            : entry.count--);
+      }
+      request.length = 0;
+    }
+    function defaultErrorHandler(error) {
+      console.error(error);
+    }
+    function defaultPostponeHandler() {}
+    function RequestInstance(
+      type,
+      model,
+      bundlerConfig,
+      onError,
+      identifierPrefix,
+      onPostpone,
+      temporaryReferences,
+      environmentName,
+      filterStackFrame,
+      onAllReady,
+      onFatalError
+    ) {
+      if (
+        null !== ReactSharedInternalsServer.A &&
+        ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
+      )
+        throw Error(
+          "Currently React only supports one RSC renderer at a time."
+        );
+      ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
+      ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;
+      var abortSet = new Set(),
+        pingedTasks = [],
+        cleanupQueue = [];
+      TaintRegistryPendingRequests.add(cleanupQueue);
+      var hints = new Set();
+      this.type = type;
+      this.status = OPENING;
+      this.flushScheduled = !1;
+      this.destination = this.fatalError = null;
+      this.bundlerConfig = bundlerConfig;
+      this.cache = new Map();
+      this.pendingChunks = this.nextChunkId = 0;
+      this.hints = hints;
+      this.abortListeners = new Set();
+      this.abortableTasks = abortSet;
+      this.pingedTasks = pingedTasks;
+      this.completedImportChunks = [];
+      this.completedHintChunks = [];
+      this.completedRegularChunks = [];
+      this.completedErrorChunks = [];
+      this.writtenSymbols = new Map();
+      this.writtenClientReferences = new Map();
+      this.writtenServerReferences = new Map();
+      this.writtenObjects = new WeakMap();
+      this.temporaryReferences = temporaryReferences;
+      this.identifierPrefix = identifierPrefix || "";
+      this.identifierCount = 1;
+      this.taintCleanupQueue = cleanupQueue;
+      this.onError = void 0 === onError ? defaultErrorHandler : onError;
+      this.onPostpone =
+        void 0 === onPostpone ? defaultPostponeHandler : onPostpone;
+      this.onAllReady = onAllReady;
+      this.onFatalError = onFatalError;
+      this.environmentName =
+        void 0 === environmentName
+          ? function () {
+              return "Server";
+            }
+          : "function" !== typeof environmentName
+            ? function () {
+                return environmentName;
+              }
+            : environmentName;
+      this.filterStackFrame =
+        void 0 === filterStackFrame
+          ? defaultFilterStackFrame
+          : filterStackFrame;
+      this.didWarnForKey = null;
+      type = this.timeOrigin = performance.now();
+      emitTimeOriginChunk(this, type + performance.timeOrigin);
+      model = createTask(this, model, null, !1, abortSet, null, null, null);
+      pingedTasks.push(model);
+    }
+    function noop() {}
+    function resolveRequest() {
+      if (currentRequest) return currentRequest;
+      var store = requestStorage.getStore();
+      return store ? store : null;
+    }
+    function serializeThenable(request, task, thenable) {
+      var newTask = createTask(
+        request,
+        null,
+        task.keyPath,
+        task.implicitSlot,
+        request.abortableTasks,
+        task.debugOwner,
+        task.debugStack,
+        task.debugTask
+      );
+      (task = thenable._debugInfo) &&
+        forwardDebugInfo(request, newTask.id, task);
+      switch (thenable.status) {
+        case "fulfilled":
+          return (
+            (newTask.model = thenable.value),
+            pingTask(request, newTask),
+            newTask.id
+          );
+        case "rejected":
+          return erroredTask(request, newTask, thenable.reason), newTask.id;
+        default:
+          if (request.status === ABORTING)
+            return (
+              request.abortableTasks.delete(newTask),
+              (newTask.status = ABORTED),
+              request.type === PRERENDER
+                ? request.pendingChunks--
+                : ((task = stringify(serializeByValueID(request.fatalError))),
+                  emitModelChunk(request, newTask.id, task)),
+              newTask.id
+            );
+          "string" !== typeof thenable.status &&
+            ((thenable.status = "pending"),
+            thenable.then(
+              function (fulfilledValue) {
+                "pending" === thenable.status &&
+                  ((thenable.status = "fulfilled"),
+                  (thenable.value = fulfilledValue));
+              },
+              function (error) {
+                "pending" === thenable.status &&
+                  ((thenable.status = "rejected"), (thenable.reason = error));
+              }
+            ));
+      }
+      thenable.then(
+        function (value) {
+          newTask.model = value;
+          pingTask(request, newTask);
+        },
+        function (reason) {
+          newTask.status === PENDING$1 &&
+            (erroredTask(request, newTask, reason), enqueueFlush(request));
+        }
+      );
+      newTask.timed = !0;
+      return newTask.id;
+    }
+    function serializeReadableStream(request, task, stream) {
+      function progress(entry) {
+        if (!aborted)
+          if (entry.done)
+            request.abortListeners.delete(abortStream),
+              (entry = streamTask.id.toString(16) + ":C\n"),
+              request.completedRegularChunks.push(entry),
+              enqueueFlush(request),
+              (aborted = !0);
+          else
+            try {
+              (streamTask.model = entry.value),
+                request.pendingChunks++,
+                tryStreamTask(request, streamTask),
+                enqueueFlush(request),
+                reader.read().then(progress, error);
+            } catch (x$0) {
+              error(x$0);
+            }
+      }
+      function error(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortStream),
+          erroredTask(request, streamTask, reason),
+          enqueueFlush(request),
+          reader.cancel(reason).then(error, error));
+      }
+      function abortStream(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortStream),
+          request.type === PRERENDER
+            ? request.pendingChunks--
+            : (erroredTask(request, streamTask, reason), enqueueFlush(request)),
+          reader.cancel(reason).then(error, error));
+      }
+      var supportsBYOB = stream.supportsBYOB;
+      if (void 0 === supportsBYOB)
+        try {
+          stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+        } catch (x) {
+          supportsBYOB = !1;
+        }
+      var reader = stream.getReader(),
+        streamTask = createTask(
+          request,
+          task.model,
+          task.keyPath,
+          task.implicitSlot,
+          request.abortableTasks,
+          task.debugOwner,
+          task.debugStack,
+          task.debugTask
+        );
+      request.abortableTasks.delete(streamTask);
+      request.pendingChunks++;
+      task =
+        streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+      request.completedRegularChunks.push(task);
+      var aborted = !1;
+      request.abortListeners.add(abortStream);
+      reader.read().then(progress, error);
+      return serializeByValueID(streamTask.id);
+    }
+    function serializeAsyncIterable(request, task, iterable, iterator) {
+      function progress(entry) {
+        if (!aborted)
+          if (entry.done) {
+            request.abortListeners.delete(abortIterable);
+            if (void 0 === entry.value)
+              var endStreamRow = streamTask.id.toString(16) + ":C\n";
+            else
+              try {
+                var chunkId = outlineModel(request, entry.value);
+                endStreamRow =
+                  streamTask.id.toString(16) +
+                  ":C" +
+                  stringify(serializeByValueID(chunkId)) +
+                  "\n";
+              } catch (x) {
+                error(x);
+                return;
+              }
+            request.completedRegularChunks.push(endStreamRow);
+            enqueueFlush(request);
+            aborted = !0;
+          } else
+            try {
+              (streamTask.model = entry.value),
+                request.pendingChunks++,
+                tryStreamTask(request, streamTask),
+                enqueueFlush(request),
+                callIteratorInDEV(iterator, progress, error);
+            } catch (x$1) {
+              error(x$1);
+            }
+      }
+      function error(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortIterable),
+          erroredTask(request, streamTask, reason),
+          enqueueFlush(request),
+          "function" === typeof iterator.throw &&
+            iterator.throw(reason).then(error, error));
+      }
+      function abortIterable(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortIterable),
+          request.type === PRERENDER
+            ? request.pendingChunks--
+            : (erroredTask(request, streamTask, reason), enqueueFlush(request)),
+          "function" === typeof iterator.throw &&
+            iterator.throw(reason).then(error, error));
+      }
+      var isIterator = iterable === iterator,
+        streamTask = createTask(
+          request,
+          task.model,
+          task.keyPath,
+          task.implicitSlot,
+          request.abortableTasks,
+          task.debugOwner,
+          task.debugStack,
+          task.debugTask
+        );
+      request.abortableTasks.delete(streamTask);
+      request.pendingChunks++;
+      task = streamTask.id.toString(16) + ":" + (isIterator ? "x" : "X") + "\n";
+      request.completedRegularChunks.push(task);
+      (iterable = iterable._debugInfo) &&
+        forwardDebugInfo(request, streamTask.id, iterable);
+      var aborted = !1;
+      request.abortListeners.add(abortIterable);
+      callIteratorInDEV(iterator, progress, error);
+      return serializeByValueID(streamTask.id);
+    }
+    function emitHint(request, code, model) {
+      model = stringify(model);
+      request.completedHintChunks.push(":H" + code + model + "\n");
+      enqueueFlush(request);
+    }
+    function readThenable(thenable) {
+      if ("fulfilled" === thenable.status) return thenable.value;
+      if ("rejected" === thenable.status) throw thenable.reason;
+      throw thenable;
+    }
+    function createLazyWrapperAroundWakeable(wakeable) {
+      switch (wakeable.status) {
+        case "fulfilled":
+        case "rejected":
+          break;
+        default:
+          "string" !== typeof wakeable.status &&
+            ((wakeable.status = "pending"),
+            wakeable.then(
+              function (fulfilledValue) {
+                "pending" === wakeable.status &&
+                  ((wakeable.status = "fulfilled"),
+                  (wakeable.value = fulfilledValue));
+              },
+              function (error) {
+                "pending" === wakeable.status &&
+                  ((wakeable.status = "rejected"), (wakeable.reason = error));
+              }
+            ));
+      }
+      var lazyType = {
+        $$typeof: REACT_LAZY_TYPE,
+        _payload: wakeable,
+        _init: readThenable
+      };
+      lazyType._debugInfo = wakeable._debugInfo || [];
+      return lazyType;
+    }
+    function callWithDebugContextInDEV(request, task, callback, arg) {
+      var componentDebugInfo = {
+        name: "",
+        env: task.environmentName,
+        key: null,
+        owner: task.debugOwner
+      };
+      componentDebugInfo.stack =
+        null === task.debugStack
+          ? null
+          : filterStackTrace(request, task.debugStack, 1);
+      componentDebugInfo.debugStack = task.debugStack;
+      request = componentDebugInfo.debugTask = task.debugTask;
+      currentOwner = componentDebugInfo;
+      try {
+        return request ? request.run(callback.bind(null, arg)) : callback(arg);
+      } finally {
+        currentOwner = null;
+      }
+    }
+    function processServerComponentReturnValue(
+      request,
+      task,
+      Component,
+      result
+    ) {
+      if (
+        "object" !== typeof result ||
+        null === result ||
+        isClientReference(result)
+      )
+        return result;
+      if ("function" === typeof result.then)
+        return (
+          result.then(function (resolvedValue) {
+            "object" === typeof resolvedValue &&
+              null !== resolvedValue &&
+              resolvedValue.$$typeof === REACT_ELEMENT_TYPE &&
+              (resolvedValue._store.validated = 1);
+          }, voidHandler),
+          "fulfilled" === result.status
+            ? result.value
+            : createLazyWrapperAroundWakeable(result)
+        );
+      result.$$typeof === REACT_ELEMENT_TYPE && (result._store.validated = 1);
+      var iteratorFn = getIteratorFn(result);
+      if (iteratorFn) {
+        var multiShot = _defineProperty({}, Symbol.iterator, function () {
+          var iterator = iteratorFn.call(result);
+          iterator !== result ||
+            ("[object GeneratorFunction]" ===
+              Object.prototype.toString.call(Component) &&
+              "[object Generator]" ===
+                Object.prototype.toString.call(result)) ||
+            callWithDebugContextInDEV(request, task, function () {
+              console.error(
+                "Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. "
+              );
+            });
+          return iterator;
+        });
+        multiShot._debugInfo = result._debugInfo;
+        return multiShot;
+      }
+      return "function" !== typeof result[ASYNC_ITERATOR] ||
+        ("function" === typeof ReadableStream &&
+          result instanceof ReadableStream)
+        ? result
+        : ((multiShot = _defineProperty({}, ASYNC_ITERATOR, function () {
+            var iterator = result[ASYNC_ITERATOR]();
+            iterator !== result ||
+              ("[object AsyncGeneratorFunction]" ===
+                Object.prototype.toString.call(Component) &&
+                "[object AsyncGenerator]" ===
+                  Object.prototype.toString.call(result)) ||
+              callWithDebugContextInDEV(request, task, function () {
+                console.error(
+                  "Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. "
+                );
+              });
+            return iterator;
+          })),
+          (multiShot._debugInfo = result._debugInfo),
+          multiShot);
+    }
+    function renderFunctionComponent(
+      request,
+      task,
+      key,
+      Component,
+      props,
+      validated
+    ) {
+      var prevThenableState = task.thenableState;
+      task.thenableState = null;
+      if (null === debugID) return outlineTask(request, task);
+      if (null !== prevThenableState)
+        var componentDebugInfo = prevThenableState._componentDebugInfo;
+      else {
+        var componentDebugID = debugID;
+        componentDebugInfo = Component.displayName || Component.name || "";
+        var componentEnv = (0, request.environmentName)();
+        request.pendingChunks++;
+        componentDebugInfo = {
+          name: componentDebugInfo,
+          env: componentEnv,
+          key: key,
+          owner: task.debugOwner
+        };
+        componentDebugInfo.stack =
+          null === task.debugStack
+            ? null
+            : filterStackTrace(request, task.debugStack, 1);
+        componentDebugInfo.props = props;
+        componentDebugInfo.debugStack = task.debugStack;
+        componentDebugInfo.debugTask = task.debugTask;
+        outlineComponentInfo(request, componentDebugInfo);
+        task.timed = !0;
+        emitTimingChunk(request, componentDebugID, performance.now());
+        emitDebugChunk(request, componentDebugID, componentDebugInfo);
+        task.environmentName = componentEnv;
+        2 === validated &&
+          warnForMissingKey(request, key, componentDebugInfo, task.debugTask);
+      }
+      thenableIndexCounter = 0;
+      thenableState = prevThenableState;
+      currentComponentDebugInfo = componentDebugInfo;
+      props = task.debugTask
+        ? task.debugTask.run(
+            componentStorage.run.bind(
+              componentStorage,
+              componentDebugInfo,
+              callComponentInDEV,
+              Component,
+              props,
+              componentDebugInfo
+            )
+          )
+        : componentStorage.run(
+            componentDebugInfo,
+            callComponentInDEV,
+            Component,
+            props,
+            componentDebugInfo
+          );
+      if (request.status === ABORTING)
+        throw (
+          ("object" !== typeof props ||
+            null === props ||
+            "function" !== typeof props.then ||
+            isClientReference(props) ||
+            props.then(voidHandler, voidHandler),
+          null)
+        );
+      props = processServerComponentReturnValue(
+        request,
+        task,
+        Component,
+        props
+      );
+      Component = task.keyPath;
+      validated = task.implicitSlot;
+      null !== key
+        ? (task.keyPath = null === Component ? key : Component + "," + key)
+        : null === Component && (task.implicitSlot = !0);
+      request = renderModelDestructive(request, task, emptyRoot, "", props);
+      task.keyPath = Component;
+      task.implicitSlot = validated;
+      return request;
+    }
+    function warnForMissingKey(request, key, componentDebugInfo, debugTask) {
+      function logKeyError() {
+        console.error(
+          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
+          "",
+          ""
+        );
+      }
+      key = request.didWarnForKey;
+      null == key && (key = request.didWarnForKey = new WeakSet());
+      request = componentDebugInfo.owner;
+      if (null != request) {
+        if (key.has(request)) return;
+        key.add(request);
+      }
+      debugTask
+        ? debugTask.run(
+            componentStorage.run.bind(
+              componentStorage,
+              componentDebugInfo,
+              callComponentInDEV,
+              logKeyError,
+              null,
+              componentDebugInfo
+            )
+          )
+        : componentStorage.run(
+            componentDebugInfo,
+            callComponentInDEV,
+            logKeyError,
+            null,
+            componentDebugInfo
+          );
+    }
+    function renderFragment(request, task, children) {
+      for (var i = 0; i < children.length; i++) {
+        var child = children[i];
+        null === child ||
+          "object" !== typeof child ||
+          child.$$typeof !== REACT_ELEMENT_TYPE ||
+          null !== child.key ||
+          child._store.validated ||
+          (child._store.validated = 2);
+      }
+      if (null !== task.keyPath)
+        return (
+          (request = [
+            REACT_ELEMENT_TYPE,
+            REACT_FRAGMENT_TYPE,
+            task.keyPath,
+            { children: children },
+            null,
+            null,
+            0
+          ]),
+          task.implicitSlot ? [request] : request
+        );
+      if ((i = children._debugInfo)) {
+        if (null === debugID) return outlineTask(request, task);
+        forwardDebugInfo(request, debugID, i);
+        children = Array.from(children);
+      }
+      return children;
+    }
+    function renderAsyncFragment(request, task, children, getAsyncIterator) {
+      if (null !== task.keyPath)
+        return (
+          (request = [
+            REACT_ELEMENT_TYPE,
+            REACT_FRAGMENT_TYPE,
+            task.keyPath,
+            { children: children },
+            null,
+            null,
+            0
+          ]),
+          task.implicitSlot ? [request] : request
+        );
+      getAsyncIterator = getAsyncIterator.call(children);
+      return serializeAsyncIterable(request, task, children, getAsyncIterator);
+    }
+    function outlineTask(request, task) {
+      task = createTask(
+        request,
+        task.model,
+        task.keyPath,
+        task.implicitSlot,
+        request.abortableTasks,
+        task.debugOwner,
+        task.debugStack,
+        task.debugTask
+      );
+      retryTask(request, task);
+      return task.status === COMPLETED
+        ? serializeByValueID(task.id)
+        : serializeLazyID(task.id);
+    }
+    function renderElement(request, task, type, key, ref, props, validated) {
+      if (null !== ref && void 0 !== ref)
+        throw Error(
+          "Refs cannot be used in Server Components, nor passed to Client Components."
+        );
+      jsxPropsParents.set(props, type);
+      "object" === typeof props.children &&
+        null !== props.children &&
+        jsxChildrenParents.set(props.children, type);
+      if (
+        "function" !== typeof type ||
+        isClientReference(type) ||
+        type.$$typeof === TEMPORARY_REFERENCE_TAG
+      ) {
+        if (type === REACT_FRAGMENT_TYPE && null === key)
+          return (
+            2 === validated &&
+              ((validated = {
+                name: "Fragment",
+                env: (0, request.environmentName)(),
+                key: key,
+                owner: task.debugOwner,
+                stack:
+                  null === task.debugStack
+                    ? null
+                    : filterStackTrace(request, task.debugStack, 1),
+                props: props,
+                debugStack: task.debugStack,
+                debugTask: task.debugTask
+              }),
+              warnForMissingKey(request, key, validated, task.debugTask)),
+            (validated = task.implicitSlot),
+            null === task.keyPath && (task.implicitSlot = !0),
+            (request = renderModelDestructive(
+              request,
+              task,
+              emptyRoot,
+              "",
+              props.children
+            )),
+            (task.implicitSlot = validated),
+            request
+          );
+        if (
+          null != type &&
+          "object" === typeof type &&
+          !isClientReference(type)
+        )
+          switch (type.$$typeof) {
+            case REACT_LAZY_TYPE:
+              type = callLazyInitInDEV(type);
+              if (request.status === ABORTING) throw null;
+              return renderElement(
+                request,
+                task,
+                type,
+                key,
+                ref,
+                props,
+                validated
+              );
+            case REACT_FORWARD_REF_TYPE:
+              return renderFunctionComponent(
+                request,
+                task,
+                key,
+                type.render,
+                props,
+                validated
+              );
+            case REACT_MEMO_TYPE:
+              return renderElement(
+                request,
+                task,
+                type.type,
+                key,
+                ref,
+                props,
+                validated
+              );
+            case REACT_ELEMENT_TYPE:
+              type._store.validated = 1;
+          }
+      } else
+        return renderFunctionComponent(
+          request,
+          task,
+          key,
+          type,
+          props,
+          validated
+        );
+      ref = task.keyPath;
+      null === key ? (key = ref) : null !== ref && (key = ref + "," + key);
+      null !== task.debugOwner &&
+        outlineComponentInfo(request, task.debugOwner);
+      request = [
+        REACT_ELEMENT_TYPE,
+        type,
+        key,
+        props,
+        task.debugOwner,
+        null === task.debugStack
+          ? null
+          : filterStackTrace(request, task.debugStack, 1),
+        validated
+      ];
+      task = task.implicitSlot && null !== key ? [request] : request;
+      return task;
+    }
+    function pingTask(request, task) {
+      task.timed = !0;
+      var pingedTasks = request.pingedTasks;
+      pingedTasks.push(task);
+      1 === pingedTasks.length &&
+        ((request.flushScheduled = null !== request.destination),
+        request.type === PRERENDER || request.status === OPENING
+          ? scheduleMicrotask(function () {
+              return performWork(request);
+            })
+          : setImmediate(function () {
+              return performWork(request);
+            }));
+    }
+    function createTask(
+      request,
+      model,
+      keyPath,
+      implicitSlot,
+      abortSet,
+      debugOwner,
+      debugStack,
+      debugTask
+    ) {
+      request.pendingChunks++;
+      var id = request.nextChunkId++;
+      "object" !== typeof model ||
+        null === model ||
+        null !== keyPath ||
+        implicitSlot ||
+        request.writtenObjects.set(model, serializeByValueID(id));
+      var task = {
+        id: id,
+        status: PENDING$1,
+        model: model,
+        keyPath: keyPath,
+        implicitSlot: implicitSlot,
+        ping: function () {
+          return pingTask(request, task);
+        },
+        toJSON: function (parentPropertyName, value) {
+          var parent = this,
+            originalValue = parent[parentPropertyName];
+          "object" !== typeof originalValue ||
+            originalValue === value ||
+            originalValue instanceof Date ||
+            callWithDebugContextInDEV(request, task, function () {
+              "Object" !== objectName(originalValue)
+                ? "string" === typeof jsxChildrenParents.get(parent)
+                  ? console.error(
+                      "%s objects cannot be rendered as text children. Try formatting it using toString().%s",
+                      objectName(originalValue),
+                      describeObjectForErrorMessage(parent, parentPropertyName)
+                    )
+                  : console.error(
+                      "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+                      objectName(originalValue),
+                      describeObjectForErrorMessage(parent, parentPropertyName)
+                    )
+                : console.error(
+                    "Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s",
+                    describeObjectForErrorMessage(parent, parentPropertyName)
+                  );
+            });
+          return renderModel(request, task, parent, parentPropertyName, value);
+        },
+        thenableState: null,
+        timed: !1
+      };
+      task.environmentName = request.environmentName();
+      task.debugOwner = debugOwner;
+      task.debugStack = debugStack;
+      task.debugTask = debugTask;
+      abortSet.add(task);
+      return task;
+    }
+    function serializeByValueID(id) {
+      return "$" + id.toString(16);
+    }
+    function serializeLazyID(id) {
+      return "$L" + id.toString(16);
+    }
+    function serializeNumber(number) {
+      return Number.isFinite(number)
+        ? 0 === number && -Infinity === 1 / number
+          ? "$-0"
+          : number
+        : Infinity === number
+          ? "$Infinity"
+          : -Infinity === number
+            ? "$-Infinity"
+            : "$NaN";
+    }
+    function encodeReferenceChunk(request, id, reference) {
+      request = stringify(reference);
+      return id.toString(16) + ":" + request + "\n";
+    }
+    function serializeClientReference(
+      request,
+      parent,
+      parentPropertyName,
+      clientReference
+    ) {
+      var clientReferenceKey = clientReference.$$id,
+        writtenClientReferences = request.writtenClientReferences,
+        existingId = writtenClientReferences.get(clientReferenceKey);
+      if (void 0 !== existingId)
+        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+          ? serializeLazyID(existingId)
+          : serializeByValueID(existingId);
+      try {
+        var baseURL = request.bundlerConfig,
+          id = clientReference.$$id,
+          idx = id.lastIndexOf("#"),
+          exportName = id.slice(idx + 1),
+          fullURL = id.slice(0, idx);
+        if (!fullURL.startsWith(baseURL))
+          throw Error(
+            "Attempted to load a Client Module outside the hosted root."
+          );
+        var clientReferenceMetadata = [
+          fullURL.slice(baseURL.length),
+          exportName
+        ];
+        request.pendingChunks++;
+        var importId = request.nextChunkId++,
+          json = stringify(clientReferenceMetadata),
+          processedChunk = importId.toString(16) + ":I" + json + "\n";
+        request.completedImportChunks.push(processedChunk);
+        writtenClientReferences.set(clientReferenceKey, importId);
+        return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+          ? serializeLazyID(importId)
+          : serializeByValueID(importId);
+      } catch (x) {
+        return (
+          request.pendingChunks++,
+          (parent = request.nextChunkId++),
+          (parentPropertyName = logRecoverableError(request, x, null)),
+          emitErrorChunk(request, parent, parentPropertyName, x),
+          serializeByValueID(parent)
+        );
+      }
+    }
+    function outlineModel(request, value) {
+      value = createTask(
+        request,
+        value,
+        null,
+        !1,
+        request.abortableTasks,
+        null,
+        null,
+        null
+      );
+      retryTask(request, value);
+      return value.id;
+    }
+    function serializeServerReference(request, serverReference) {
+      var writtenServerReferences = request.writtenServerReferences,
+        existingId = writtenServerReferences.get(serverReference);
+      if (void 0 !== existingId) return "$F" + existingId.toString(16);
+      existingId = serverReference.$$bound;
+      existingId = null === existingId ? null : Promise.resolve(existingId);
+      var id = serverReference.$$id,
+        location = null,
+        error = serverReference.$$location;
+      error &&
+        ((error = parseStackTrace(error, 1)),
+        0 < error.length && (location = error[0]));
+      existingId =
+        null !== location
+          ? {
+              id: id,
+              bound: existingId,
+              name:
+                "function" === typeof serverReference
+                  ? serverReference.name
+                  : "",
+              env: (0, request.environmentName)(),
+              location: location
+            }
+          : { id: id, bound: existingId };
+      request = outlineModel(request, existingId);
+      writtenServerReferences.set(serverReference, request);
+      return "$F" + request.toString(16);
+    }
+    function serializeLargeTextString(request, text) {
+      request.pendingChunks++;
+      var textId = request.nextChunkId++;
+      emitTextChunk(request, textId, text);
+      return serializeByValueID(textId);
+    }
+    function serializeMap(request, map) {
+      map = Array.from(map);
+      return "$Q" + outlineModel(request, map).toString(16);
+    }
+    function serializeFormData(request, formData) {
+      formData = Array.from(formData.entries());
+      return "$K" + outlineModel(request, formData).toString(16);
+    }
+    function serializeSet(request, set) {
+      set = Array.from(set);
+      return "$W" + outlineModel(request, set).toString(16);
+    }
+    function serializeTypedArray(request, tag, typedArray) {
+      request.pendingChunks++;
+      var bufferId = request.nextChunkId++;
+      emitTypedArrayChunk(request, bufferId, tag, typedArray);
+      return serializeByValueID(bufferId);
+    }
+    function serializeBlob(request, blob) {
+      function progress(entry) {
+        if (!aborted)
+          if (entry.done)
+            request.abortListeners.delete(abortBlob),
+              (aborted = !0),
+              pingTask(request, newTask);
+          else
+            return (
+              model.push(entry.value), reader.read().then(progress).catch(error)
+            );
+      }
+      function error(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortBlob),
+          erroredTask(request, newTask, reason),
+          enqueueFlush(request),
+          reader.cancel(reason).then(error, error));
+      }
+      function abortBlob(reason) {
+        aborted ||
+          ((aborted = !0),
+          request.abortListeners.delete(abortBlob),
+          request.type === PRERENDER
+            ? request.pendingChunks--
+            : (erroredTask(request, newTask, reason), enqueueFlush(request)),
+          reader.cancel(reason).then(error, error));
+      }
+      var model = [blob.type],
+        newTask = createTask(
+          request,
+          model,
+          null,
+          !1,
+          request.abortableTasks,
+          null,
+          null,
+          null
+        ),
+        reader = blob.stream().getReader(),
+        aborted = !1;
+      request.abortListeners.add(abortBlob);
+      reader.read().then(progress).catch(error);
+      return "$B" + newTask.id.toString(16);
+    }
+    function renderModel(request, task, parent, key, value) {
+      var prevKeyPath = task.keyPath,
+        prevImplicitSlot = task.implicitSlot;
+      try {
+        return renderModelDestructive(request, task, parent, key, value);
+      } catch (thrownValue) {
+        parent = task.model;
+        parent =
+          "object" === typeof parent &&
+          null !== parent &&
+          (parent.$$typeof === REACT_ELEMENT_TYPE ||
+            parent.$$typeof === REACT_LAZY_TYPE);
+        if (request.status === ABORTING) {
+          task.status = ABORTED;
+          if (request.type === PRERENDER)
+            return (
+              (task = request.nextChunkId++),
+              (task = parent
+                ? serializeLazyID(task)
+                : serializeByValueID(task)),
+              task
+            );
+          task = request.fatalError;
+          return parent ? serializeLazyID(task) : serializeByValueID(task);
+        }
+        key =
+          thrownValue === SuspenseException
+            ? getSuspendedThenable()
+            : thrownValue;
+        if (
+          "object" === typeof key &&
+          null !== key &&
+          "function" === typeof key.then
+        )
+          return (
+            (request = createTask(
+              request,
+              task.model,
+              task.keyPath,
+              task.implicitSlot,
+              request.abortableTasks,
+              task.debugOwner,
+              task.debugStack,
+              task.debugTask
+            )),
+            (value = request.ping),
+            key.then(value, value),
+            (request.thenableState = getThenableStateAfterSuspending()),
+            (task.keyPath = prevKeyPath),
+            (task.implicitSlot = prevImplicitSlot),
+            parent
+              ? serializeLazyID(request.id)
+              : serializeByValueID(request.id)
+          );
+        task.keyPath = prevKeyPath;
+        task.implicitSlot = prevImplicitSlot;
+        request.pendingChunks++;
+        prevKeyPath = request.nextChunkId++;
+        "object" === typeof key &&
+        null !== key &&
+        key.$$typeof === REACT_POSTPONE_TYPE
+          ? (logPostpone(request, key.message, task),
+            emitPostponeChunk(request, prevKeyPath, key))
+          : ((task = logRecoverableError(request, key, task)),
+            emitErrorChunk(request, prevKeyPath, task, key));
+        return parent
+          ? serializeLazyID(prevKeyPath)
+          : serializeByValueID(prevKeyPath);
+      }
+    }
+    function renderModelDestructive(
+      request,
+      task,
+      parent,
+      parentPropertyName,
+      value
+    ) {
+      task.model = value;
+      if (value === REACT_ELEMENT_TYPE) return "$";
+      if (null === value) return null;
+      if ("object" === typeof value) {
+        switch (value.$$typeof) {
+          case REACT_ELEMENT_TYPE:
+            var elementReference = null,
+              _writtenObjects = request.writtenObjects;
+            if (null === task.keyPath && !task.implicitSlot) {
+              var _existingReference = _writtenObjects.get(value);
+              if (void 0 !== _existingReference)
+                if (modelRoot === value) modelRoot = null;
+                else return _existingReference;
+              else
+                -1 === parentPropertyName.indexOf(":") &&
+                  ((_existingReference = _writtenObjects.get(parent)),
+                  void 0 !== _existingReference &&
+                    ((elementReference =
+                      _existingReference + ":" + parentPropertyName),
+                    _writtenObjects.set(value, elementReference)));
+            }
+            if ((_existingReference = value._debugInfo)) {
+              if (null === debugID) return outlineTask(request, task);
+              forwardDebugInfo(request, debugID, _existingReference);
+            }
+            _existingReference = value.props;
+            var refProp = _existingReference.ref;
+            task.debugOwner = value._owner;
+            task.debugStack = value._debugStack;
+            task.debugTask = value._debugTask;
+            request = renderElement(
+              request,
+              task,
+              value.type,
+              value.key,
+              void 0 !== refProp ? refProp : null,
+              _existingReference,
+              value._store.validated
+            );
+            "object" === typeof request &&
+              null !== request &&
+              null !== elementReference &&
+              (_writtenObjects.has(request) ||
+                _writtenObjects.set(request, elementReference));
+            return request;
+          case REACT_LAZY_TYPE:
+            task.thenableState = null;
+            elementReference = callLazyInitInDEV(value);
+            if (request.status === ABORTING) throw null;
+            if ((_writtenObjects = value._debugInfo)) {
+              if (null === debugID) return outlineTask(request, task);
+              forwardDebugInfo(request, debugID, _writtenObjects);
+            }
+            return renderModelDestructive(
+              request,
+              task,
+              emptyRoot,
+              "",
+              elementReference
+            );
+          case REACT_LEGACY_ELEMENT_TYPE:
+            throw Error(
+              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+            );
+        }
+        if (isClientReference(value))
+          return serializeClientReference(
+            request,
+            parent,
+            parentPropertyName,
+            value
+          );
+        if (
+          void 0 !== request.temporaryReferences &&
+          ((elementReference = request.temporaryReferences.get(value)),
+          void 0 !== elementReference)
+        )
+          return "$T" + elementReference;
+        elementReference = TaintRegistryObjects.get(value);
+        void 0 !== elementReference && throwTaintViolation(elementReference);
+        elementReference = request.writtenObjects;
+        _writtenObjects = elementReference.get(value);
+        if ("function" === typeof value.then) {
+          if (void 0 !== _writtenObjects) {
+            if (null !== task.keyPath || task.implicitSlot)
+              return (
+                "$@" + serializeThenable(request, task, value).toString(16)
+              );
+            if (modelRoot === value) modelRoot = null;
+            else return _writtenObjects;
+          }
+          request = "$@" + serializeThenable(request, task, value).toString(16);
+          elementReference.set(value, request);
+          return request;
+        }
+        if (void 0 !== _writtenObjects)
+          if (modelRoot === value) modelRoot = null;
+          else return _writtenObjects;
+        else if (
+          -1 === parentPropertyName.indexOf(":") &&
+          ((_writtenObjects = elementReference.get(parent)),
+          void 0 !== _writtenObjects)
+        ) {
+          _existingReference = parentPropertyName;
+          if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
+            switch (parentPropertyName) {
+              case "1":
+                _existingReference = "type";
+                break;
+              case "2":
+                _existingReference = "key";
+                break;
+              case "3":
+                _existingReference = "props";
+                break;
+              case "4":
+                _existingReference = "_owner";
+            }
+          elementReference.set(
+            value,
+            _writtenObjects + ":" + _existingReference
+          );
+        }
+        if (isArrayImpl(value)) return renderFragment(request, task, value);
+        if (value instanceof Map) return serializeMap(request, value);
+        if (value instanceof Set) return serializeSet(request, value);
+        if ("function" === typeof FormData && value instanceof FormData)
+          return serializeFormData(request, value);
+        if (value instanceof Error) return serializeErrorValue(request, value);
+        if (value instanceof ArrayBuffer)
+          return serializeTypedArray(request, "A", new Uint8Array(value));
+        if (value instanceof Int8Array)
+          return serializeTypedArray(request, "O", value);
+        if (value instanceof Uint8Array)
+          return serializeTypedArray(request, "o", value);
+        if (value instanceof Uint8ClampedArray)
+          return serializeTypedArray(request, "U", value);
+        if (value instanceof Int16Array)
+          return serializeTypedArray(request, "S", value);
+        if (value instanceof Uint16Array)
+          return serializeTypedArray(request, "s", value);
+        if (value instanceof Int32Array)
+          return serializeTypedArray(request, "L", value);
+        if (value instanceof Uint32Array)
+          return serializeTypedArray(request, "l", value);
+        if (value instanceof Float32Array)
+          return serializeTypedArray(request, "G", value);
+        if (value instanceof Float64Array)
+          return serializeTypedArray(request, "g", value);
+        if (value instanceof BigInt64Array)
+          return serializeTypedArray(request, "M", value);
+        if (value instanceof BigUint64Array)
+          return serializeTypedArray(request, "m", value);
+        if (value instanceof DataView)
+          return serializeTypedArray(request, "V", value);
+        if ("function" === typeof Blob && value instanceof Blob)
+          return serializeBlob(request, value);
+        if ((elementReference = getIteratorFn(value)))
+          return (
+            (elementReference = elementReference.call(value)),
+            elementReference === value
+              ? "$i" +
+                outlineModel(request, Array.from(elementReference)).toString(16)
+              : renderFragment(request, task, Array.from(elementReference))
+          );
+        if (
+          "function" === typeof ReadableStream &&
+          value instanceof ReadableStream
+        )
+          return serializeReadableStream(request, task, value);
+        elementReference = value[ASYNC_ITERATOR];
+        if ("function" === typeof elementReference)
+          return renderAsyncFragment(request, task, value, elementReference);
+        if (value instanceof Date) return "$D" + value.toJSON();
+        elementReference = getPrototypeOf(value);
+        if (
+          elementReference !== ObjectPrototype &&
+          (null === elementReference ||
+            null !== getPrototypeOf(elementReference))
+        )
+          throw Error(
+            "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
+              describeObjectForErrorMessage(parent, parentPropertyName)
+          );
+        if ("Object" !== objectName(value))
+          callWithDebugContextInDEV(request, task, function () {
+            console.error(
+              "Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s",
+              objectName(value),
+              describeObjectForErrorMessage(parent, parentPropertyName)
+            );
+          });
+        else if (!isSimpleObject(value))
+          callWithDebugContextInDEV(request, task, function () {
+            console.error(
+              "Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s",
+              describeObjectForErrorMessage(parent, parentPropertyName)
+            );
+          });
+        else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+          0 < symbols.length &&
+            callWithDebugContextInDEV(request, task, function () {
+              console.error(
+                "Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s",
+                symbols[0].description,
+                describeObjectForErrorMessage(parent, parentPropertyName)
+              );
+            });
+        }
+        return value;
+      }
+      if ("string" === typeof value)
+        return (
+          (task = TaintRegistryValues.get(value)),
+          void 0 !== task && throwTaintViolation(task.message),
+          "Z" === value[value.length - 1] &&
+          parent[parentPropertyName] instanceof Date
+            ? "$D" + value
+            : 1024 <= value.length && null !== byteLengthOfChunk
+              ? serializeLargeTextString(request, value)
+              : "$" === value[0]
+                ? "$" + value
+                : value
+        );
+      if ("boolean" === typeof value) return value;
+      if ("number" === typeof value) return serializeNumber(value);
+      if ("undefined" === typeof value) return "$undefined";
+      if ("function" === typeof value) {
+        if (isClientReference(value))
+          return serializeClientReference(
+            request,
+            parent,
+            parentPropertyName,
+            value
+          );
+        if (value.$$typeof === SERVER_REFERENCE_TAG)
+          return serializeServerReference(request, value);
+        if (
+          void 0 !== request.temporaryReferences &&
+          ((request = request.temporaryReferences.get(value)),
+          void 0 !== request)
+        )
+          return "$T" + request;
+        request = TaintRegistryObjects.get(value);
+        void 0 !== request && throwTaintViolation(request);
+        if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
+          throw Error(
+            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+          );
+        if (/^on[A-Z]/.test(parentPropertyName))
+          throw Error(
+            "Event handlers cannot be passed to Client Component props." +
+              describeObjectForErrorMessage(parent, parentPropertyName) +
+              "\nIf you need interactivity, consider converting part of this to a Client Component."
+          );
+        if (
+          jsxChildrenParents.has(parent) ||
+          (jsxPropsParents.has(parent) && "children" === parentPropertyName)
+        )
+          throw (
+            ((request = value.displayName || value.name || "Component"),
+            Error(
+              "Functions are not valid as a child of Client Components. This may happen if you return " +
+                request +
+                " instead of <" +
+                request +
+                " /> from render. Or maybe you meant to call this function rather than return it." +
+                describeObjectForErrorMessage(parent, parentPropertyName)
+            ))
+          );
+        throw Error(
+          'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
+            describeObjectForErrorMessage(parent, parentPropertyName)
+        );
+      }
+      if ("symbol" === typeof value) {
+        task = request.writtenSymbols;
+        elementReference = task.get(value);
+        if (void 0 !== elementReference)
+          return serializeByValueID(elementReference);
+        elementReference = value.description;
+        if (Symbol.for(elementReference) !== value)
+          throw Error(
+            "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
+              (value.description + ") cannot be found among global symbols.") +
+              describeObjectForErrorMessage(parent, parentPropertyName)
+          );
+        request.pendingChunks++;
+        _writtenObjects = request.nextChunkId++;
+        emitSymbolChunk(request, _writtenObjects, elementReference);
+        task.set(value, _writtenObjects);
+        return serializeByValueID(_writtenObjects);
+      }
+      if ("bigint" === typeof value)
+        return (
+          (request = TaintRegistryValues.get(value)),
+          void 0 !== request && throwTaintViolation(request.message),
+          "$n" + value.toString(10)
+        );
+      throw Error(
+        "Type " +
+          typeof value +
+          " is not supported in Client Component props." +
+          describeObjectForErrorMessage(parent, parentPropertyName)
+      );
+    }
+    function logPostpone(request, reason, task) {
+      var prevRequest = currentRequest;
+      currentRequest = null;
+      try {
+        var onPostpone = request.onPostpone;
+        null !== task
+          ? requestStorage.run(
+              void 0,
+              callWithDebugContextInDEV,
+              request,
+              task,
+              onPostpone,
+              reason
+            )
+          : requestStorage.run(void 0, onPostpone, reason);
+      } finally {
+        currentRequest = prevRequest;
+      }
+    }
+    function logRecoverableError(request, error, task) {
+      var prevRequest = currentRequest;
+      currentRequest = null;
+      try {
+        var onError = request.onError;
+        var errorDigest =
+          null !== task
+            ? requestStorage.run(
+                void 0,
+                callWithDebugContextInDEV,
+                request,
+                task,
+                onError,
+                error
+              )
+            : requestStorage.run(void 0, onError, error);
+      } finally {
+        currentRequest = prevRequest;
+      }
+      if (null != errorDigest && "string" !== typeof errorDigest)
+        throw Error(
+          'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
+            typeof errorDigest +
+            '" instead'
+        );
+      return errorDigest || "";
+    }
+    function fatalError(request, error) {
+      var onFatalError = request.onFatalError;
+      onFatalError(error);
+      cleanupTaintQueue(request);
+      null !== request.destination
+        ? ((request.status = CLOSED), request.destination.destroy(error))
+        : ((request.status = CLOSING), (request.fatalError = error));
+    }
+    function emitPostponeChunk(request, id, postponeInstance) {
+      var reason = "",
+        env = request.environmentName();
+      try {
+        reason = String(postponeInstance.message);
+        var stack = filterStackTrace(request, postponeInstance, 0);
+      } catch (x) {
+        stack = [];
+      }
+      id =
+        id.toString(16) +
+        ":P" +
+        stringify({ reason: reason, stack: stack, env: env }) +
+        "\n";
+      request.completedErrorChunks.push(id);
+    }
+    function serializeErrorValue(request, error) {
+      var env = (0, request.environmentName)();
+      try {
+        var message = String(error.message);
+        var stack = filterStackTrace(request, error, 0);
+        var errorEnv = error.environmentName;
+        "string" === typeof errorEnv && (env = errorEnv);
+      } catch (x) {
+        (message =
+          "An error occurred but serializing the error message failed."),
+          (stack = []);
+      }
+      return (
+        "$Z" +
+        outlineModel(request, {
+          message: message,
+          stack: stack,
+          env: env
+        }).toString(16)
+      );
+    }
+    function emitErrorChunk(request, id, digest, error) {
+      var env = (0, request.environmentName)();
+      try {
+        if (error instanceof Error) {
+          var message = String(error.message);
+          var stack = filterStackTrace(request, error, 0);
+          var errorEnv = error.environmentName;
+          "string" === typeof errorEnv && (env = errorEnv);
+        } else
+          (message =
+            "object" === typeof error && null !== error
+              ? describeObjectForErrorMessage(error)
+              : String(error)),
+            (stack = []);
+      } catch (x) {
+        (message =
+          "An error occurred but serializing the error message failed."),
+          (stack = []);
+      }
+      digest = { digest: digest, message: message, stack: stack, env: env };
+      id = id.toString(16) + ":E" + stringify(digest) + "\n";
+      request.completedErrorChunks.push(id);
+    }
+    function emitSymbolChunk(request, id, name) {
+      id = encodeReferenceChunk(request, id, "$S" + name);
+      request.completedImportChunks.push(id);
+    }
+    function emitModelChunk(request, id, json) {
+      id = id.toString(16) + ":" + json + "\n";
+      request.completedRegularChunks.push(id);
+    }
+    function emitDebugChunk(request, id, debugInfo) {
+      var counter = { objectLimit: 500 };
+      debugInfo = stringify(debugInfo, function (parentPropertyName, value) {
+        return renderConsoleValue(
+          request,
+          counter,
+          this,
+          parentPropertyName,
+          value
+        );
+      });
+      id = id.toString(16) + ":D" + debugInfo + "\n";
+      request.completedRegularChunks.push(id);
+    }
+    function outlineComponentInfo(request, componentInfo) {
+      if (!request.writtenObjects.has(componentInfo)) {
+        null != componentInfo.owner &&
+          outlineComponentInfo(request, componentInfo.owner);
+        var objectLimit = 10;
+        null != componentInfo.stack &&
+          (objectLimit += componentInfo.stack.length);
+        objectLimit = { objectLimit: objectLimit };
+        var componentDebugInfo = {
+          name: componentInfo.name,
+          env: componentInfo.env,
+          key: componentInfo.key,
+          owner: componentInfo.owner
+        };
+        componentDebugInfo.stack = componentInfo.stack;
+        componentDebugInfo.props = componentInfo.props;
+        objectLimit = outlineConsoleValue(
+          request,
+          objectLimit,
+          componentDebugInfo
+        );
+        request.writtenObjects.set(
+          componentInfo,
+          serializeByValueID(objectLimit)
+        );
+      }
+    }
+    function emitTypedArrayChunk(request, id, tag, typedArray) {
+      if (TaintRegistryByteLengths.has(typedArray.byteLength)) {
+        var tainted = TaintRegistryValues.get(
+          String.fromCharCode.apply(
+            String,
+            new Uint8Array(
+              typedArray.buffer,
+              typedArray.byteOffset,
+              typedArray.byteLength
+            )
+          )
+        );
+        void 0 !== tainted && throwTaintViolation(tainted.message);
+      }
+      request.pendingChunks++;
+      typedArray = new Uint8Array(
+        typedArray.buffer,
+        typedArray.byteOffset,
+        typedArray.byteLength
+      );
+      tainted = typedArray.byteLength;
+      id = id.toString(16) + ":" + tag + tainted.toString(16) + ",";
+      request.completedRegularChunks.push(id, typedArray);
+    }
+    function emitTextChunk(request, id, text) {
+      if (null === byteLengthOfChunk)
+        throw Error(
+          "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+        );
+      request.pendingChunks++;
+      var binaryLength = byteLengthOfChunk(text);
+      id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+      request.completedRegularChunks.push(id, text);
+    }
+    function renderConsoleValue(
+      request,
+      counter,
+      parent,
+      parentPropertyName,
+      value
+    ) {
+      if (null === value) return null;
+      if (value === REACT_ELEMENT_TYPE) return "$";
+      if ("object" === typeof value) {
+        if (isClientReference(value))
+          return serializeClientReference(
+            request,
+            parent,
+            parentPropertyName,
+            value
+          );
+        if (
+          void 0 !== request.temporaryReferences &&
+          ((parent = request.temporaryReferences.get(value)), void 0 !== parent)
+        )
+          return "$T" + parent;
+        parent = request.writtenObjects.get(value);
+        if (void 0 !== parent) return parent;
+        if (0 >= counter.objectLimit && !doNotLimit.has(value)) return "$Y";
+        counter.objectLimit--;
+        switch (value.$$typeof) {
+          case REACT_ELEMENT_TYPE:
+            null != value._owner && outlineComponentInfo(request, value._owner);
+            "object" === typeof value.type &&
+              null !== value.type &&
+              doNotLimit.add(value.type);
+            "object" === typeof value.key &&
+              null !== value.key &&
+              doNotLimit.add(value.key);
+            doNotLimit.add(value.props);
+            null !== value._owner && doNotLimit.add(value._owner);
+            counter = null;
+            if (null != value._debugStack)
+              for (
+                counter = filterStackTrace(request, value._debugStack, 1),
+                  doNotLimit.add(counter),
+                  request = 0;
+                request < counter.length;
+                request++
+              )
+                doNotLimit.add(counter[request]);
+            return [
+              REACT_ELEMENT_TYPE,
+              value.type,
+              value.key,
+              value.props,
+              value._owner,
+              counter,
+              value._store.validated
+            ];
+        }
+        if ("function" === typeof value.then) {
+          switch (value.status) {
+            case "fulfilled":
+              return (
+                "$@" +
+                outlineConsoleValue(request, counter, value.value).toString(16)
+              );
+            case "rejected":
+              return (
+                (counter = value.reason),
+                request.pendingChunks++,
+                (value = request.nextChunkId++),
+                "object" === typeof counter &&
+                null !== counter &&
+                counter.$$typeof === REACT_POSTPONE_TYPE
+                  ? emitPostponeChunk(request, value, counter)
+                  : emitErrorChunk(request, value, "", counter),
+                "$@" + value.toString(16)
+              );
+          }
+          return "$@";
+        }
+        if (isArrayImpl(value)) return value;
+        if (value instanceof Map) {
+          value = Array.from(value);
+          counter.objectLimit++;
+          for (parent = 0; parent < value.length; parent++) {
+            var entry = value[parent];
+            doNotLimit.add(entry);
+            parentPropertyName = entry[0];
+            entry = entry[1];
+            "object" === typeof parentPropertyName &&
+              null !== parentPropertyName &&
+              doNotLimit.add(parentPropertyName);
+            "object" === typeof entry &&
+              null !== entry &&
+              doNotLimit.add(entry);
+          }
+          return (
+            "$Q" + outlineConsoleValue(request, counter, value).toString(16)
+          );
+        }
+        if (value instanceof Set) {
+          value = Array.from(value);
+          counter.objectLimit++;
+          for (parent = 0; parent < value.length; parent++)
+            (parentPropertyName = value[parent]),
+              "object" === typeof parentPropertyName &&
+                null !== parentPropertyName &&
+                doNotLimit.add(parentPropertyName);
+          return (
+            "$W" + outlineConsoleValue(request, counter, value).toString(16)
+          );
+        }
+        return "function" === typeof FormData && value instanceof FormData
+          ? serializeFormData(request, value)
+          : value instanceof Error
+            ? serializeErrorValue(request, value)
+            : value instanceof ArrayBuffer
+              ? serializeTypedArray(request, "A", new Uint8Array(value))
+              : value instanceof Int8Array
+                ? serializeTypedArray(request, "O", value)
+                : value instanceof Uint8Array
+                  ? serializeTypedArray(request, "o", value)
+                  : value instanceof Uint8ClampedArray
+                    ? serializeTypedArray(request, "U", value)
+                    : value instanceof Int16Array
+                      ? serializeTypedArray(request, "S", value)
+                      : value instanceof Uint16Array
+                        ? serializeTypedArray(request, "s", value)
+                        : value instanceof Int32Array
+                          ? serializeTypedArray(request, "L", value)
+                          : value instanceof Uint32Array
+                            ? serializeTypedArray(request, "l", value)
+                            : value instanceof Float32Array
+                              ? serializeTypedArray(request, "G", value)
+                              : value instanceof Float64Array
+                                ? serializeTypedArray(request, "g", value)
+                                : value instanceof BigInt64Array
+                                  ? serializeTypedArray(request, "M", value)
+                                  : value instanceof BigUint64Array
+                                    ? serializeTypedArray(request, "m", value)
+                                    : value instanceof DataView
+                                      ? serializeTypedArray(request, "V", value)
+                                      : "function" === typeof Blob &&
+                                          value instanceof Blob
+                                        ? serializeBlob(request, value)
+                                        : getIteratorFn(value)
+                                          ? Array.from(value)
+                                          : value;
+      }
+      if ("string" === typeof value)
+        return "Z" === value[value.length - 1] &&
+          parent[parentPropertyName] instanceof Date
+          ? "$D" + value
+          : 1024 <= value.length
+            ? serializeLargeTextString(request, value)
+            : "$" === value[0]
+              ? "$" + value
+              : value;
+      if ("boolean" === typeof value) return value;
+      if ("number" === typeof value) return serializeNumber(value);
+      if ("undefined" === typeof value) return "$undefined";
+      if ("function" === typeof value)
+        return isClientReference(value)
+          ? serializeClientReference(request, parent, parentPropertyName, value)
+          : void 0 !== request.temporaryReferences &&
+              ((request = request.temporaryReferences.get(value)),
+              void 0 !== request)
+            ? "$T" + request
+            : "$E(" + (Function.prototype.toString.call(value) + ")");
+      if ("symbol" === typeof value) {
+        counter = request.writtenSymbols.get(value);
+        if (void 0 !== counter) return serializeByValueID(counter);
+        counter = value.description;
+        request.pendingChunks++;
+        value = request.nextChunkId++;
+        emitSymbolChunk(request, value, counter);
+        return serializeByValueID(value);
+      }
+      return "bigint" === typeof value
+        ? "$n" + value.toString(10)
+        : value instanceof Date
+          ? "$D" + value.toJSON()
+          : "unknown type " + typeof value;
+    }
+    function outlineConsoleValue(request, counter, model) {
+      function replacer(parentPropertyName, value) {
+        try {
+          return renderConsoleValue(
+            request,
+            counter,
+            this,
+            parentPropertyName,
+            value
+          );
+        } catch (x) {
+          return (
+            "Unknown Value: React could not send it from the server.\n" +
+            x.message
+          );
+        }
+      }
+      "object" === typeof model && null !== model && doNotLimit.add(model);
+      try {
+        var json = stringify(model, replacer);
+      } catch (x) {
+        json = stringify(
+          "Unknown Value: React could not send it from the server.\n" +
+            x.message
+        );
+      }
+      request.pendingChunks++;
+      model = request.nextChunkId++;
+      json = model.toString(16) + ":" + json + "\n";
+      request.completedRegularChunks.push(json);
+      return model;
+    }
+    function emitConsoleChunk(request, methodName, owner, stackTrace, args) {
+      function replacer(parentPropertyName, value) {
+        try {
+          return renderConsoleValue(
+            request,
+            counter,
+            this,
+            parentPropertyName,
+            value
+          );
+        } catch (x) {
+          return (
+            "Unknown Value: React could not send it from the server.\n" +
+            x.message
+          );
+        }
+      }
+      var counter = { objectLimit: 500 };
+      null != owner && outlineComponentInfo(request, owner);
+      var env = (0, request.environmentName)(),
+        payload = [methodName, stackTrace, owner, env];
+      payload.push.apply(payload, args);
+      try {
+        var json = stringify(payload, replacer);
+      } catch (x) {
+        json = stringify(
+          [
+            methodName,
+            stackTrace,
+            owner,
+            env,
+            "Unknown Value: React could not send it from the server.",
+            x
+          ],
+          replacer
+        );
+      }
+      request.completedRegularChunks.push(":W" + json + "\n");
+    }
+    function emitTimeOriginChunk(request, timeOrigin) {
+      request.pendingChunks++;
+      request.completedRegularChunks.push(":N" + timeOrigin + "\n");
+    }
+    function forwardDebugInfo(request, id, debugInfo) {
+      for (var i = 0; i < debugInfo.length; i++)
+        "number" === typeof debugInfo[i].time
+          ? emitTimingChunk(request, id, debugInfo[i].time)
+          : (request.pendingChunks++,
+            "string" === typeof debugInfo[i].name &&
+              outlineComponentInfo(request, debugInfo[i]),
+            emitDebugChunk(request, id, debugInfo[i]));
+    }
+    function emitTimingChunk(request, id, timestamp) {
+      request.pendingChunks++;
+      timestamp -= request.timeOrigin;
+      id = id.toString(16) + ':D{"time":' + timestamp + "}\n";
+      request.completedRegularChunks.push(id);
+    }
+    function emitChunk(request, task, value) {
+      var id = task.id;
+      "string" === typeof value && null !== byteLengthOfChunk
+        ? ((task = TaintRegistryValues.get(value)),
+          void 0 !== task && throwTaintViolation(task.message),
+          emitTextChunk(request, id, value))
+        : value instanceof ArrayBuffer
+          ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value))
+          : value instanceof Int8Array
+            ? emitTypedArrayChunk(request, id, "O", value)
+            : value instanceof Uint8Array
+              ? emitTypedArrayChunk(request, id, "o", value)
+              : value instanceof Uint8ClampedArray
+                ? emitTypedArrayChunk(request, id, "U", value)
+                : value instanceof Int16Array
+                  ? emitTypedArrayChunk(request, id, "S", value)
+                  : value instanceof Uint16Array
+                    ? emitTypedArrayChunk(request, id, "s", value)
+                    : value instanceof Int32Array
+                      ? emitTypedArrayChunk(request, id, "L", value)
+                      : value instanceof Uint32Array
+                        ? emitTypedArrayChunk(request, id, "l", value)
+                        : value instanceof Float32Array
+                          ? emitTypedArrayChunk(request, id, "G", value)
+                          : value instanceof Float64Array
+                            ? emitTypedArrayChunk(request, id, "g", value)
+                            : value instanceof BigInt64Array
+                              ? emitTypedArrayChunk(request, id, "M", value)
+                              : value instanceof BigUint64Array
+                                ? emitTypedArrayChunk(request, id, "m", value)
+                                : value instanceof DataView
+                                  ? emitTypedArrayChunk(request, id, "V", value)
+                                  : ((value = stringify(value, task.toJSON)),
+                                    emitModelChunk(request, task.id, value));
+    }
+    function erroredTask(request, task, error) {
+      task.timed && emitTimingChunk(request, task.id, performance.now());
+      request.abortableTasks.delete(task);
+      task.status = ERRORED$1;
+      if (
+        "object" === typeof error &&
+        null !== error &&
+        error.$$typeof === REACT_POSTPONE_TYPE
+      )
+        logPostpone(request, error.message, task),
+          emitPostponeChunk(request, task.id, error);
+      else {
+        var digest = logRecoverableError(request, error, task);
+        emitErrorChunk(request, task.id, digest, error);
+      }
+    }
+    function retryTask(request, task) {
+      if (task.status === PENDING$1) {
+        var prevDebugID = debugID;
+        task.status = RENDERING;
+        try {
+          modelRoot = task.model;
+          debugID = task.id;
+          var resolvedModel = renderModelDestructive(
+            request,
+            task,
+            emptyRoot,
+            "",
+            task.model
+          );
+          debugID = null;
+          modelRoot = resolvedModel;
+          task.keyPath = null;
+          task.implicitSlot = !1;
+          var currentEnv = (0, request.environmentName)();
+          currentEnv !== task.environmentName &&
+            (request.pendingChunks++,
+            emitDebugChunk(request, task.id, { env: currentEnv }));
+          task.timed && emitTimingChunk(request, task.id, performance.now());
+          if ("object" === typeof resolvedModel && null !== resolvedModel)
+            request.writtenObjects.set(
+              resolvedModel,
+              serializeByValueID(task.id)
+            ),
+              emitChunk(request, task, resolvedModel);
+          else {
+            var json = stringify(resolvedModel);
+            emitModelChunk(request, task.id, json);
+          }
+          request.abortableTasks.delete(task);
+          task.status = COMPLETED;
+        } catch (thrownValue) {
+          if (request.status === ABORTING)
+            if (
+              (request.abortableTasks.delete(task),
+              (task.status = ABORTED),
+              request.type === PRERENDER)
+            )
+              request.pendingChunks--;
+            else {
+              var model = stringify(serializeByValueID(request.fatalError));
+              emitModelChunk(request, task.id, model);
+            }
+          else {
+            var x =
+              thrownValue === SuspenseException
+                ? getSuspendedThenable()
+                : thrownValue;
+            if (
+              "object" === typeof x &&
+              null !== x &&
+              "function" === typeof x.then
+            ) {
+              task.status = PENDING$1;
+              task.thenableState = getThenableStateAfterSuspending();
+              var ping = task.ping;
+              x.then(ping, ping);
+            } else erroredTask(request, task, x);
+          }
+        } finally {
+          debugID = prevDebugID;
+        }
+      }
+    }
+    function tryStreamTask(request, task) {
+      var prevDebugID = debugID;
+      debugID = null;
+      try {
+        emitChunk(request, task, task.model);
+      } finally {
+        debugID = prevDebugID;
+      }
+    }
+    function performWork(request) {
+      var prevDispatcher = ReactSharedInternalsServer.H;
+      ReactSharedInternalsServer.H = HooksDispatcher;
+      var prevRequest = currentRequest;
+      currentRequest$1 = currentRequest = request;
+      var hadAbortableTasks = 0 < request.abortableTasks.size;
+      try {
+        var pingedTasks = request.pingedTasks;
+        request.pingedTasks = [];
+        for (var i = 0; i < pingedTasks.length; i++)
+          retryTask(request, pingedTasks[i]);
+        null !== request.destination &&
+          flushCompletedChunks(request, request.destination);
+        if (hadAbortableTasks && 0 === request.abortableTasks.size) {
+          var onAllReady = request.onAllReady;
+          onAllReady();
+        }
+      } catch (error) {
+        logRecoverableError(request, error, null), fatalError(request, error);
+      } finally {
+        (ReactSharedInternalsServer.H = prevDispatcher),
+          (currentRequest$1 = null),
+          (currentRequest = prevRequest);
+      }
+    }
+    function abortTask(task, request, errorId) {
+      task.status !== RENDERING &&
+        ((task.status = ABORTED),
+        task.timed && emitTimingChunk(request, task.id, performance.now()),
+        (errorId = serializeByValueID(errorId)),
+        (task = encodeReferenceChunk(request, task.id, errorId)),
+        request.completedErrorChunks.push(task));
+    }
+    function flushCompletedChunks(request, destination) {
+      currentView = new Uint8Array(2048);
+      writtenBytes = 0;
+      destinationHasCapacity = !0;
+      try {
+        for (
+          var importsChunks = request.completedImportChunks, i = 0;
+          i < importsChunks.length;
+          i++
+        )
+          if (
+            (request.pendingChunks--,
+            !writeChunkAndReturn(destination, importsChunks[i]))
+          ) {
+            request.destination = null;
+            i++;
+            break;
+          }
+        importsChunks.splice(0, i);
+        var hintChunks = request.completedHintChunks;
+        for (i = 0; i < hintChunks.length; i++)
+          if (!writeChunkAndReturn(destination, hintChunks[i])) {
+            request.destination = null;
+            i++;
+            break;
+          }
+        hintChunks.splice(0, i);
+        var regularChunks = request.completedRegularChunks;
+        for (i = 0; i < regularChunks.length; i++)
+          if (
+            (request.pendingChunks--,
+            !writeChunkAndReturn(destination, regularChunks[i]))
+          ) {
+            request.destination = null;
+            i++;
+            break;
+          }
+        regularChunks.splice(0, i);
+        var errorChunks = request.completedErrorChunks;
+        for (i = 0; i < errorChunks.length; i++)
+          if (
+            (request.pendingChunks--,
+            !writeChunkAndReturn(destination, errorChunks[i]))
+          ) {
+            request.destination = null;
+            i++;
+            break;
+          }
+        errorChunks.splice(0, i);
+      } finally {
+        (request.flushScheduled = !1),
+          currentView &&
+            0 < writtenBytes &&
+            destination.write(currentView.subarray(0, writtenBytes)),
+          (currentView = null),
+          (writtenBytes = 0),
+          (destinationHasCapacity = !0);
+      }
+      "function" === typeof destination.flush && destination.flush();
+      0 === request.pendingChunks &&
+        (cleanupTaintQueue(request),
+        (request.status = CLOSED),
+        destination.end(),
+        (request.destination = null));
+    }
+    function startWork(request) {
+      request.flushScheduled = null !== request.destination;
+      scheduleMicrotask(function () {
+        requestStorage.run(request, performWork, request);
+      });
+      setImmediate(function () {
+        request.status === OPENING && (request.status = 11);
+      });
+    }
+    function enqueueFlush(request) {
+      !1 === request.flushScheduled &&
+        0 === request.pingedTasks.length &&
+        null !== request.destination &&
+        ((request.flushScheduled = !0),
+        setImmediate(function () {
+          request.flushScheduled = !1;
+          var destination = request.destination;
+          destination && flushCompletedChunks(request, destination);
+        }));
+    }
+    function startFlowing(request, destination) {
+      if (request.status === CLOSING)
+        (request.status = CLOSED), destination.destroy(request.fatalError);
+      else if (request.status !== CLOSED && null === request.destination) {
+        request.destination = destination;
+        try {
+          flushCompletedChunks(request, destination);
+        } catch (error) {
+          logRecoverableError(request, error, null), fatalError(request, error);
+        }
+      }
+    }
+    function abort(request, reason) {
+      try {
+        11 >= request.status && (request.status = ABORTING);
+        var abortableTasks = request.abortableTasks;
+        if (0 < abortableTasks.size) {
+          if (request.type === PRERENDER)
+            abortableTasks.forEach(function (task) {
+              task.status !== RENDERING &&
+                ((task.status = ABORTED), request.pendingChunks--);
+            });
+          else if (
+            "object" === typeof reason &&
+            null !== reason &&
+            reason.$$typeof === REACT_POSTPONE_TYPE
+          ) {
+            logPostpone(request, reason.message, null);
+            var errorId = request.nextChunkId++;
+            request.fatalError = errorId;
+            request.pendingChunks++;
+            emitPostponeChunk(request, errorId, reason);
+            abortableTasks.forEach(function (task) {
+              return abortTask(task, request, errorId);
+            });
+          } else {
+            var error =
+                void 0 === reason
+                  ? Error(
+                      "The render was aborted by the server without a reason."
+                    )
+                  : "object" === typeof reason &&
+                      null !== reason &&
+                      "function" === typeof reason.then
+                    ? Error(
+                        "The render was aborted by the server with a promise."
+                      )
+                    : reason,
+              digest = logRecoverableError(request, error, null),
+              _errorId2 = request.nextChunkId++;
+            request.fatalError = _errorId2;
+            request.pendingChunks++;
+            emitErrorChunk(request, _errorId2, digest, error);
+            abortableTasks.forEach(function (task) {
+              return abortTask(task, request, _errorId2);
+            });
+          }
+          abortableTasks.clear();
+          var onAllReady = request.onAllReady;
+          onAllReady();
+        }
+        var abortListeners = request.abortListeners;
+        if (0 < abortListeners.size) {
+          var _error =
+            "object" === typeof reason &&
+            null !== reason &&
+            reason.$$typeof === REACT_POSTPONE_TYPE
+              ? Error("The render was aborted due to being postponed.")
+              : void 0 === reason
+                ? Error(
+                    "The render was aborted by the server without a reason."
+                  )
+                : "object" === typeof reason &&
+                    null !== reason &&
+                    "function" === typeof reason.then
+                  ? Error(
+                      "The render was aborted by the server with a promise."
+                    )
+                  : reason;
+          abortListeners.forEach(function (callback) {
+            return callback(_error);
+          });
+          abortListeners.clear();
+        }
+        null !== request.destination &&
+          flushCompletedChunks(request, request.destination);
+      } catch (error$2) {
+        logRecoverableError(request, error$2, null),
+          fatalError(request, error$2);
+      }
+    }
+    function resolveServerReference(config, id) {
+      var idx = id.lastIndexOf("#"),
+        exportName = id.slice(idx + 1);
+      id = id.slice(0, idx);
+      if (!id.startsWith(config))
+        throw Error(
+          "Attempted to load a Server Reference outside the hosted root."
+        );
+      return { specifier: id, name: exportName };
+    }
+    function preloadModule(metadata) {
+      var existingPromise = asyncModuleCache.get(metadata.specifier);
+      if (existingPromise)
+        return "fulfilled" === existingPromise.status ? null : existingPromise;
+      var modulePromise = import(metadata.specifier);
+      modulePromise.then(
+        function (value) {
+          modulePromise.status = "fulfilled";
+          modulePromise.value = value;
+        },
+        function (reason) {
+          modulePromise.status = "rejected";
+          modulePromise.reason = reason;
+        }
+      );
+      asyncModuleCache.set(metadata.specifier, modulePromise);
+      return modulePromise;
+    }
+    function requireModule(metadata) {
+      var moduleExports = asyncModuleCache.get(metadata.specifier);
+      if ("fulfilled" === moduleExports.status)
+        moduleExports = moduleExports.value;
+      else throw moduleExports.reason;
+      return moduleExports[metadata.name];
+    }
+    function Chunk(status, value, reason, response) {
+      this.status = status;
+      this.value = value;
+      this.reason = reason;
+      this._response = response;
+    }
+    function createPendingChunk(response) {
+      return new Chunk("pending", null, null, response);
+    }
+    function wakeChunk(listeners, value) {
+      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+    }
+    function triggerErrorOnChunk(chunk, error) {
+      if ("pending" !== chunk.status && "blocked" !== chunk.status)
+        chunk.reason.error(error);
+      else {
+        var listeners = chunk.reason;
+        chunk.status = "rejected";
+        chunk.reason = error;
+        null !== listeners && wakeChunk(listeners, error);
+      }
+    }
+    function resolveModelChunk(chunk, value, id) {
+      if ("pending" !== chunk.status)
+        (chunk = chunk.reason),
+          "C" === value[0]
+            ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+            : chunk.enqueueModel(value);
+      else {
+        var resolveListeners = chunk.value,
+          rejectListeners = chunk.reason;
+        chunk.status = "resolved_model";
+        chunk.value = value;
+        chunk.reason = id;
+        if (null !== resolveListeners)
+          switch ((initializeModelChunk(chunk), chunk.status)) {
+            case "fulfilled":
+              wakeChunk(resolveListeners, chunk.value);
+              break;
+            case "pending":
+            case "blocked":
+            case "cyclic":
+              if (chunk.value)
+                for (value = 0; value < resolveListeners.length; value++)
+                  chunk.value.push(resolveListeners[value]);
+              else chunk.value = resolveListeners;
+              if (chunk.reason) {
+                if (rejectListeners)
+                  for (value = 0; value < rejectListeners.length; value++)
+                    chunk.reason.push(rejectListeners[value]);
+              } else chunk.reason = rejectListeners;
+              break;
+            case "rejected":
+              rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+          }
+      }
+    }
+    function createResolvedIteratorResultChunk(response, value, done) {
+      return new Chunk(
+        "resolved_model",
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}",
+        -1,
+        response
+      );
+    }
+    function resolveIteratorResultChunk(chunk, value, done) {
+      resolveModelChunk(
+        chunk,
+        (done ? '{"done":true,"value":' : '{"done":false,"value":') +
+          value +
+          "}",
+        -1
+      );
+    }
+    function loadServerReference$1(
+      response,
+      id,
+      bound,
+      parentChunk,
+      parentObject,
+      key
+    ) {
+      var serverReference = resolveServerReference(response._bundlerConfig, id);
+      id = preloadModule(serverReference);
+      if (bound)
+        bound = Promise.all([bound, id]).then(function (_ref) {
+          _ref = _ref[0];
+          var fn = requireModule(serverReference);
+          return fn.bind.apply(fn, [null].concat(_ref));
+        });
+      else if (id)
+        bound = Promise.resolve(id).then(function () {
+          return requireModule(serverReference);
+        });
+      else return requireModule(serverReference);
+      bound.then(
+        createModelResolver(
+          parentChunk,
+          parentObject,
+          key,
+          !1,
+          response,
+          createModel,
+          []
+        ),
+        createModelReject(parentChunk)
+      );
+      return null;
+    }
+    function reviveModel(response, parentObj, parentKey, value, reference) {
+      if ("string" === typeof value)
+        return parseModelString(
+          response,
+          parentObj,
+          parentKey,
+          value,
+          reference
+        );
+      if ("object" === typeof value && null !== value)
+        if (
+          (void 0 !== reference &&
+            void 0 !== response._temporaryReferences &&
+            response._temporaryReferences.set(value, reference),
+          Array.isArray(value))
+        )
+          for (var i = 0; i < value.length; i++)
+            value[i] = reviveModel(
+              response,
+              value,
+              "" + i,
+              value[i],
+              void 0 !== reference ? reference + ":" + i : void 0
+            );
+        else
+          for (i in value)
+            hasOwnProperty.call(value, i) &&
+              ((parentObj =
+                void 0 !== reference && -1 === i.indexOf(":")
+                  ? reference + ":" + i
+                  : void 0),
+              (parentObj = reviveModel(
+                response,
+                value,
+                i,
+                value[i],
+                parentObj
+              )),
+              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
+      return value;
+    }
+    function initializeModelChunk(chunk) {
+      var prevChunk = initializingChunk,
+        prevBlocked = initializingChunkBlockedModel;
+      initializingChunk = chunk;
+      initializingChunkBlockedModel = null;
+      var rootReference =
+          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
+        resolvedModel = chunk.value;
+      chunk.status = "cyclic";
+      chunk.value = null;
+      chunk.reason = null;
+      try {
+        var rawModel = JSON.parse(resolvedModel),
+          value = reviveModel(
+            chunk._response,
+            { "": rawModel },
+            "",
+            rawModel,
+            rootReference
+          );
+        if (
+          null !== initializingChunkBlockedModel &&
+          0 < initializingChunkBlockedModel.deps
+        )
+          (initializingChunkBlockedModel.value = value),
+            (chunk.status = "blocked");
+        else {
+          var resolveListeners = chunk.value;
+          chunk.status = "fulfilled";
+          chunk.value = value;
+          null !== resolveListeners && wakeChunk(resolveListeners, value);
+        }
+      } catch (error) {
+        (chunk.status = "rejected"), (chunk.reason = error);
+      } finally {
+        (initializingChunk = prevChunk),
+          (initializingChunkBlockedModel = prevBlocked);
+      }
+    }
+    function reportGlobalError(response, error) {
+      response._closed = !0;
+      response._closedReason = error;
+      response._chunks.forEach(function (chunk) {
+        "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+      });
+    }
+    function getChunk(response, id) {
+      var chunks = response._chunks,
+        chunk = chunks.get(id);
+      chunk ||
+        ((chunk = response._formData.get(response._prefix + id)),
+        (chunk =
+          null != chunk
+            ? new Chunk("resolved_model", chunk, id, response)
+            : response._closed
+              ? new Chunk("rejected", null, response._closedReason, response)
+              : createPendingChunk(response)),
+        chunks.set(id, chunk));
+      return chunk;
+    }
+    function createModelResolver(
+      chunk,
+      parentObject,
+      key,
+      cyclic,
+      response,
+      map,
+      path
+    ) {
+      if (initializingChunkBlockedModel) {
+        var blocked = initializingChunkBlockedModel;
+        cyclic || blocked.deps++;
+      } else
+        blocked = initializingChunkBlockedModel = {
+          deps: cyclic ? 0 : 1,
+          value: null
+        };
+      return function (value) {
+        for (var i = 1; i < path.length; i++) value = value[path[i]];
+        parentObject[key] = map(response, value);
+        "" === key &&
+          null === blocked.value &&
+          (blocked.value = parentObject[key]);
+        blocked.deps--;
+        0 === blocked.deps &&
+          "blocked" === chunk.status &&
+          ((value = chunk.value),
+          (chunk.status = "fulfilled"),
+          (chunk.value = blocked.value),
+          null !== value && wakeChunk(value, blocked.value));
+      };
+    }
+    function createModelReject(chunk) {
+      return function (error) {
+        return triggerErrorOnChunk(chunk, error);
+      };
+    }
+    function getOutlinedModel(response, reference, parentObject, key, map) {
+      reference = reference.split(":");
+      var id = parseInt(reference[0], 16);
+      id = getChunk(response, id);
+      switch (id.status) {
+        case "resolved_model":
+          initializeModelChunk(id);
+      }
+      switch (id.status) {
+        case "fulfilled":
+          parentObject = id.value;
+          for (key = 1; key < reference.length; key++)
+            parentObject = parentObject[reference[key]];
+          return map(response, parentObject);
+        case "pending":
+        case "blocked":
+        case "cyclic":
+          var parentChunk = initializingChunk;
+          id.then(
+            createModelResolver(
+              parentChunk,
+              parentObject,
+              key,
+              "cyclic" === id.status,
+              response,
+              map,
+              reference
+            ),
+            createModelReject(parentChunk)
+          );
+          return null;
+        default:
+          throw id.reason;
+      }
+    }
+    function createMap(response, model) {
+      return new Map(model);
+    }
+    function createSet(response, model) {
+      return new Set(model);
+    }
+    function extractIterator(response, model) {
+      return model[Symbol.iterator]();
+    }
+    function createModel(response, model) {
+      return model;
+    }
+    function parseTypedArray(
+      response,
+      reference,
+      constructor,
+      bytesPerElement,
+      parentObject,
+      parentKey
+    ) {
+      reference = parseInt(reference.slice(2), 16);
+      reference = response._formData.get(response._prefix + reference);
+      reference =
+        constructor === ArrayBuffer
+          ? reference.arrayBuffer()
+          : reference.arrayBuffer().then(function (buffer) {
+              return new constructor(buffer);
+            });
+      bytesPerElement = initializingChunk;
+      reference.then(
+        createModelResolver(
+          bytesPerElement,
+          parentObject,
+          parentKey,
+          !1,
+          response,
+          createModel,
+          []
+        ),
+        createModelReject(bytesPerElement)
+      );
+      return null;
+    }
+    function resolveStream(response, id, stream, controller) {
+      var chunks = response._chunks;
+      stream = new Chunk("fulfilled", stream, controller, response);
+      chunks.set(id, stream);
+      response = response._formData.getAll(response._prefix + id);
+      for (id = 0; id < response.length; id++)
+        (chunks = response[id]),
+          "C" === chunks[0]
+            ? controller.close(
+                "C" === chunks ? '"$undefined"' : chunks.slice(1)
+              )
+            : controller.enqueueModel(chunks);
+    }
+    function parseReadableStream(response, reference, type) {
+      reference = parseInt(reference.slice(2), 16);
+      var controller = null;
+      type = new ReadableStream({
+        type: type,
+        start: function (c) {
+          controller = c;
+        }
+      });
+      var previousBlockedChunk = null;
+      resolveStream(response, reference, type, {
+        enqueueModel: function (json) {
+          if (null === previousBlockedChunk) {
+            var chunk = new Chunk("resolved_model", json, -1, response);
+            initializeModelChunk(chunk);
+            "fulfilled" === chunk.status
+              ? controller.enqueue(chunk.value)
+              : (chunk.then(
+                  function (v) {
+                    return controller.enqueue(v);
+                  },
+                  function (e) {
+                    return controller.error(e);
+                  }
+                ),
+                (previousBlockedChunk = chunk));
+          } else {
+            chunk = previousBlockedChunk;
+            var _chunk = createPendingChunk(response);
+            _chunk.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            );
+            previousBlockedChunk = _chunk;
+            chunk.then(function () {
+              previousBlockedChunk === _chunk && (previousBlockedChunk = null);
+              resolveModelChunk(_chunk, json, -1);
+            });
+          }
+        },
+        close: function () {
+          if (null === previousBlockedChunk) controller.close();
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.close();
+            });
+          }
+        },
+        error: function (error) {
+          if (null === previousBlockedChunk) controller.error(error);
+          else {
+            var blockedChunk = previousBlockedChunk;
+            previousBlockedChunk = null;
+            blockedChunk.then(function () {
+              return controller.error(error);
+            });
+          }
+        }
+      });
+      return type;
+    }
+    function asyncIterator() {
+      return this;
+    }
+    function createIterator(next) {
+      next = { next: next };
+      next[ASYNC_ITERATOR] = asyncIterator;
+      return next;
+    }
+    function parseAsyncIterable(response, reference, iterator) {
+      reference = parseInt(reference.slice(2), 16);
+      var buffer = [],
+        closed = !1,
+        nextWriteIndex = 0,
+        iterable = _defineProperty({}, ASYNC_ITERATOR, function () {
+          var nextReadIndex = 0;
+          return createIterator(function (arg) {
+            if (void 0 !== arg)
+              throw Error(
+                "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+              );
+            if (nextReadIndex === buffer.length) {
+              if (closed)
+                return new Chunk(
+                  "fulfilled",
+                  { done: !0, value: void 0 },
+                  null,
+                  response
+                );
+              buffer[nextReadIndex] = createPendingChunk(response);
+            }
+            return buffer[nextReadIndex++];
+          });
+        });
+      iterator = iterator ? iterable[ASYNC_ITERATOR]() : iterable;
+      resolveStream(response, reference, iterator, {
+        enqueueModel: function (value) {
+          nextWriteIndex === buffer.length
+            ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                response,
+                value,
+                !1
+              ))
+            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+          nextWriteIndex++;
+        },
+        close: function (value) {
+          closed = !0;
+          nextWriteIndex === buffer.length
+            ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+                response,
+                value,
+                !0
+              ))
+            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+          for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+            resolveIteratorResultChunk(
+              buffer[nextWriteIndex++],
+              '"$undefined"',
+              !0
+            );
+        },
+        error: function (error) {
+          closed = !0;
+          for (
+            nextWriteIndex === buffer.length &&
+            (buffer[nextWriteIndex] = createPendingChunk(response));
+            nextWriteIndex < buffer.length;
+
+          )
+            triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+        }
+      });
+      return iterator;
+    }
+    function parseModelString(response, obj, key, value, reference) {
+      if ("$" === value[0]) {
+        switch (value[1]) {
+          case "$":
+            return value.slice(1);
+          case "@":
+            return (
+              (obj = parseInt(value.slice(2), 16)), getChunk(response, obj)
+            );
+          case "F":
+            return (
+              (value = value.slice(2)),
+              (value = getOutlinedModel(
+                response,
+                value,
+                obj,
+                key,
+                createModel
+              )),
+              loadServerReference$1(
+                response,
+                value.id,
+                value.bound,
+                initializingChunk,
+                obj,
+                key
+              )
+            );
+          case "T":
+            if (
+              void 0 === reference ||
+              void 0 === response._temporaryReferences
+            )
+              throw Error(
+                "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+              );
+            return createTemporaryReference(
+              response._temporaryReferences,
+              reference
+            );
+          case "Q":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, obj, key, createMap)
+            );
+          case "W":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, obj, key, createSet)
+            );
+          case "K":
+            obj = value.slice(2);
+            var formPrefix = response._prefix + obj + "_",
+              data = new FormData();
+            response._formData.forEach(function (entry, entryKey) {
+              entryKey.startsWith(formPrefix) &&
+                data.append(entryKey.slice(formPrefix.length), entry);
+            });
+            return data;
+          case "i":
+            return (
+              (value = value.slice(2)),
+              getOutlinedModel(response, value, obj, key, extractIterator)
+            );
+          case "I":
+            return Infinity;
+          case "-":
+            return "$-0" === value ? -0 : -Infinity;
+          case "N":
+            return NaN;
+          case "u":
+            return;
+          case "D":
+            return new Date(Date.parse(value.slice(2)));
+          case "n":
+            return BigInt(value.slice(2));
+        }
+        switch (value[1]) {
+          case "A":
+            return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
+          case "O":
+            return parseTypedArray(response, value, Int8Array, 1, obj, key);
+          case "o":
+            return parseTypedArray(response, value, Uint8Array, 1, obj, key);
+          case "U":
+            return parseTypedArray(
+              response,
+              value,
+              Uint8ClampedArray,
+              1,
+              obj,
+              key
+            );
+          case "S":
+            return parseTypedArray(response, value, Int16Array, 2, obj, key);
+          case "s":
+            return parseTypedArray(response, value, Uint16Array, 2, obj, key);
+          case "L":
+            return parseTypedArray(response, value, Int32Array, 4, obj, key);
+          case "l":
+            return parseTypedArray(response, value, Uint32Array, 4, obj, key);
+          case "G":
+            return parseTypedArray(response, value, Float32Array, 4, obj, key);
+          case "g":
+            return parseTypedArray(response, value, Float64Array, 8, obj, key);
+          case "M":
+            return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
+          case "m":
+            return parseTypedArray(
+              response,
+              value,
+              BigUint64Array,
+              8,
+              obj,
+              key
+            );
+          case "V":
+            return parseTypedArray(response, value, DataView, 1, obj, key);
+          case "B":
+            return (
+              (obj = parseInt(value.slice(2), 16)),
+              response._formData.get(response._prefix + obj)
+            );
+        }
+        switch (value[1]) {
+          case "R":
+            return parseReadableStream(response, value, void 0);
+          case "r":
+            return parseReadableStream(response, value, "bytes");
+          case "X":
+            return parseAsyncIterable(response, value, !1);
+          case "x":
+            return parseAsyncIterable(response, value, !0);
+        }
+        value = value.slice(1);
+        return getOutlinedModel(response, value, obj, key, createModel);
+      }
+      return value;
+    }
+    function createResponse(
+      bundlerConfig,
+      formFieldPrefix,
+      temporaryReferences
+    ) {
+      var backingFormData =
+          3 < arguments.length && void 0 !== arguments[3]
+            ? arguments[3]
+            : new FormData(),
+        chunks = new Map();
+      return {
+        _bundlerConfig: bundlerConfig,
+        _prefix: formFieldPrefix,
+        _formData: backingFormData,
+        _chunks: chunks,
+        _closed: !1,
+        _closedReason: null,
+        _temporaryReferences: temporaryReferences
+      };
+    }
+    function resolveField(response, key, value) {
+      response._formData.append(key, value);
+      var prefix = response._prefix;
+      key.startsWith(prefix) &&
+        ((response = response._chunks),
+        (key = +key.slice(prefix.length)),
+        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
+    }
+    function close(response) {
+      reportGlobalError(response, Error("Connection closed."));
+    }
+    function loadServerReference(bundlerConfig, id, bound) {
+      var serverReference = resolveServerReference(bundlerConfig, id);
+      bundlerConfig = preloadModule(serverReference);
+      return bound
+        ? Promise.all([bound, bundlerConfig]).then(function (_ref) {
+            _ref = _ref[0];
+            var fn = requireModule(serverReference);
+            return fn.bind.apply(fn, [null].concat(_ref));
+          })
+        : bundlerConfig
+          ? Promise.resolve(bundlerConfig).then(function () {
+              return requireModule(serverReference);
+            })
+          : Promise.resolve(requireModule(serverReference));
+    }
+    function decodeBoundActionMetaData(body, serverManifest, formFieldPrefix) {
+      body = createResponse(serverManifest, formFieldPrefix, void 0, body);
+      close(body);
+      body = getChunk(body, 0);
+      body.then(function () {});
+      if ("fulfilled" !== body.status) throw body.reason;
+      return body.value;
+    }
+    function createDrainHandler(destination, request) {
+      return function () {
+        return startFlowing(request, destination);
+      };
+    }
+    function createCancelHandler(request, reason) {
+      return function () {
+        request.destination = null;
+        abort(request, Error(reason));
+      };
+    }
+    function createFakeWritable(readable) {
+      return {
+        write: function (chunk) {
+          return readable.push(chunk);
+        },
+        end: function () {
+          readable.push(null);
+        },
+        destroy: function (error) {
+          readable.destroy(error);
+        }
+      };
+    }
+    var stream = require("stream"),
+      util = require("util");
+    require("crypto");
+    var async_hooks = require("async_hooks"),
+      ReactDOM = require("react-dom"),
+      React = require("react"),
+      scheduleMicrotask = queueMicrotask,
+      currentView = null,
+      writtenBytes = 0,
+      destinationHasCapacity = !0,
+      textEncoder = new util.TextEncoder(),
+      CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
+      SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+      FunctionBind = Function.prototype.bind,
+      ArraySlice = Array.prototype.slice,
+      ReactDOMSharedInternals =
+        ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+      previousDispatcher = ReactDOMSharedInternals.d;
+    ReactDOMSharedInternals.d = {
+      f: previousDispatcher.f,
+      r: previousDispatcher.r,
+      D: function (href) {
+        if ("string" === typeof href && href) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "D|" + href;
+            hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+          } else previousDispatcher.D(href);
+        }
+      },
+      C: function (href, crossOrigin) {
+        if ("string" === typeof href) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key =
+                "C|" +
+                (null == crossOrigin ? "null" : crossOrigin) +
+                "|" +
+                href;
+            hints.has(key) ||
+              (hints.add(key),
+              "string" === typeof crossOrigin
+                ? emitHint(request, "C", [href, crossOrigin])
+                : emitHint(request, "C", href));
+          } else previousDispatcher.C(href, crossOrigin);
+        }
+      },
+      L: function (href, as, options) {
+        if ("string" === typeof href) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "L";
+            if ("image" === as && options) {
+              var imageSrcSet = options.imageSrcSet,
+                imageSizes = options.imageSizes,
+                uniquePart = "";
+              "string" === typeof imageSrcSet && "" !== imageSrcSet
+                ? ((uniquePart += "[" + imageSrcSet + "]"),
+                  "string" === typeof imageSizes &&
+                    (uniquePart += "[" + imageSizes + "]"))
+                : (uniquePart += "[][]" + href);
+              key += "[image]" + uniquePart;
+            } else key += "[" + as + "]" + href;
+            hints.has(key) ||
+              (hints.add(key),
+              (options = trimOptions(options))
+                ? emitHint(request, "L", [href, as, options])
+                : emitHint(request, "L", [href, as]));
+          } else previousDispatcher.L(href, as, options);
+        }
+      },
+      m: function (href, options) {
+        if ("string" === typeof href) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "m|" + href;
+            if (hints.has(key)) return;
+            hints.add(key);
+            return (options = trimOptions(options))
+              ? emitHint(request, "m", [href, options])
+              : emitHint(request, "m", href);
+          }
+          previousDispatcher.m(href, options);
+        }
+      },
+      X: function (src, options) {
+        if ("string" === typeof src) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "X|" + src;
+            if (hints.has(key)) return;
+            hints.add(key);
+            return (options = trimOptions(options))
+              ? emitHint(request, "X", [src, options])
+              : emitHint(request, "X", src);
+          }
+          previousDispatcher.X(src, options);
+        }
+      },
+      S: function (href, precedence, options) {
+        if ("string" === typeof href) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "S|" + href;
+            if (hints.has(key)) return;
+            hints.add(key);
+            return (options = trimOptions(options))
+              ? emitHint(request, "S", [
+                  href,
+                  "string" === typeof precedence ? precedence : 0,
+                  options
+                ])
+              : "string" === typeof precedence
+                ? emitHint(request, "S", [href, precedence])
+                : emitHint(request, "S", href);
+          }
+          previousDispatcher.S(href, precedence, options);
+        }
+      },
+      M: function (src, options) {
+        if ("string" === typeof src) {
+          var request = resolveRequest();
+          if (request) {
+            var hints = request.hints,
+              key = "M|" + src;
+            if (hints.has(key)) return;
+            hints.add(key);
+            return (options = trimOptions(options))
+              ? emitHint(request, "M", [src, options])
+              : emitHint(request, "M", src);
+          }
+          previousDispatcher.M(src, options);
+        }
+      }
+    };
+    var frameRegExp =
+        /^ {3} at (?:(.+) \((?:(.+):(\d+):(\d+)|<anonymous>)\)|(?:async )?(.+):(\d+):(\d+)|<anonymous>)$/,
+      requestStorage = new async_hooks.AsyncLocalStorage(),
+      componentStorage = new async_hooks.AsyncLocalStorage(),
+      TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+      proxyHandlers = {
+        get: function (target, name) {
+          switch (name) {
+            case "$$typeof":
+              return target.$$typeof;
+            case "name":
+              return;
+            case "displayName":
+              return;
+            case "defaultProps":
+              return;
+            case "toJSON":
+              return;
+            case Symbol.toPrimitive:
+              return Object.prototype[Symbol.toPrimitive];
+            case Symbol.toStringTag:
+              return Object.prototype[Symbol.toStringTag];
+            case "Provider":
+              throw Error(
+                "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+              );
+          }
+          throw Error(
+            "Cannot access " +
+              String(name) +
+              " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+          );
+        },
+        set: function () {
+          throw Error(
+            "Cannot assign to a temporary client reference from a server module."
+          );
+        }
+      },
+      REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
+      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+      REACT_MEMO_TYPE = Symbol.for("react.memo"),
+      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+      REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+      REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+      REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
+      ASYNC_ITERATOR = Symbol.asyncIterator,
+      SuspenseException = Error(
+        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+      ),
+      suspendedThenable = null,
+      currentRequest$1 = null,
+      thenableIndexCounter = 0,
+      thenableState = null,
+      currentComponentDebugInfo = null,
+      HooksDispatcher = {
+        useMemo: function (nextCreate) {
+          return nextCreate();
+        },
+        useCallback: function (callback) {
+          return callback;
+        },
+        useDebugValue: function () {},
+        useDeferredValue: unsupportedHook,
+        useTransition: unsupportedHook,
+        readContext: unsupportedContext,
+        useContext: unsupportedContext,
+        useReducer: unsupportedHook,
+        useRef: unsupportedHook,
+        useState: unsupportedHook,
+        useInsertionEffect: unsupportedHook,
+        useLayoutEffect: unsupportedHook,
+        useImperativeHandle: unsupportedHook,
+        useEffect: unsupportedHook,
+        useId: function () {
+          if (null === currentRequest$1)
+            throw Error("useId can only be used while React is rendering");
+          var id = currentRequest$1.identifierCount++;
+          return (
+            ":" +
+            currentRequest$1.identifierPrefix +
+            "S" +
+            id.toString(32) +
+            ":"
+          );
+        },
+        useHostTransitionStatus: unsupportedHook,
+        useOptimistic: unsupportedHook,
+        useFormState: unsupportedHook,
+        useActionState: unsupportedHook,
+        useSyncExternalStore: unsupportedHook,
+        useCacheRefresh: function () {
+          return unsupportedRefresh;
+        },
+        useMemoCache: function (size) {
+          for (var data = Array(size), i = 0; i < size; i++)
+            data[i] = REACT_MEMO_CACHE_SENTINEL;
+          return data;
+        },
+        use: function (usable) {
+          if (
+            (null !== usable && "object" === typeof usable) ||
+            "function" === typeof usable
+          ) {
+            if ("function" === typeof usable.then) {
+              var index = thenableIndexCounter;
+              thenableIndexCounter += 1;
+              null === thenableState && (thenableState = []);
+              return trackUsedThenable(thenableState, usable, index);
+            }
+            usable.$$typeof === REACT_CONTEXT_TYPE && unsupportedContext();
+          }
+          if (isClientReference(usable)) {
+            if (
+              null != usable.value &&
+              usable.value.$$typeof === REACT_CONTEXT_TYPE
+            )
+              throw Error(
+                "Cannot read a Client Context from a Server Component."
+              );
+            throw Error("Cannot use() an already resolved Client Reference.");
+          }
+          throw Error(
+            "An unsupported type was passed to use(): " + String(usable)
+          );
+        }
+      },
+      currentOwner = null,
+      DefaultAsyncDispatcher = {
+        getCacheForType: function (resourceType) {
+          var cache = (cache = resolveRequest()) ? cache.cache : new Map();
+          var entry = cache.get(resourceType);
+          void 0 === entry &&
+            ((entry = resourceType()), cache.set(resourceType, entry));
+          return entry;
+        }
+      };
+    DefaultAsyncDispatcher.getOwner = resolveOwner;
+    var ReactSharedInternalsServer =
+      React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+    if (!ReactSharedInternalsServer)
+      throw Error(
+        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+      );
+    var prefix, suffix;
+    new ("function" === typeof WeakMap ? WeakMap : Map)();
+    var callComponent = {
+        "react-stack-bottom-frame": function (
+          Component,
+          props,
+          componentDebugInfo
+        ) {
+          currentOwner = componentDebugInfo;
+          try {
+            return Component(props, void 0);
+          } finally {
+            currentOwner = null;
+          }
+        }
+      },
+      callComponentInDEV =
+        callComponent["react-stack-bottom-frame"].bind(callComponent),
+      callLazyInit = {
+        "react-stack-bottom-frame": function (lazy) {
+          var init = lazy._init;
+          return init(lazy._payload);
+        }
+      },
+      callLazyInitInDEV =
+        callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
+      callIterator = {
+        "react-stack-bottom-frame": function (iterator, progress, error) {
+          iterator.next().then(progress, error);
+        }
+      },
+      callIteratorInDEV =
+        callIterator["react-stack-bottom-frame"].bind(callIterator),
+      isArrayImpl = Array.isArray,
+      getPrototypeOf = Object.getPrototypeOf,
+      jsxPropsParents = new WeakMap(),
+      jsxChildrenParents = new WeakMap(),
+      CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference"),
+      doNotLimit = new WeakSet();
+    (function () {
+      async_hooks
+        .createHook({
+          init: function () {},
+          promiseResolve: function () {
+            async_hooks.executionAsyncId();
+          },
+          destroy: function () {}
+        })
+        .enable();
+    })();
+    "object" === typeof console &&
+      null !== console &&
+      (patchConsole(console, "assert"),
+      patchConsole(console, "debug"),
+      patchConsole(console, "dir"),
+      patchConsole(console, "dirxml"),
+      patchConsole(console, "error"),
+      patchConsole(console, "group"),
+      patchConsole(console, "groupCollapsed"),
+      patchConsole(console, "groupEnd"),
+      patchConsole(console, "info"),
+      patchConsole(console, "log"),
+      patchConsole(console, "table"),
+      patchConsole(console, "trace"),
+      patchConsole(console, "warn"));
+    var ObjectPrototype = Object.prototype,
+      stringify = JSON.stringify,
+      PENDING$1 = 0,
+      COMPLETED = 1,
+      ABORTED = 3,
+      ERRORED$1 = 4,
+      RENDERING = 5,
+      OPENING = 10,
+      ABORTING = 12,
+      CLOSING = 13,
+      CLOSED = 14,
+      PRERENDER = 21,
+      TaintRegistryObjects = ReactSharedInternalsServer.TaintRegistryObjects,
+      TaintRegistryValues = ReactSharedInternalsServer.TaintRegistryValues,
+      TaintRegistryByteLengths =
+        ReactSharedInternalsServer.TaintRegistryByteLengths,
+      TaintRegistryPendingRequests =
+        ReactSharedInternalsServer.TaintRegistryPendingRequests,
+      currentRequest = null,
+      debugID = null,
+      modelRoot = !1,
+      emptyRoot = {},
+      asyncModuleCache = new Map(),
+      hasOwnProperty = Object.prototype.hasOwnProperty;
+    Chunk.prototype = Object.create(Promise.prototype);
+    Chunk.prototype.then = function (resolve, reject) {
+      switch (this.status) {
+        case "resolved_model":
+          initializeModelChunk(this);
+      }
+      switch (this.status) {
+        case "fulfilled":
+          resolve(this.value);
+          break;
+        case "pending":
+        case "blocked":
+        case "cyclic":
+          resolve &&
+            (null === this.value && (this.value = []),
+            this.value.push(resolve));
+          reject &&
+            (null === this.reason && (this.reason = []),
+            this.reason.push(reject));
+          break;
+        default:
+          reject(this.reason);
+      }
+    };
+    var initializingChunk = null,
+      initializingChunkBlockedModel = null;
+    exports.createTemporaryReferenceSet = function () {
+      return new WeakMap();
+    };
+    exports.decodeAction = function (body, serverManifest) {
+      var formData = new FormData(),
+        action = null;
+      body.forEach(function (value, key) {
+        key.startsWith("$ACTION_")
+          ? key.startsWith("$ACTION_REF_")
+            ? ((value = "$ACTION_" + key.slice(12) + ":"),
+              (value = decodeBoundActionMetaData(body, serverManifest, value)),
+              (action = loadServerReference(
+                serverManifest,
+                value.id,
+                value.bound
+              )))
+            : key.startsWith("$ACTION_ID_") &&
+              ((value = key.slice(11)),
+              (action = loadServerReference(serverManifest, value, null)))
+          : formData.append(key, value);
+      });
+      return null === action
+        ? null
+        : action.then(function (fn) {
+            return fn.bind(null, formData);
+          });
+    };
+    exports.decodeFormState = function (actionResult, body, serverManifest) {
+      var keyPath = body.get("$ACTION_KEY");
+      if ("string" !== typeof keyPath) return Promise.resolve(null);
+      var metaData = null;
+      body.forEach(function (value, key) {
+        key.startsWith("$ACTION_REF_") &&
+          ((value = "$ACTION_" + key.slice(12) + ":"),
+          (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
+      });
+      if (null === metaData) return Promise.resolve(null);
+      var referenceId = metaData.id;
+      return Promise.resolve(metaData.bound).then(function (bound) {
+        return null === bound
+          ? null
+          : [actionResult, keyPath, referenceId, bound.length - 1];
+      });
+    };
+    exports.decodeReply = function (body, moduleBasePath, options) {
+      if ("string" === typeof body) {
+        var form = new FormData();
+        form.append("0", body);
+        body = form;
+      }
+      body = createResponse(
+        moduleBasePath,
+        "",
+        options ? options.temporaryReferences : void 0,
+        body
+      );
+      moduleBasePath = getChunk(body, 0);
+      close(body);
+      return moduleBasePath;
+    };
+    exports.decodeReplyFromBusboy = function (
+      busboyStream,
+      moduleBasePath,
+      options
+    ) {
+      var response = createResponse(
+          moduleBasePath,
+          "",
+          options ? options.temporaryReferences : void 0
+        ),
+        pendingFiles = 0,
+        queuedFields = [];
+      busboyStream.on("field", function (name, value) {
+        0 < pendingFiles
+          ? queuedFields.push(name, value)
+          : resolveField(response, name, value);
+      });
+      busboyStream.on("file", function (name, value, _ref) {
+        var filename = _ref.filename,
+          mimeType = _ref.mimeType;
+        if ("base64" === _ref.encoding.toLowerCase())
+          throw Error(
+            "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+          );
+        pendingFiles++;
+        var JSCompiler_object_inline_chunks_155 = [];
+        value.on("data", function (chunk) {
+          JSCompiler_object_inline_chunks_155.push(chunk);
+        });
+        value.on("end", function () {
+          var blob = new Blob(JSCompiler_object_inline_chunks_155, {
+            type: mimeType
+          });
+          response._formData.append(name, blob, filename);
+          pendingFiles--;
+          if (0 === pendingFiles) {
+            for (blob = 0; blob < queuedFields.length; blob += 2)
+              resolveField(
+                response,
+                queuedFields[blob],
+                queuedFields[blob + 1]
+              );
+            queuedFields.length = 0;
+          }
+        });
+      });
+      busboyStream.on("finish", function () {
+        close(response);
+      });
+      busboyStream.on("error", function (err) {
+        reportGlobalError(response, err);
+      });
+      return getChunk(response, 0);
+    };
+    exports.registerClientReference = function (
+      proxyImplementation,
+      id,
+      exportName
+    ) {
+      return Object.defineProperties(proxyImplementation, {
+        $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
+        $$id: { value: id + "#" + exportName }
+      });
+    };
+    exports.registerServerReference = function (reference, id, exportName) {
+      return Object.defineProperties(reference, {
+        $$typeof: { value: SERVER_REFERENCE_TAG },
+        $$id: { value: id + "#" + exportName, configurable: !0 },
+        $$bound: { value: null, configurable: !0 },
+        $$location: { value: Error("react-stack-top-frame"), configurable: !0 },
+        bind: { value: bind, configurable: !0 }
+      });
+    };
+    exports.renderToPipeableStream = function (model, moduleBasePath, options) {
+      var request = new RequestInstance(
+          20,
+          model,
+          moduleBasePath,
+          options ? options.onError : void 0,
+          options ? options.identifierPrefix : void 0,
+          options ? options.onPostpone : void 0,
+          options ? options.temporaryReferences : void 0,
+          options ? options.environmentName : void 0,
+          options ? options.filterStackFrame : void 0,
+          noop,
+          noop
+        ),
+        hasStartedFlowing = !1;
+      startWork(request);
+      return {
+        pipe: function (destination) {
+          if (hasStartedFlowing)
+            throw Error(
+              "React currently only supports piping to one writable stream."
+            );
+          hasStartedFlowing = !0;
+          startFlowing(request, destination);
+          destination.on("drain", createDrainHandler(destination, request));
+          destination.on(
+            "error",
+            createCancelHandler(
+              request,
+              "The destination stream errored while writing data."
+            )
+          );
+          destination.on(
+            "close",
+            createCancelHandler(request, "The destination stream closed early.")
+          );
+          return destination;
+        },
+        abort: function (reason) {
+          abort(request, reason);
+        }
+      };
+    };
+    exports.unstable_prerenderToNodeStream = function (
+      model,
+      moduleBasePath,
+      options
+    ) {
+      return new Promise(function (resolve, reject) {
+        var request = new RequestInstance(
+          PRERENDER,
+          model,
+          moduleBasePath,
+          options ? options.onError : void 0,
+          options ? options.identifierPrefix : void 0,
+          options ? options.onPostpone : void 0,
+          options ? options.temporaryReferences : void 0,
+          options ? options.environmentName : void 0,
+          options ? options.filterStackFrame : void 0,
+          function () {
+            var readable = new stream.Readable({
+                read: function () {
+                  startFlowing(request, writable);
+                }
+              }),
+              writable = createFakeWritable(readable);
+            resolve({ prelude: readable });
+          },
+          reject
+        );
+        if (options && options.signal) {
+          var signal = options.signal;
+          if (signal.aborted) abort(request, signal.reason);
+          else {
+            var listener = function () {
+              abort(request, signal.reason);
+              signal.removeEventListener("abort", listener);
+            };
+            signal.addEventListener("abort", listener);
+          }
+        }
+        startWork(request);
+      });
+    };
+  })();
diff --git a/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.production.js b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.production.js
new file mode 100644
index 0000000..da3e97e
--- /dev/null
+++ b/node_modules/react-server-dom-esm/cjs/react-server-dom-esm-server.node.production.js
@@ -0,0 +1,2821 @@
+/**
+ * @license React
+ * react-server-dom-esm-server.node.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+"use strict";
+var stream = require("stream"),
+  util = require("util");
+require("crypto");
+var async_hooks = require("async_hooks"),
+  ReactDOM = require("react-dom"),
+  React = require("react"),
+  scheduleMicrotask = queueMicrotask,
+  currentView = null,
+  writtenBytes = 0,
+  destinationHasCapacity = !0;
+function writeToDestination(destination, view) {
+  destination = destination.write(view);
+  destinationHasCapacity = destinationHasCapacity && destination;
+}
+function writeChunkAndReturn(destination, chunk) {
+  if ("string" === typeof chunk) {
+    if (0 !== chunk.length)
+      if (2048 < 3 * chunk.length)
+        0 < writtenBytes &&
+          (writeToDestination(
+            destination,
+            currentView.subarray(0, writtenBytes)
+          ),
+          (currentView = new Uint8Array(2048)),
+          (writtenBytes = 0)),
+          writeToDestination(destination, chunk);
+      else {
+        var target = currentView;
+        0 < writtenBytes && (target = currentView.subarray(writtenBytes));
+        target = textEncoder.encodeInto(chunk, target);
+        var read = target.read;
+        writtenBytes += target.written;
+        read < chunk.length &&
+          (writeToDestination(
+            destination,
+            currentView.subarray(0, writtenBytes)
+          ),
+          (currentView = new Uint8Array(2048)),
+          (writtenBytes = textEncoder.encodeInto(
+            chunk.slice(read),
+            currentView
+          ).written));
+        2048 === writtenBytes &&
+          (writeToDestination(destination, currentView),
+          (currentView = new Uint8Array(2048)),
+          (writtenBytes = 0));
+      }
+  } else
+    0 !== chunk.byteLength &&
+      (2048 < chunk.byteLength
+        ? (0 < writtenBytes &&
+            (writeToDestination(
+              destination,
+              currentView.subarray(0, writtenBytes)
+            ),
+            (currentView = new Uint8Array(2048)),
+            (writtenBytes = 0)),
+          writeToDestination(destination, chunk))
+        : ((target = currentView.length - writtenBytes),
+          target < chunk.byteLength &&
+            (0 === target
+              ? writeToDestination(destination, currentView)
+              : (currentView.set(chunk.subarray(0, target), writtenBytes),
+                (writtenBytes += target),
+                writeToDestination(destination, currentView),
+                (chunk = chunk.subarray(target))),
+            (currentView = new Uint8Array(2048)),
+            (writtenBytes = 0)),
+          currentView.set(chunk, writtenBytes),
+          (writtenBytes += chunk.byteLength),
+          2048 === writtenBytes &&
+            (writeToDestination(destination, currentView),
+            (currentView = new Uint8Array(2048)),
+            (writtenBytes = 0))));
+  return destinationHasCapacity;
+}
+var textEncoder = new util.TextEncoder();
+function byteLengthOfChunk(chunk) {
+  return "string" === typeof chunk
+    ? Buffer.byteLength(chunk, "utf8")
+    : chunk.byteLength;
+}
+var CLIENT_REFERENCE_TAG$1 = Symbol.for("react.client.reference"),
+  SERVER_REFERENCE_TAG = Symbol.for("react.server.reference"),
+  FunctionBind = Function.prototype.bind,
+  ArraySlice = Array.prototype.slice;
+function bind() {
+  var newFn = FunctionBind.apply(this, arguments);
+  if (this.$$typeof === SERVER_REFERENCE_TAG) {
+    var args = ArraySlice.call(arguments, 1),
+      $$typeof = { value: SERVER_REFERENCE_TAG },
+      $$id = { value: this.$$id };
+    args = { value: this.$$bound ? this.$$bound.concat(args) : args };
+    return Object.defineProperties(newFn, {
+      $$typeof: $$typeof,
+      $$id: $$id,
+      $$bound: args,
+      bind: { value: bind, configurable: !0 }
+    });
+  }
+  return newFn;
+}
+var ReactDOMSharedInternals =
+    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
+  previousDispatcher = ReactDOMSharedInternals.d;
+ReactDOMSharedInternals.d = {
+  f: previousDispatcher.f,
+  r: previousDispatcher.r,
+  D: prefetchDNS,
+  C: preconnect,
+  L: preload,
+  m: preloadModule$1,
+  X: preinitScript,
+  S: preinitStyle,
+  M: preinitModuleScript
+};
+function prefetchDNS(href) {
+  if ("string" === typeof href && href) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "D|" + href;
+      hints.has(key) || (hints.add(key), emitHint(request, "D", href));
+    } else previousDispatcher.D(href);
+  }
+}
+function preconnect(href, crossOrigin) {
+  if ("string" === typeof href) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "C|" + (null == crossOrigin ? "null" : crossOrigin) + "|" + href;
+      hints.has(key) ||
+        (hints.add(key),
+        "string" === typeof crossOrigin
+          ? emitHint(request, "C", [href, crossOrigin])
+          : emitHint(request, "C", href));
+    } else previousDispatcher.C(href, crossOrigin);
+  }
+}
+function preload(href, as, options) {
+  if ("string" === typeof href) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "L";
+      if ("image" === as && options) {
+        var imageSrcSet = options.imageSrcSet,
+          imageSizes = options.imageSizes,
+          uniquePart = "";
+        "string" === typeof imageSrcSet && "" !== imageSrcSet
+          ? ((uniquePart += "[" + imageSrcSet + "]"),
+            "string" === typeof imageSizes &&
+              (uniquePart += "[" + imageSizes + "]"))
+          : (uniquePart += "[][]" + href);
+        key += "[image]" + uniquePart;
+      } else key += "[" + as + "]" + href;
+      hints.has(key) ||
+        (hints.add(key),
+        (options = trimOptions(options))
+          ? emitHint(request, "L", [href, as, options])
+          : emitHint(request, "L", [href, as]));
+    } else previousDispatcher.L(href, as, options);
+  }
+}
+function preloadModule$1(href, options) {
+  if ("string" === typeof href) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "m|" + href;
+      if (hints.has(key)) return;
+      hints.add(key);
+      return (options = trimOptions(options))
+        ? emitHint(request, "m", [href, options])
+        : emitHint(request, "m", href);
+    }
+    previousDispatcher.m(href, options);
+  }
+}
+function preinitStyle(href, precedence, options) {
+  if ("string" === typeof href) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "S|" + href;
+      if (hints.has(key)) return;
+      hints.add(key);
+      return (options = trimOptions(options))
+        ? emitHint(request, "S", [
+            href,
+            "string" === typeof precedence ? precedence : 0,
+            options
+          ])
+        : "string" === typeof precedence
+          ? emitHint(request, "S", [href, precedence])
+          : emitHint(request, "S", href);
+    }
+    previousDispatcher.S(href, precedence, options);
+  }
+}
+function preinitScript(src, options) {
+  if ("string" === typeof src) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "X|" + src;
+      if (hints.has(key)) return;
+      hints.add(key);
+      return (options = trimOptions(options))
+        ? emitHint(request, "X", [src, options])
+        : emitHint(request, "X", src);
+    }
+    previousDispatcher.X(src, options);
+  }
+}
+function preinitModuleScript(src, options) {
+  if ("string" === typeof src) {
+    var request = resolveRequest();
+    if (request) {
+      var hints = request.hints,
+        key = "M|" + src;
+      if (hints.has(key)) return;
+      hints.add(key);
+      return (options = trimOptions(options))
+        ? emitHint(request, "M", [src, options])
+        : emitHint(request, "M", src);
+    }
+    previousDispatcher.M(src, options);
+  }
+}
+function trimOptions(options) {
+  if (null == options) return null;
+  var hasProperties = !1,
+    trimmed = {},
+    key;
+  for (key in options)
+    null != options[key] &&
+      ((hasProperties = !0), (trimmed[key] = options[key]));
+  return hasProperties ? trimmed : null;
+}
+var requestStorage = new async_hooks.AsyncLocalStorage(),
+  TEMPORARY_REFERENCE_TAG = Symbol.for("react.temporary.reference"),
+  proxyHandlers = {
+    get: function (target, name) {
+      switch (name) {
+        case "$$typeof":
+          return target.$$typeof;
+        case "name":
+          return;
+        case "displayName":
+          return;
+        case "defaultProps":
+          return;
+        case "toJSON":
+          return;
+        case Symbol.toPrimitive:
+          return Object.prototype[Symbol.toPrimitive];
+        case Symbol.toStringTag:
+          return Object.prototype[Symbol.toStringTag];
+        case "Provider":
+          throw Error(
+            "Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider."
+          );
+      }
+      throw Error(
+        "Cannot access " +
+          String(name) +
+          " on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client."
+      );
+    },
+    set: function () {
+      throw Error(
+        "Cannot assign to a temporary client reference from a server module."
+      );
+    }
+  };
+function createTemporaryReference(temporaryReferences, id) {
+  var reference = Object.defineProperties(
+    function () {
+      throw Error(
+        "Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."
+      );
+    },
+    { $$typeof: { value: TEMPORARY_REFERENCE_TAG } }
+  );
+  reference = new Proxy(reference, proxyHandlers);
+  temporaryReferences.set(reference, id);
+  return reference;
+}
+var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
+  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
+  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
+  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
+  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
+  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
+  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
+  REACT_MEMO_TYPE = Symbol.for("react.memo"),
+  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
+  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
+  REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
+  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
+  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+function getIteratorFn(maybeIterable) {
+  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
+  maybeIterable =
+    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
+    maybeIterable["@@iterator"];
+  return "function" === typeof maybeIterable ? maybeIterable : null;
+}
+var ASYNC_ITERATOR = Symbol.asyncIterator,
+  SuspenseException = Error(
+    "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
+  );
+function noop$1() {}
+function trackUsedThenable(thenableState, thenable, index) {
+  index = thenableState[index];
+  void 0 === index
+    ? thenableState.push(thenable)
+    : index !== thenable && (thenable.then(noop$1, noop$1), (thenable = index));
+  switch (thenable.status) {
+    case "fulfilled":
+      return thenable.value;
+    case "rejected":
+      throw thenable.reason;
+    default:
+      "string" === typeof thenable.status
+        ? thenable.then(noop$1, noop$1)
+        : ((thenableState = thenable),
+          (thenableState.status = "pending"),
+          thenableState.then(
+            function (fulfilledValue) {
+              if ("pending" === thenable.status) {
+                var fulfilledThenable = thenable;
+                fulfilledThenable.status = "fulfilled";
+                fulfilledThenable.value = fulfilledValue;
+              }
+            },
+            function (error) {
+              if ("pending" === thenable.status) {
+                var rejectedThenable = thenable;
+                rejectedThenable.status = "rejected";
+                rejectedThenable.reason = error;
+              }
+            }
+          ));
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw thenable.reason;
+      }
+      suspendedThenable = thenable;
+      throw SuspenseException;
+  }
+}
+var suspendedThenable = null;
+function getSuspendedThenable() {
+  if (null === suspendedThenable)
+    throw Error(
+      "Expected a suspended thenable. This is a bug in React. Please file an issue."
+    );
+  var thenable = suspendedThenable;
+  suspendedThenable = null;
+  return thenable;
+}
+var currentRequest$1 = null,
+  thenableIndexCounter = 0,
+  thenableState = null;
+function getThenableStateAfterSuspending() {
+  var state = thenableState || [];
+  thenableState = null;
+  return state;
+}
+var HooksDispatcher = {
+  useMemo: function (nextCreate) {
+    return nextCreate();
+  },
+  useCallback: function (callback) {
+    return callback;
+  },
+  useDebugValue: function () {},
+  useDeferredValue: unsupportedHook,
+  useTransition: unsupportedHook,
+  readContext: unsupportedContext,
+  useContext: unsupportedContext,
+  useReducer: unsupportedHook,
+  useRef: unsupportedHook,
+  useState: unsupportedHook,
+  useInsertionEffect: unsupportedHook,
+  useLayoutEffect: unsupportedHook,
+  useImperativeHandle: unsupportedHook,
+  useEffect: unsupportedHook,
+  useId: useId,
+  useHostTransitionStatus: unsupportedHook,
+  useOptimistic: unsupportedHook,
+  useFormState: unsupportedHook,
+  useActionState: unsupportedHook,
+  useSyncExternalStore: unsupportedHook,
+  useCacheRefresh: function () {
+    return unsupportedRefresh;
+  },
+  useMemoCache: function (size) {
+    for (var data = Array(size), i = 0; i < size; i++)
+      data[i] = REACT_MEMO_CACHE_SENTINEL;
+    return data;
+  },
+  use: use
+};
+function unsupportedHook() {
+  throw Error("This Hook is not supported in Server Components.");
+}
+function unsupportedRefresh() {
+  throw Error("Refreshing the cache is not supported in Server Components.");
+}
+function unsupportedContext() {
+  throw Error("Cannot read a Client Context from a Server Component.");
+}
+function useId() {
+  if (null === currentRequest$1)
+    throw Error("useId can only be used while React is rendering");
+  var id = currentRequest$1.identifierCount++;
+  return ":" + currentRequest$1.identifierPrefix + "S" + id.toString(32) + ":";
+}
+function use(usable) {
+  if (
+    (null !== usable && "object" === typeof usable) ||
+    "function" === typeof usable
+  ) {
+    if ("function" === typeof usable.then) {
+      var index = thenableIndexCounter;
+      thenableIndexCounter += 1;
+      null === thenableState && (thenableState = []);
+      return trackUsedThenable(thenableState, usable, index);
+    }
+    usable.$$typeof === REACT_CONTEXT_TYPE && unsupportedContext();
+  }
+  if (usable.$$typeof === CLIENT_REFERENCE_TAG$1) {
+    if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE)
+      throw Error("Cannot read a Client Context from a Server Component.");
+    throw Error("Cannot use() an already resolved Client Reference.");
+  }
+  throw Error("An unsupported type was passed to use(): " + String(usable));
+}
+var DefaultAsyncDispatcher = {
+    getCacheForType: function (resourceType) {
+      var JSCompiler_inline_result = (JSCompiler_inline_result =
+        resolveRequest())
+        ? JSCompiler_inline_result.cache
+        : new Map();
+      var entry = JSCompiler_inline_result.get(resourceType);
+      void 0 === entry &&
+        ((entry = resourceType()),
+        JSCompiler_inline_result.set(resourceType, entry));
+      return entry;
+    }
+  },
+  ReactSharedInternalsServer =
+    React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+if (!ReactSharedInternalsServer)
+  throw Error(
+    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
+  );
+var isArrayImpl = Array.isArray,
+  getPrototypeOf = Object.getPrototypeOf;
+function objectName(object) {
+  return Object.prototype.toString
+    .call(object)
+    .replace(/^\[object (.*)\]$/, function (m, p0) {
+      return p0;
+    });
+}
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case "string":
+      return JSON.stringify(
+        10 >= value.length ? value : value.slice(0, 10) + "..."
+      );
+    case "object":
+      if (isArrayImpl(value)) return "[...]";
+      if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG)
+        return "client";
+      value = objectName(value);
+      return "Object" === value ? "{...}" : value;
+    case "function":
+      return value.$$typeof === CLIENT_REFERENCE_TAG
+        ? "client"
+        : (value = value.displayName || value.name)
+          ? "function " + value
+          : "function";
+    default:
+      return String(value);
+  }
+}
+function describeElementType(type) {
+  if ("string" === typeof type) return type;
+  switch (type) {
+    case REACT_SUSPENSE_TYPE:
+      return "Suspense";
+    case REACT_SUSPENSE_LIST_TYPE:
+      return "SuspenseList";
+    case REACT_VIEW_TRANSITION_TYPE:
+      return "ViewTransition";
+  }
+  if ("object" === typeof type)
+    switch (type.$$typeof) {
+      case REACT_FORWARD_REF_TYPE:
+        return describeElementType(type.render);
+      case REACT_MEMO_TYPE:
+        return describeElementType(type.type);
+      case REACT_LAZY_TYPE:
+        var payload = type._payload;
+        type = type._init;
+        try {
+          return describeElementType(type(payload));
+        } catch (x) {}
+    }
+  return "";
+}
+var CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  var objKind = objectName(objectOrArray);
+  if ("Object" !== objKind && "Array" !== objKind) return objKind;
+  objKind = -1;
+  var length = 0;
+  if (isArrayImpl(objectOrArray)) {
+    var str = "[";
+    for (var i = 0; i < objectOrArray.length; i++) {
+      0 < i && (str += ", ");
+      var value = objectOrArray[i];
+      value =
+        "object" === typeof value && null !== value
+          ? describeObjectForErrorMessage(value)
+          : describeValueForErrorMessage(value);
+      "" + i === expandedName
+        ? ((objKind = str.length), (length = value.length), (str += value))
+        : (str =
+            10 > value.length && 40 > str.length + value.length
+              ? str + value
+              : str + "...");
+    }
+    str += "]";
+  } else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
+    str = "<" + describeElementType(objectOrArray.type) + "/>";
+  else {
+    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return "client";
+    str = "{";
+    i = Object.keys(objectOrArray);
+    for (value = 0; value < i.length; value++) {
+      0 < value && (str += ", ");
+      var name = i[value],
+        encodedKey = JSON.stringify(name);
+      str += ('"' + name + '"' === encodedKey ? name : encodedKey) + ": ";
+      encodedKey = objectOrArray[name];
+      encodedKey =
+        "object" === typeof encodedKey && null !== encodedKey
+          ? describeObjectForErrorMessage(encodedKey)
+          : describeValueForErrorMessage(encodedKey);
+      name === expandedName
+        ? ((objKind = str.length),
+          (length = encodedKey.length),
+          (str += encodedKey))
+        : (str =
+            10 > encodedKey.length && 40 > str.length + encodedKey.length
+              ? str + encodedKey
+              : str + "...");
+    }
+    str += "}";
+  }
+  return void 0 === expandedName
+    ? str
+    : -1 < objKind && 0 < length
+      ? ((objectOrArray = " ".repeat(objKind) + "^".repeat(length)),
+        "\n  " + str + "\n  " + objectOrArray)
+      : "\n  " + str;
+}
+var ObjectPrototype = Object.prototype,
+  stringify = JSON.stringify,
+  TaintRegistryObjects = ReactSharedInternalsServer.TaintRegistryObjects,
+  TaintRegistryValues = ReactSharedInternalsServer.TaintRegistryValues,
+  TaintRegistryByteLengths =
+    ReactSharedInternalsServer.TaintRegistryByteLengths,
+  TaintRegistryPendingRequests =
+    ReactSharedInternalsServer.TaintRegistryPendingRequests;
+function throwTaintViolation(message) {
+  throw Error(message);
+}
+function cleanupTaintQueue(request) {
+  request = request.taintCleanupQueue;
+  TaintRegistryPendingRequests.delete(request);
+  for (var i = 0; i < request.length; i++) {
+    var entryValue = request[i],
+      entry = TaintRegistryValues.get(entryValue);
+    void 0 !== entry &&
+      (1 === entry.count
+        ? TaintRegistryValues.delete(entryValue)
+        : entry.count--);
+  }
+  request.length = 0;
+}
+function defaultErrorHandler(error) {
+  console.error(error);
+}
+function defaultPostponeHandler() {}
+function RequestInstance(
+  type,
+  model,
+  bundlerConfig,
+  onError,
+  identifierPrefix,
+  onPostpone,
+  temporaryReferences,
+  environmentName,
+  filterStackFrame,
+  onAllReady,
+  onFatalError
+) {
+  if (
+    null !== ReactSharedInternalsServer.A &&
+    ReactSharedInternalsServer.A !== DefaultAsyncDispatcher
+  )
+    throw Error("Currently React only supports one RSC renderer at a time.");
+  ReactSharedInternalsServer.A = DefaultAsyncDispatcher;
+  filterStackFrame = new Set();
+  environmentName = [];
+  var cleanupQueue = [];
+  TaintRegistryPendingRequests.add(cleanupQueue);
+  var hints = new Set();
+  this.type = type;
+  this.status = 10;
+  this.flushScheduled = !1;
+  this.destination = this.fatalError = null;
+  this.bundlerConfig = bundlerConfig;
+  this.cache = new Map();
+  this.pendingChunks = this.nextChunkId = 0;
+  this.hints = hints;
+  this.abortListeners = new Set();
+  this.abortableTasks = filterStackFrame;
+  this.pingedTasks = environmentName;
+  this.completedImportChunks = [];
+  this.completedHintChunks = [];
+  this.completedRegularChunks = [];
+  this.completedErrorChunks = [];
+  this.writtenSymbols = new Map();
+  this.writtenClientReferences = new Map();
+  this.writtenServerReferences = new Map();
+  this.writtenObjects = new WeakMap();
+  this.temporaryReferences = temporaryReferences;
+  this.identifierPrefix = identifierPrefix || "";
+  this.identifierCount = 1;
+  this.taintCleanupQueue = cleanupQueue;
+  this.onError = void 0 === onError ? defaultErrorHandler : onError;
+  this.onPostpone = void 0 === onPostpone ? defaultPostponeHandler : onPostpone;
+  this.onAllReady = onAllReady;
+  this.onFatalError = onFatalError;
+  type = createTask(this, model, null, !1, filterStackFrame);
+  environmentName.push(type);
+}
+function noop() {}
+var currentRequest = null;
+function resolveRequest() {
+  if (currentRequest) return currentRequest;
+  var store = requestStorage.getStore();
+  return store ? store : null;
+}
+function serializeThenable(request, task, thenable) {
+  var newTask = createTask(
+    request,
+    null,
+    task.keyPath,
+    task.implicitSlot,
+    request.abortableTasks
+  );
+  switch (thenable.status) {
+    case "fulfilled":
+      return (
+        (newTask.model = thenable.value), pingTask(request, newTask), newTask.id
+      );
+    case "rejected":
+      return erroredTask(request, newTask, thenable.reason), newTask.id;
+    default:
+      if (12 === request.status)
+        return (
+          request.abortableTasks.delete(newTask),
+          (newTask.status = 3),
+          21 === request.type
+            ? request.pendingChunks--
+            : ((task = stringify(serializeByValueID(request.fatalError))),
+              emitModelChunk(request, newTask.id, task)),
+          newTask.id
+        );
+      "string" !== typeof thenable.status &&
+        ((thenable.status = "pending"),
+        thenable.then(
+          function (fulfilledValue) {
+            "pending" === thenable.status &&
+              ((thenable.status = "fulfilled"),
+              (thenable.value = fulfilledValue));
+          },
+          function (error) {
+            "pending" === thenable.status &&
+              ((thenable.status = "rejected"), (thenable.reason = error));
+          }
+        ));
+  }
+  thenable.then(
+    function (value) {
+      newTask.model = value;
+      pingTask(request, newTask);
+    },
+    function (reason) {
+      0 === newTask.status &&
+        (erroredTask(request, newTask, reason), enqueueFlush(request));
+    }
+  );
+  return newTask.id;
+}
+function serializeReadableStream(request, task, stream) {
+  function progress(entry) {
+    if (!aborted)
+      if (entry.done)
+        request.abortListeners.delete(abortStream),
+          (entry = streamTask.id.toString(16) + ":C\n"),
+          request.completedRegularChunks.push(entry),
+          enqueueFlush(request),
+          (aborted = !0);
+      else
+        try {
+          (streamTask.model = entry.value),
+            request.pendingChunks++,
+            emitChunk(request, streamTask, streamTask.model),
+            enqueueFlush(request),
+            reader.read().then(progress, error);
+        } catch (x$7) {
+          error(x$7);
+        }
+  }
+  function error(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortStream),
+      erroredTask(request, streamTask, reason),
+      enqueueFlush(request),
+      reader.cancel(reason).then(error, error));
+  }
+  function abortStream(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortStream),
+      21 === request.type
+        ? request.pendingChunks--
+        : (erroredTask(request, streamTask, reason), enqueueFlush(request)),
+      reader.cancel(reason).then(error, error));
+  }
+  var supportsBYOB = stream.supportsBYOB;
+  if (void 0 === supportsBYOB)
+    try {
+      stream.getReader({ mode: "byob" }).releaseLock(), (supportsBYOB = !0);
+    } catch (x) {
+      supportsBYOB = !1;
+    }
+  var reader = stream.getReader(),
+    streamTask = createTask(
+      request,
+      task.model,
+      task.keyPath,
+      task.implicitSlot,
+      request.abortableTasks
+    );
+  request.abortableTasks.delete(streamTask);
+  request.pendingChunks++;
+  task = streamTask.id.toString(16) + ":" + (supportsBYOB ? "r" : "R") + "\n";
+  request.completedRegularChunks.push(task);
+  var aborted = !1;
+  request.abortListeners.add(abortStream);
+  reader.read().then(progress, error);
+  return serializeByValueID(streamTask.id);
+}
+function serializeAsyncIterable(request, task, iterable, iterator) {
+  function progress(entry) {
+    if (!aborted)
+      if (entry.done) {
+        request.abortListeners.delete(abortIterable);
+        if (void 0 === entry.value)
+          var endStreamRow = streamTask.id.toString(16) + ":C\n";
+        else
+          try {
+            var chunkId = outlineModel(request, entry.value);
+            endStreamRow =
+              streamTask.id.toString(16) +
+              ":C" +
+              stringify(serializeByValueID(chunkId)) +
+              "\n";
+          } catch (x) {
+            error(x);
+            return;
+          }
+        request.completedRegularChunks.push(endStreamRow);
+        enqueueFlush(request);
+        aborted = !0;
+      } else
+        try {
+          (streamTask.model = entry.value),
+            request.pendingChunks++,
+            emitChunk(request, streamTask, streamTask.model),
+            enqueueFlush(request),
+            iterator.next().then(progress, error);
+        } catch (x$8) {
+          error(x$8);
+        }
+  }
+  function error(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortIterable),
+      erroredTask(request, streamTask, reason),
+      enqueueFlush(request),
+      "function" === typeof iterator.throw &&
+        iterator.throw(reason).then(error, error));
+  }
+  function abortIterable(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortIterable),
+      21 === request.type
+        ? request.pendingChunks--
+        : (erroredTask(request, streamTask, reason), enqueueFlush(request)),
+      "function" === typeof iterator.throw &&
+        iterator.throw(reason).then(error, error));
+  }
+  iterable = iterable === iterator;
+  var streamTask = createTask(
+    request,
+    task.model,
+    task.keyPath,
+    task.implicitSlot,
+    request.abortableTasks
+  );
+  request.abortableTasks.delete(streamTask);
+  request.pendingChunks++;
+  task = streamTask.id.toString(16) + ":" + (iterable ? "x" : "X") + "\n";
+  request.completedRegularChunks.push(task);
+  var aborted = !1;
+  request.abortListeners.add(abortIterable);
+  iterator.next().then(progress, error);
+  return serializeByValueID(streamTask.id);
+}
+function emitHint(request, code, model) {
+  model = stringify(model);
+  request.completedHintChunks.push(":H" + code + model + "\n");
+  enqueueFlush(request);
+}
+function readThenable(thenable) {
+  if ("fulfilled" === thenable.status) return thenable.value;
+  if ("rejected" === thenable.status) throw thenable.reason;
+  throw thenable;
+}
+function createLazyWrapperAroundWakeable(wakeable) {
+  switch (wakeable.status) {
+    case "fulfilled":
+    case "rejected":
+      break;
+    default:
+      "string" !== typeof wakeable.status &&
+        ((wakeable.status = "pending"),
+        wakeable.then(
+          function (fulfilledValue) {
+            "pending" === wakeable.status &&
+              ((wakeable.status = "fulfilled"),
+              (wakeable.value = fulfilledValue));
+          },
+          function (error) {
+            "pending" === wakeable.status &&
+              ((wakeable.status = "rejected"), (wakeable.reason = error));
+          }
+        ));
+  }
+  return { $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };
+}
+function voidHandler() {}
+function processServerComponentReturnValue(request, task, Component, result) {
+  if (
+    "object" !== typeof result ||
+    null === result ||
+    result.$$typeof === CLIENT_REFERENCE_TAG$1
+  )
+    return result;
+  if ("function" === typeof result.then)
+    return "fulfilled" === result.status
+      ? result.value
+      : createLazyWrapperAroundWakeable(result);
+  var iteratorFn = getIteratorFn(result);
+  return iteratorFn
+    ? ((request = {}),
+      (request[Symbol.iterator] = function () {
+        return iteratorFn.call(result);
+      }),
+      request)
+    : "function" !== typeof result[ASYNC_ITERATOR] ||
+        ("function" === typeof ReadableStream &&
+          result instanceof ReadableStream)
+      ? result
+      : ((request = {}),
+        (request[ASYNC_ITERATOR] = function () {
+          return result[ASYNC_ITERATOR]();
+        }),
+        request);
+}
+function renderFunctionComponent(request, task, key, Component, props) {
+  var prevThenableState = task.thenableState;
+  task.thenableState = null;
+  thenableIndexCounter = 0;
+  thenableState = prevThenableState;
+  props = Component(props, void 0);
+  if (12 === request.status)
+    throw (
+      ("object" === typeof props &&
+        null !== props &&
+        "function" === typeof props.then &&
+        props.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
+        props.then(voidHandler, voidHandler),
+      null)
+    );
+  props = processServerComponentReturnValue(request, task, Component, props);
+  Component = task.keyPath;
+  prevThenableState = task.implicitSlot;
+  null !== key
+    ? (task.keyPath = null === Component ? key : Component + "," + key)
+    : null === Component && (task.implicitSlot = !0);
+  request = renderModelDestructive(request, task, emptyRoot, "", props);
+  task.keyPath = Component;
+  task.implicitSlot = prevThenableState;
+  return request;
+}
+function renderFragment(request, task, children) {
+  return null !== task.keyPath
+    ? ((request = [
+        REACT_ELEMENT_TYPE,
+        REACT_FRAGMENT_TYPE,
+        task.keyPath,
+        { children: children }
+      ]),
+      task.implicitSlot ? [request] : request)
+    : children;
+}
+function renderElement(request, task, type, key, ref, props) {
+  if (null !== ref && void 0 !== ref)
+    throw Error(
+      "Refs cannot be used in Server Components, nor passed to Client Components."
+    );
+  if (
+    "function" === typeof type &&
+    type.$$typeof !== CLIENT_REFERENCE_TAG$1 &&
+    type.$$typeof !== TEMPORARY_REFERENCE_TAG
+  )
+    return renderFunctionComponent(request, task, key, type, props);
+  if (type === REACT_FRAGMENT_TYPE && null === key)
+    return (
+      (type = task.implicitSlot),
+      null === task.keyPath && (task.implicitSlot = !0),
+      (props = renderModelDestructive(
+        request,
+        task,
+        emptyRoot,
+        "",
+        props.children
+      )),
+      (task.implicitSlot = type),
+      props
+    );
+  if (
+    null != type &&
+    "object" === typeof type &&
+    type.$$typeof !== CLIENT_REFERENCE_TAG$1
+  )
+    switch (type.$$typeof) {
+      case REACT_LAZY_TYPE:
+        var init = type._init;
+        type = init(type._payload);
+        if (12 === request.status) throw null;
+        return renderElement(request, task, type, key, ref, props);
+      case REACT_FORWARD_REF_TYPE:
+        return renderFunctionComponent(request, task, key, type.render, props);
+      case REACT_MEMO_TYPE:
+        return renderElement(request, task, type.type, key, ref, props);
+    }
+  request = key;
+  key = task.keyPath;
+  null === request
+    ? (request = key)
+    : null !== key && (request = key + "," + request);
+  props = [REACT_ELEMENT_TYPE, type, request, props];
+  task = task.implicitSlot && null !== request ? [props] : props;
+  return task;
+}
+function pingTask(request, task) {
+  var pingedTasks = request.pingedTasks;
+  pingedTasks.push(task);
+  1 === pingedTasks.length &&
+    ((request.flushScheduled = null !== request.destination),
+    21 === request.type || 10 === request.status
+      ? scheduleMicrotask(function () {
+          return performWork(request);
+        })
+      : setImmediate(function () {
+          return performWork(request);
+        }));
+}
+function createTask(request, model, keyPath, implicitSlot, abortSet) {
+  request.pendingChunks++;
+  var id = request.nextChunkId++;
+  "object" !== typeof model ||
+    null === model ||
+    null !== keyPath ||
+    implicitSlot ||
+    request.writtenObjects.set(model, serializeByValueID(id));
+  var task = {
+    id: id,
+    status: 0,
+    model: model,
+    keyPath: keyPath,
+    implicitSlot: implicitSlot,
+    ping: function () {
+      return pingTask(request, task);
+    },
+    toJSON: function (parentPropertyName, value) {
+      var prevKeyPath = task.keyPath,
+        prevImplicitSlot = task.implicitSlot;
+      try {
+        var JSCompiler_inline_result = renderModelDestructive(
+          request,
+          task,
+          this,
+          parentPropertyName,
+          value
+        );
+      } catch (thrownValue) {
+        if (
+          ((parentPropertyName = task.model),
+          (parentPropertyName =
+            "object" === typeof parentPropertyName &&
+            null !== parentPropertyName &&
+            (parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||
+              parentPropertyName.$$typeof === REACT_LAZY_TYPE)),
+          12 === request.status)
+        )
+          (task.status = 3),
+            21 === request.type
+              ? ((prevKeyPath = request.nextChunkId++),
+                (prevKeyPath = parentPropertyName
+                  ? "$L" + prevKeyPath.toString(16)
+                  : serializeByValueID(prevKeyPath)),
+                (JSCompiler_inline_result = prevKeyPath))
+              : ((prevKeyPath = request.fatalError),
+                (JSCompiler_inline_result = parentPropertyName
+                  ? "$L" + prevKeyPath.toString(16)
+                  : serializeByValueID(prevKeyPath)));
+        else if (
+          ((value =
+            thrownValue === SuspenseException
+              ? getSuspendedThenable()
+              : thrownValue),
+          "object" === typeof value &&
+            null !== value &&
+            "function" === typeof value.then)
+        ) {
+          JSCompiler_inline_result = createTask(
+            request,
+            task.model,
+            task.keyPath,
+            task.implicitSlot,
+            request.abortableTasks
+          );
+          var ping = JSCompiler_inline_result.ping;
+          value.then(ping, ping);
+          JSCompiler_inline_result.thenableState =
+            getThenableStateAfterSuspending();
+          task.keyPath = prevKeyPath;
+          task.implicitSlot = prevImplicitSlot;
+          JSCompiler_inline_result = parentPropertyName
+            ? "$L" + JSCompiler_inline_result.id.toString(16)
+            : serializeByValueID(JSCompiler_inline_result.id);
+        } else
+          (task.keyPath = prevKeyPath),
+            (task.implicitSlot = prevImplicitSlot),
+            request.pendingChunks++,
+            (prevKeyPath = request.nextChunkId++),
+            "object" === typeof value &&
+            null !== value &&
+            value.$$typeof === REACT_POSTPONE_TYPE
+              ? (logPostpone(request, value.message, task),
+                emitPostponeChunk(request, prevKeyPath))
+              : ((prevImplicitSlot = logRecoverableError(request, value, task)),
+                emitErrorChunk(request, prevKeyPath, prevImplicitSlot)),
+            (JSCompiler_inline_result = parentPropertyName
+              ? "$L" + prevKeyPath.toString(16)
+              : serializeByValueID(prevKeyPath));
+      }
+      return JSCompiler_inline_result;
+    },
+    thenableState: null
+  };
+  abortSet.add(task);
+  return task;
+}
+function serializeByValueID(id) {
+  return "$" + id.toString(16);
+}
+function encodeReferenceChunk(request, id, reference) {
+  request = stringify(reference);
+  return id.toString(16) + ":" + request + "\n";
+}
+function serializeClientReference(
+  request,
+  parent,
+  parentPropertyName,
+  clientReference
+) {
+  var clientReferenceKey = clientReference.$$id,
+    writtenClientReferences = request.writtenClientReferences,
+    existingId = writtenClientReferences.get(clientReferenceKey);
+  if (void 0 !== existingId)
+    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+      ? "$L" + existingId.toString(16)
+      : serializeByValueID(existingId);
+  try {
+    var baseURL = request.bundlerConfig,
+      id = clientReference.$$id,
+      idx = id.lastIndexOf("#"),
+      exportName = id.slice(idx + 1),
+      fullURL = id.slice(0, idx);
+    if (!fullURL.startsWith(baseURL))
+      throw Error("Attempted to load a Client Module outside the hosted root.");
+    var JSCompiler_inline_result = [fullURL.slice(baseURL.length), exportName];
+    request.pendingChunks++;
+    var importId = request.nextChunkId++,
+      json = stringify(JSCompiler_inline_result),
+      processedChunk = importId.toString(16) + ":I" + json + "\n";
+    request.completedImportChunks.push(processedChunk);
+    writtenClientReferences.set(clientReferenceKey, importId);
+    return parent[0] === REACT_ELEMENT_TYPE && "1" === parentPropertyName
+      ? "$L" + importId.toString(16)
+      : serializeByValueID(importId);
+  } catch (x) {
+    return (
+      request.pendingChunks++,
+      (parent = request.nextChunkId++),
+      (parentPropertyName = logRecoverableError(request, x, null)),
+      emitErrorChunk(request, parent, parentPropertyName),
+      serializeByValueID(parent)
+    );
+  }
+}
+function outlineModel(request, value) {
+  value = createTask(request, value, null, !1, request.abortableTasks);
+  retryTask(request, value);
+  return value.id;
+}
+function serializeTypedArray(request, tag, typedArray) {
+  request.pendingChunks++;
+  var bufferId = request.nextChunkId++;
+  emitTypedArrayChunk(request, bufferId, tag, typedArray);
+  return serializeByValueID(bufferId);
+}
+function serializeBlob(request, blob) {
+  function progress(entry) {
+    if (!aborted)
+      if (entry.done)
+        request.abortListeners.delete(abortBlob),
+          (aborted = !0),
+          pingTask(request, newTask);
+      else
+        return (
+          model.push(entry.value), reader.read().then(progress).catch(error)
+        );
+  }
+  function error(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortBlob),
+      erroredTask(request, newTask, reason),
+      enqueueFlush(request),
+      reader.cancel(reason).then(error, error));
+  }
+  function abortBlob(reason) {
+    aborted ||
+      ((aborted = !0),
+      request.abortListeners.delete(abortBlob),
+      21 === request.type
+        ? request.pendingChunks--
+        : (erroredTask(request, newTask, reason), enqueueFlush(request)),
+      reader.cancel(reason).then(error, error));
+  }
+  var model = [blob.type],
+    newTask = createTask(request, model, null, !1, request.abortableTasks),
+    reader = blob.stream().getReader(),
+    aborted = !1;
+  request.abortListeners.add(abortBlob);
+  reader.read().then(progress).catch(error);
+  return "$B" + newTask.id.toString(16);
+}
+var modelRoot = !1;
+function renderModelDestructive(
+  request,
+  task,
+  parent,
+  parentPropertyName,
+  value
+) {
+  task.model = value;
+  if (value === REACT_ELEMENT_TYPE) return "$";
+  if (null === value) return null;
+  if ("object" === typeof value) {
+    switch (value.$$typeof) {
+      case REACT_ELEMENT_TYPE:
+        var elementReference = null,
+          writtenObjects = request.writtenObjects;
+        if (null === task.keyPath && !task.implicitSlot) {
+          var existingReference = writtenObjects.get(value);
+          if (void 0 !== existingReference)
+            if (modelRoot === value) modelRoot = null;
+            else return existingReference;
+          else
+            -1 === parentPropertyName.indexOf(":") &&
+              ((parent = writtenObjects.get(parent)),
+              void 0 !== parent &&
+                ((elementReference = parent + ":" + parentPropertyName),
+                writtenObjects.set(value, elementReference)));
+        }
+        parentPropertyName = value.props;
+        parent = parentPropertyName.ref;
+        value = renderElement(
+          request,
+          task,
+          value.type,
+          value.key,
+          void 0 !== parent ? parent : null,
+          parentPropertyName
+        );
+        "object" === typeof value &&
+          null !== value &&
+          null !== elementReference &&
+          (writtenObjects.has(value) ||
+            writtenObjects.set(value, elementReference));
+        return value;
+      case REACT_LAZY_TYPE:
+        task.thenableState = null;
+        parentPropertyName = value._init;
+        value = parentPropertyName(value._payload);
+        if (12 === request.status) throw null;
+        return renderModelDestructive(request, task, emptyRoot, "", value);
+      case REACT_LEGACY_ELEMENT_TYPE:
+        throw Error(
+          'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
+        );
+    }
+    if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
+      return serializeClientReference(
+        request,
+        parent,
+        parentPropertyName,
+        value
+      );
+    if (
+      void 0 !== request.temporaryReferences &&
+      ((elementReference = request.temporaryReferences.get(value)),
+      void 0 !== elementReference)
+    )
+      return "$T" + elementReference;
+    elementReference = TaintRegistryObjects.get(value);
+    void 0 !== elementReference && throwTaintViolation(elementReference);
+    elementReference = request.writtenObjects;
+    writtenObjects = elementReference.get(value);
+    if ("function" === typeof value.then) {
+      if (void 0 !== writtenObjects) {
+        if (null !== task.keyPath || task.implicitSlot)
+          return "$@" + serializeThenable(request, task, value).toString(16);
+        if (modelRoot === value) modelRoot = null;
+        else return writtenObjects;
+      }
+      request = "$@" + serializeThenable(request, task, value).toString(16);
+      elementReference.set(value, request);
+      return request;
+    }
+    if (void 0 !== writtenObjects)
+      if (modelRoot === value) modelRoot = null;
+      else return writtenObjects;
+    else if (
+      -1 === parentPropertyName.indexOf(":") &&
+      ((writtenObjects = elementReference.get(parent)),
+      void 0 !== writtenObjects)
+    ) {
+      existingReference = parentPropertyName;
+      if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE)
+        switch (parentPropertyName) {
+          case "1":
+            existingReference = "type";
+            break;
+          case "2":
+            existingReference = "key";
+            break;
+          case "3":
+            existingReference = "props";
+            break;
+          case "4":
+            existingReference = "_owner";
+        }
+      elementReference.set(value, writtenObjects + ":" + existingReference);
+    }
+    if (isArrayImpl(value)) return renderFragment(request, task, value);
+    if (value instanceof Map)
+      return (
+        (value = Array.from(value)),
+        "$Q" + outlineModel(request, value).toString(16)
+      );
+    if (value instanceof Set)
+      return (
+        (value = Array.from(value)),
+        "$W" + outlineModel(request, value).toString(16)
+      );
+    if ("function" === typeof FormData && value instanceof FormData)
+      return (
+        (value = Array.from(value.entries())),
+        "$K" + outlineModel(request, value).toString(16)
+      );
+    if (value instanceof Error) return "$Z";
+    if (value instanceof ArrayBuffer)
+      return serializeTypedArray(request, "A", new Uint8Array(value));
+    if (value instanceof Int8Array)
+      return serializeTypedArray(request, "O", value);
+    if (value instanceof Uint8Array)
+      return serializeTypedArray(request, "o", value);
+    if (value instanceof Uint8ClampedArray)
+      return serializeTypedArray(request, "U", value);
+    if (value instanceof Int16Array)
+      return serializeTypedArray(request, "S", value);
+    if (value instanceof Uint16Array)
+      return serializeTypedArray(request, "s", value);
+    if (value instanceof Int32Array)
+      return serializeTypedArray(request, "L", value);
+    if (value instanceof Uint32Array)
+      return serializeTypedArray(request, "l", value);
+    if (value instanceof Float32Array)
+      return serializeTypedArray(request, "G", value);
+    if (value instanceof Float64Array)
+      return serializeTypedArray(request, "g", value);
+    if (value instanceof BigInt64Array)
+      return serializeTypedArray(request, "M", value);
+    if (value instanceof BigUint64Array)
+      return serializeTypedArray(request, "m", value);
+    if (value instanceof DataView)
+      return serializeTypedArray(request, "V", value);
+    if ("function" === typeof Blob && value instanceof Blob)
+      return serializeBlob(request, value);
+    if ((elementReference = getIteratorFn(value)))
+      return (
+        (parentPropertyName = elementReference.call(value)),
+        parentPropertyName === value
+          ? "$i" +
+            outlineModel(request, Array.from(parentPropertyName)).toString(16)
+          : renderFragment(request, task, Array.from(parentPropertyName))
+      );
+    if ("function" === typeof ReadableStream && value instanceof ReadableStream)
+      return serializeReadableStream(request, task, value);
+    elementReference = value[ASYNC_ITERATOR];
+    if ("function" === typeof elementReference)
+      return (
+        null !== task.keyPath
+          ? ((value = [
+              REACT_ELEMENT_TYPE,
+              REACT_FRAGMENT_TYPE,
+              task.keyPath,
+              { children: value }
+            ]),
+            (value = task.implicitSlot ? [value] : value))
+          : ((parentPropertyName = elementReference.call(value)),
+            (value = serializeAsyncIterable(
+              request,
+              task,
+              value,
+              parentPropertyName
+            ))),
+        value
+      );
+    if (value instanceof Date) return "$D" + value.toJSON();
+    request = getPrototypeOf(value);
+    if (
+      request !== ObjectPrototype &&
+      (null === request || null !== getPrototypeOf(request))
+    )
+      throw Error(
+        "Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported." +
+          describeObjectForErrorMessage(parent, parentPropertyName)
+      );
+    return value;
+  }
+  if ("string" === typeof value) {
+    task = TaintRegistryValues.get(value);
+    void 0 !== task && throwTaintViolation(task.message);
+    if (
+      "Z" === value[value.length - 1] &&
+      parent[parentPropertyName] instanceof Date
+    )
+      return "$D" + value;
+    if (1024 <= value.length && null !== byteLengthOfChunk)
+      return (
+        request.pendingChunks++,
+        (task = request.nextChunkId++),
+        emitTextChunk(request, task, value),
+        serializeByValueID(task)
+      );
+    value = "$" === value[0] ? "$" + value : value;
+    return value;
+  }
+  if ("boolean" === typeof value) return value;
+  if ("number" === typeof value)
+    return Number.isFinite(value)
+      ? 0 === value && -Infinity === 1 / value
+        ? "$-0"
+        : value
+      : Infinity === value
+        ? "$Infinity"
+        : -Infinity === value
+          ? "$-Infinity"
+          : "$NaN";
+  if ("undefined" === typeof value) return "$undefined";
+  if ("function" === typeof value) {
+    if (value.$$typeof === CLIENT_REFERENCE_TAG$1)
+      return serializeClientReference(
+        request,
+        parent,
+        parentPropertyName,
+        value
+      );
+    if (value.$$typeof === SERVER_REFERENCE_TAG)
+      return (
+        (task = request.writtenServerReferences),
+        (parentPropertyName = task.get(value)),
+        void 0 !== parentPropertyName
+          ? (value = "$F" + parentPropertyName.toString(16))
+          : ((parentPropertyName = value.$$bound),
+            (parentPropertyName =
+              null === parentPropertyName
+                ? null
+                : Promise.resolve(parentPropertyName)),
+            (request = outlineModel(request, {
+              id: value.$$id,
+              bound: parentPropertyName
+            })),
+            task.set(value, request),
+            (value = "$F" + request.toString(16))),
+        value
+      );
+    if (
+      void 0 !== request.temporaryReferences &&
+      ((request = request.temporaryReferences.get(value)), void 0 !== request)
+    )
+      return "$T" + request;
+    request = TaintRegistryObjects.get(value);
+    void 0 !== request && throwTaintViolation(request);
+    if (value.$$typeof === TEMPORARY_REFERENCE_TAG)
+      throw Error(
+        "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+      );
+    if (/^on[A-Z]/.test(parentPropertyName))
+      throw Error(
+        "Event handlers cannot be passed to Client Component props." +
+          describeObjectForErrorMessage(parent, parentPropertyName) +
+          "\nIf you need interactivity, consider converting part of this to a Client Component."
+      );
+    throw Error(
+      'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with "use server". Or maybe you meant to call this function rather than return it.' +
+        describeObjectForErrorMessage(parent, parentPropertyName)
+    );
+  }
+  if ("symbol" === typeof value) {
+    task = request.writtenSymbols;
+    elementReference = task.get(value);
+    if (void 0 !== elementReference)
+      return serializeByValueID(elementReference);
+    elementReference = value.description;
+    if (Symbol.for(elementReference) !== value)
+      throw Error(
+        "Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(" +
+          (value.description + ") cannot be found among global symbols.") +
+          describeObjectForErrorMessage(parent, parentPropertyName)
+      );
+    request.pendingChunks++;
+    parentPropertyName = request.nextChunkId++;
+    parent = encodeReferenceChunk(
+      request,
+      parentPropertyName,
+      "$S" + elementReference
+    );
+    request.completedImportChunks.push(parent);
+    task.set(value, parentPropertyName);
+    return serializeByValueID(parentPropertyName);
+  }
+  if ("bigint" === typeof value)
+    return (
+      (request = TaintRegistryValues.get(value)),
+      void 0 !== request && throwTaintViolation(request.message),
+      "$n" + value.toString(10)
+    );
+  throw Error(
+    "Type " +
+      typeof value +
+      " is not supported in Client Component props." +
+      describeObjectForErrorMessage(parent, parentPropertyName)
+  );
+}
+function logPostpone(request, reason) {
+  var prevRequest = currentRequest;
+  currentRequest = null;
+  try {
+    requestStorage.run(void 0, request.onPostpone, reason);
+  } finally {
+    currentRequest = prevRequest;
+  }
+}
+function logRecoverableError(request, error) {
+  var prevRequest = currentRequest;
+  currentRequest = null;
+  try {
+    var errorDigest = requestStorage.run(void 0, request.onError, error);
+  } finally {
+    currentRequest = prevRequest;
+  }
+  if (null != errorDigest && "string" !== typeof errorDigest)
+    throw Error(
+      'onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' +
+        typeof errorDigest +
+        '" instead'
+    );
+  return errorDigest || "";
+}
+function fatalError(request, error) {
+  var onFatalError = request.onFatalError;
+  onFatalError(error);
+  cleanupTaintQueue(request);
+  null !== request.destination
+    ? ((request.status = 14), request.destination.destroy(error))
+    : ((request.status = 13), (request.fatalError = error));
+}
+function emitPostponeChunk(request, id) {
+  id = id.toString(16) + ":P\n";
+  request.completedErrorChunks.push(id);
+}
+function emitErrorChunk(request, id, digest) {
+  digest = { digest: digest };
+  id = id.toString(16) + ":E" + stringify(digest) + "\n";
+  request.completedErrorChunks.push(id);
+}
+function emitModelChunk(request, id, json) {
+  id = id.toString(16) + ":" + json + "\n";
+  request.completedRegularChunks.push(id);
+}
+function emitTypedArrayChunk(request, id, tag, typedArray) {
+  if (TaintRegistryByteLengths.has(typedArray.byteLength)) {
+    var tainted = TaintRegistryValues.get(
+      String.fromCharCode.apply(
+        String,
+        new Uint8Array(
+          typedArray.buffer,
+          typedArray.byteOffset,
+          typedArray.byteLength
+        )
+      )
+    );
+    void 0 !== tainted && throwTaintViolation(tainted.message);
+  }
+  request.pendingChunks++;
+  typedArray = new Uint8Array(
+    typedArray.buffer,
+    typedArray.byteOffset,
+    typedArray.byteLength
+  );
+  tainted = typedArray.byteLength;
+  id = id.toString(16) + ":" + tag + tainted.toString(16) + ",";
+  request.completedRegularChunks.push(id, typedArray);
+}
+function emitTextChunk(request, id, text) {
+  if (null === byteLengthOfChunk)
+    throw Error(
+      "Existence of byteLengthOfChunk should have already been checked. This is a bug in React."
+    );
+  request.pendingChunks++;
+  var binaryLength = byteLengthOfChunk(text);
+  id = id.toString(16) + ":T" + binaryLength.toString(16) + ",";
+  request.completedRegularChunks.push(id, text);
+}
+function emitChunk(request, task, value) {
+  var id = task.id;
+  "string" === typeof value && null !== byteLengthOfChunk
+    ? ((task = TaintRegistryValues.get(value)),
+      void 0 !== task && throwTaintViolation(task.message),
+      emitTextChunk(request, id, value))
+    : value instanceof ArrayBuffer
+      ? emitTypedArrayChunk(request, id, "A", new Uint8Array(value))
+      : value instanceof Int8Array
+        ? emitTypedArrayChunk(request, id, "O", value)
+        : value instanceof Uint8Array
+          ? emitTypedArrayChunk(request, id, "o", value)
+          : value instanceof Uint8ClampedArray
+            ? emitTypedArrayChunk(request, id, "U", value)
+            : value instanceof Int16Array
+              ? emitTypedArrayChunk(request, id, "S", value)
+              : value instanceof Uint16Array
+                ? emitTypedArrayChunk(request, id, "s", value)
+                : value instanceof Int32Array
+                  ? emitTypedArrayChunk(request, id, "L", value)
+                  : value instanceof Uint32Array
+                    ? emitTypedArrayChunk(request, id, "l", value)
+                    : value instanceof Float32Array
+                      ? emitTypedArrayChunk(request, id, "G", value)
+                      : value instanceof Float64Array
+                        ? emitTypedArrayChunk(request, id, "g", value)
+                        : value instanceof BigInt64Array
+                          ? emitTypedArrayChunk(request, id, "M", value)
+                          : value instanceof BigUint64Array
+                            ? emitTypedArrayChunk(request, id, "m", value)
+                            : value instanceof DataView
+                              ? emitTypedArrayChunk(request, id, "V", value)
+                              : ((value = stringify(value, task.toJSON)),
+                                emitModelChunk(request, task.id, value));
+}
+function erroredTask(request, task, error) {
+  request.abortableTasks.delete(task);
+  task.status = 4;
+  "object" === typeof error &&
+  null !== error &&
+  error.$$typeof === REACT_POSTPONE_TYPE
+    ? (logPostpone(request, error.message, task),
+      emitPostponeChunk(request, task.id))
+    : ((error = logRecoverableError(request, error, task)),
+      emitErrorChunk(request, task.id, error));
+}
+var emptyRoot = {};
+function retryTask(request, task) {
+  if (0 === task.status) {
+    task.status = 5;
+    try {
+      modelRoot = task.model;
+      var resolvedModel = renderModelDestructive(
+        request,
+        task,
+        emptyRoot,
+        "",
+        task.model
+      );
+      modelRoot = resolvedModel;
+      task.keyPath = null;
+      task.implicitSlot = !1;
+      if ("object" === typeof resolvedModel && null !== resolvedModel)
+        request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),
+          emitChunk(request, task, resolvedModel);
+      else {
+        var json = stringify(resolvedModel);
+        emitModelChunk(request, task.id, json);
+      }
+      request.abortableTasks.delete(task);
+      task.status = 1;
+    } catch (thrownValue) {
+      if (12 === request.status)
+        if (
+          (request.abortableTasks.delete(task),
+          (task.status = 3),
+          21 === request.type)
+        )
+          request.pendingChunks--;
+        else {
+          var model = stringify(serializeByValueID(request.fatalError));
+          emitModelChunk(request, task.id, model);
+        }
+      else {
+        var x =
+          thrownValue === SuspenseException
+            ? getSuspendedThenable()
+            : thrownValue;
+        if (
+          "object" === typeof x &&
+          null !== x &&
+          "function" === typeof x.then
+        ) {
+          task.status = 0;
+          task.thenableState = getThenableStateAfterSuspending();
+          var ping = task.ping;
+          x.then(ping, ping);
+        } else erroredTask(request, task, x);
+      }
+    } finally {
+    }
+  }
+}
+function performWork(request) {
+  var prevDispatcher = ReactSharedInternalsServer.H;
+  ReactSharedInternalsServer.H = HooksDispatcher;
+  var prevRequest = currentRequest;
+  currentRequest$1 = currentRequest = request;
+  var hadAbortableTasks = 0 < request.abortableTasks.size;
+  try {
+    var pingedTasks = request.pingedTasks;
+    request.pingedTasks = [];
+    for (var i = 0; i < pingedTasks.length; i++)
+      retryTask(request, pingedTasks[i]);
+    null !== request.destination &&
+      flushCompletedChunks(request, request.destination);
+    if (hadAbortableTasks && 0 === request.abortableTasks.size) {
+      var onAllReady = request.onAllReady;
+      onAllReady();
+    }
+  } catch (error) {
+    logRecoverableError(request, error, null), fatalError(request, error);
+  } finally {
+    (ReactSharedInternalsServer.H = prevDispatcher),
+      (currentRequest$1 = null),
+      (currentRequest = prevRequest);
+  }
+}
+function abortTask(task, request, errorId) {
+  5 !== task.status &&
+    ((task.status = 3),
+    (errorId = serializeByValueID(errorId)),
+    (task = encodeReferenceChunk(request, task.id, errorId)),
+    request.completedErrorChunks.push(task));
+}
+function flushCompletedChunks(request, destination) {
+  currentView = new Uint8Array(2048);
+  writtenBytes = 0;
+  destinationHasCapacity = !0;
+  try {
+    for (
+      var importsChunks = request.completedImportChunks, i = 0;
+      i < importsChunks.length;
+      i++
+    )
+      if (
+        (request.pendingChunks--,
+        !writeChunkAndReturn(destination, importsChunks[i]))
+      ) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    importsChunks.splice(0, i);
+    var hintChunks = request.completedHintChunks;
+    for (i = 0; i < hintChunks.length; i++)
+      if (!writeChunkAndReturn(destination, hintChunks[i])) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    hintChunks.splice(0, i);
+    var regularChunks = request.completedRegularChunks;
+    for (i = 0; i < regularChunks.length; i++)
+      if (
+        (request.pendingChunks--,
+        !writeChunkAndReturn(destination, regularChunks[i]))
+      ) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    regularChunks.splice(0, i);
+    var errorChunks = request.completedErrorChunks;
+    for (i = 0; i < errorChunks.length; i++)
+      if (
+        (request.pendingChunks--,
+        !writeChunkAndReturn(destination, errorChunks[i]))
+      ) {
+        request.destination = null;
+        i++;
+        break;
+      }
+    errorChunks.splice(0, i);
+  } finally {
+    (request.flushScheduled = !1),
+      currentView &&
+        0 < writtenBytes &&
+        destination.write(currentView.subarray(0, writtenBytes)),
+      (currentView = null),
+      (writtenBytes = 0),
+      (destinationHasCapacity = !0);
+  }
+  "function" === typeof destination.flush && destination.flush();
+  0 === request.pendingChunks &&
+    (cleanupTaintQueue(request),
+    (request.status = 14),
+    destination.end(),
+    (request.destination = null));
+}
+function startWork(request) {
+  request.flushScheduled = null !== request.destination;
+  scheduleMicrotask(function () {
+    requestStorage.run(request, performWork, request);
+  });
+  setImmediate(function () {
+    10 === request.status && (request.status = 11);
+  });
+}
+function enqueueFlush(request) {
+  !1 === request.flushScheduled &&
+    0 === request.pingedTasks.length &&
+    null !== request.destination &&
+    ((request.flushScheduled = !0),
+    setImmediate(function () {
+      request.flushScheduled = !1;
+      var destination = request.destination;
+      destination && flushCompletedChunks(request, destination);
+    }));
+}
+function startFlowing(request, destination) {
+  if (13 === request.status)
+    (request.status = 14), destination.destroy(request.fatalError);
+  else if (14 !== request.status && null === request.destination) {
+    request.destination = destination;
+    try {
+      flushCompletedChunks(request, destination);
+    } catch (error) {
+      logRecoverableError(request, error, null), fatalError(request, error);
+    }
+  }
+}
+function abort(request, reason) {
+  try {
+    11 >= request.status && (request.status = 12);
+    var abortableTasks = request.abortableTasks;
+    if (0 < abortableTasks.size) {
+      if (21 === request.type)
+        abortableTasks.forEach(function (task) {
+          5 !== task.status && ((task.status = 3), request.pendingChunks--);
+        });
+      else if (
+        "object" === typeof reason &&
+        null !== reason &&
+        reason.$$typeof === REACT_POSTPONE_TYPE
+      ) {
+        logPostpone(request, reason.message, null);
+        var errorId = request.nextChunkId++;
+        request.fatalError = errorId;
+        request.pendingChunks++;
+        emitPostponeChunk(request, errorId, reason);
+        abortableTasks.forEach(function (task) {
+          return abortTask(task, request, errorId);
+        });
+      } else {
+        var error =
+            void 0 === reason
+              ? Error("The render was aborted by the server without a reason.")
+              : "object" === typeof reason &&
+                  null !== reason &&
+                  "function" === typeof reason.then
+                ? Error("The render was aborted by the server with a promise.")
+                : reason,
+          digest = logRecoverableError(request, error, null),
+          errorId$25 = request.nextChunkId++;
+        request.fatalError = errorId$25;
+        request.pendingChunks++;
+        emitErrorChunk(request, errorId$25, digest, error);
+        abortableTasks.forEach(function (task) {
+          return abortTask(task, request, errorId$25);
+        });
+      }
+      abortableTasks.clear();
+      var onAllReady = request.onAllReady;
+      onAllReady();
+    }
+    var abortListeners = request.abortListeners;
+    if (0 < abortListeners.size) {
+      var error$26 =
+        "object" === typeof reason &&
+        null !== reason &&
+        reason.$$typeof === REACT_POSTPONE_TYPE
+          ? Error("The render was aborted due to being postponed.")
+          : void 0 === reason
+            ? Error("The render was aborted by the server without a reason.")
+            : "object" === typeof reason &&
+                null !== reason &&
+                "function" === typeof reason.then
+              ? Error("The render was aborted by the server with a promise.")
+              : reason;
+      abortListeners.forEach(function (callback) {
+        return callback(error$26);
+      });
+      abortListeners.clear();
+    }
+    null !== request.destination &&
+      flushCompletedChunks(request, request.destination);
+  } catch (error$27) {
+    logRecoverableError(request, error$27, null), fatalError(request, error$27);
+  }
+}
+function resolveServerReference(config, id) {
+  var idx = id.lastIndexOf("#"),
+    exportName = id.slice(idx + 1);
+  id = id.slice(0, idx);
+  if (!id.startsWith(config))
+    throw Error(
+      "Attempted to load a Server Reference outside the hosted root."
+    );
+  return { specifier: id, name: exportName };
+}
+var asyncModuleCache = new Map();
+function preloadModule(metadata) {
+  var existingPromise = asyncModuleCache.get(metadata.specifier);
+  if (existingPromise)
+    return "fulfilled" === existingPromise.status ? null : existingPromise;
+  var modulePromise = import(metadata.specifier);
+  modulePromise.then(
+    function (value) {
+      modulePromise.status = "fulfilled";
+      modulePromise.value = value;
+    },
+    function (reason) {
+      modulePromise.status = "rejected";
+      modulePromise.reason = reason;
+    }
+  );
+  asyncModuleCache.set(metadata.specifier, modulePromise);
+  return modulePromise;
+}
+function requireModule(metadata) {
+  var moduleExports = asyncModuleCache.get(metadata.specifier);
+  if ("fulfilled" === moduleExports.status) moduleExports = moduleExports.value;
+  else throw moduleExports.reason;
+  return moduleExports[metadata.name];
+}
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function Chunk(status, value, reason, response) {
+  this.status = status;
+  this.value = value;
+  this.reason = reason;
+  this._response = response;
+}
+Chunk.prototype = Object.create(Promise.prototype);
+Chunk.prototype.then = function (resolve, reject) {
+  switch (this.status) {
+    case "resolved_model":
+      initializeModelChunk(this);
+  }
+  switch (this.status) {
+    case "fulfilled":
+      resolve(this.value);
+      break;
+    case "pending":
+    case "blocked":
+    case "cyclic":
+      resolve &&
+        (null === this.value && (this.value = []), this.value.push(resolve));
+      reject &&
+        (null === this.reason && (this.reason = []), this.reason.push(reject));
+      break;
+    default:
+      reject(this.reason);
+  }
+};
+function createPendingChunk(response) {
+  return new Chunk("pending", null, null, response);
+}
+function wakeChunk(listeners, value) {
+  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);
+}
+function triggerErrorOnChunk(chunk, error) {
+  if ("pending" !== chunk.status && "blocked" !== chunk.status)
+    chunk.reason.error(error);
+  else {
+    var listeners = chunk.reason;
+    chunk.status = "rejected";
+    chunk.reason = error;
+    null !== listeners && wakeChunk(listeners, error);
+  }
+}
+function resolveModelChunk(chunk, value, id) {
+  if ("pending" !== chunk.status)
+    (chunk = chunk.reason),
+      "C" === value[0]
+        ? chunk.close("C" === value ? '"$undefined"' : value.slice(1))
+        : chunk.enqueueModel(value);
+  else {
+    var resolveListeners = chunk.value,
+      rejectListeners = chunk.reason;
+    chunk.status = "resolved_model";
+    chunk.value = value;
+    chunk.reason = id;
+    if (null !== resolveListeners)
+      switch ((initializeModelChunk(chunk), chunk.status)) {
+        case "fulfilled":
+          wakeChunk(resolveListeners, chunk.value);
+          break;
+        case "pending":
+        case "blocked":
+        case "cyclic":
+          if (chunk.value)
+            for (value = 0; value < resolveListeners.length; value++)
+              chunk.value.push(resolveListeners[value]);
+          else chunk.value = resolveListeners;
+          if (chunk.reason) {
+            if (rejectListeners)
+              for (value = 0; value < rejectListeners.length; value++)
+                chunk.reason.push(rejectListeners[value]);
+          } else chunk.reason = rejectListeners;
+          break;
+        case "rejected":
+          rejectListeners && wakeChunk(rejectListeners, chunk.reason);
+      }
+  }
+}
+function createResolvedIteratorResultChunk(response, value, done) {
+  return new Chunk(
+    "resolved_model",
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    -1,
+    response
+  );
+}
+function resolveIteratorResultChunk(chunk, value, done) {
+  resolveModelChunk(
+    chunk,
+    (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + "}",
+    -1
+  );
+}
+function loadServerReference$1(
+  response,
+  id,
+  bound,
+  parentChunk,
+  parentObject,
+  key
+) {
+  var serverReference = resolveServerReference(response._bundlerConfig, id);
+  id = preloadModule(serverReference);
+  if (bound)
+    bound = Promise.all([bound, id]).then(function (_ref) {
+      _ref = _ref[0];
+      var fn = requireModule(serverReference);
+      return fn.bind.apply(fn, [null].concat(_ref));
+    });
+  else if (id)
+    bound = Promise.resolve(id).then(function () {
+      return requireModule(serverReference);
+    });
+  else return requireModule(serverReference);
+  bound.then(
+    createModelResolver(
+      parentChunk,
+      parentObject,
+      key,
+      !1,
+      response,
+      createModel,
+      []
+    ),
+    createModelReject(parentChunk)
+  );
+  return null;
+}
+function reviveModel(response, parentObj, parentKey, value, reference) {
+  if ("string" === typeof value)
+    return parseModelString(response, parentObj, parentKey, value, reference);
+  if ("object" === typeof value && null !== value)
+    if (
+      (void 0 !== reference &&
+        void 0 !== response._temporaryReferences &&
+        response._temporaryReferences.set(value, reference),
+      Array.isArray(value))
+    )
+      for (var i = 0; i < value.length; i++)
+        value[i] = reviveModel(
+          response,
+          value,
+          "" + i,
+          value[i],
+          void 0 !== reference ? reference + ":" + i : void 0
+        );
+    else
+      for (i in value)
+        hasOwnProperty.call(value, i) &&
+          ((parentObj =
+            void 0 !== reference && -1 === i.indexOf(":")
+              ? reference + ":" + i
+              : void 0),
+          (parentObj = reviveModel(response, value, i, value[i], parentObj)),
+          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);
+  return value;
+}
+var initializingChunk = null,
+  initializingChunkBlockedModel = null;
+function initializeModelChunk(chunk) {
+  var prevChunk = initializingChunk,
+    prevBlocked = initializingChunkBlockedModel;
+  initializingChunk = chunk;
+  initializingChunkBlockedModel = null;
+  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
+    resolvedModel = chunk.value;
+  chunk.status = "cyclic";
+  chunk.value = null;
+  chunk.reason = null;
+  try {
+    var rawModel = JSON.parse(resolvedModel),
+      value = reviveModel(
+        chunk._response,
+        { "": rawModel },
+        "",
+        rawModel,
+        rootReference
+      );
+    if (
+      null !== initializingChunkBlockedModel &&
+      0 < initializingChunkBlockedModel.deps
+    )
+      (initializingChunkBlockedModel.value = value), (chunk.status = "blocked");
+    else {
+      var resolveListeners = chunk.value;
+      chunk.status = "fulfilled";
+      chunk.value = value;
+      null !== resolveListeners && wakeChunk(resolveListeners, value);
+    }
+  } catch (error) {
+    (chunk.status = "rejected"), (chunk.reason = error);
+  } finally {
+    (initializingChunk = prevChunk),
+      (initializingChunkBlockedModel = prevBlocked);
+  }
+}
+function reportGlobalError(response, error) {
+  response._closed = !0;
+  response._closedReason = error;
+  response._chunks.forEach(function (chunk) {
+    "pending" === chunk.status && triggerErrorOnChunk(chunk, error);
+  });
+}
+function getChunk(response, id) {
+  var chunks = response._chunks,
+    chunk = chunks.get(id);
+  chunk ||
+    ((chunk = response._formData.get(response._prefix + id)),
+    (chunk =
+      null != chunk
+        ? new Chunk("resolved_model", chunk, id, response)
+        : response._closed
+          ? new Chunk("rejected", null, response._closedReason, response)
+          : createPendingChunk(response)),
+    chunks.set(id, chunk));
+  return chunk;
+}
+function createModelResolver(
+  chunk,
+  parentObject,
+  key,
+  cyclic,
+  response,
+  map,
+  path
+) {
+  if (initializingChunkBlockedModel) {
+    var blocked = initializingChunkBlockedModel;
+    cyclic || blocked.deps++;
+  } else
+    blocked = initializingChunkBlockedModel = {
+      deps: cyclic ? 0 : 1,
+      value: null
+    };
+  return function (value) {
+    for (var i = 1; i < path.length; i++) value = value[path[i]];
+    parentObject[key] = map(response, value);
+    "" === key && null === blocked.value && (blocked.value = parentObject[key]);
+    blocked.deps--;
+    0 === blocked.deps &&
+      "blocked" === chunk.status &&
+      ((value = chunk.value),
+      (chunk.status = "fulfilled"),
+      (chunk.value = blocked.value),
+      null !== value && wakeChunk(value, blocked.value));
+  };
+}
+function createModelReject(chunk) {
+  return function (error) {
+    return triggerErrorOnChunk(chunk, error);
+  };
+}
+function getOutlinedModel(response, reference, parentObject, key, map) {
+  reference = reference.split(":");
+  var id = parseInt(reference[0], 16);
+  id = getChunk(response, id);
+  switch (id.status) {
+    case "resolved_model":
+      initializeModelChunk(id);
+  }
+  switch (id.status) {
+    case "fulfilled":
+      parentObject = id.value;
+      for (key = 1; key < reference.length; key++)
+        parentObject = parentObject[reference[key]];
+      return map(response, parentObject);
+    case "pending":
+    case "blocked":
+    case "cyclic":
+      var parentChunk = initializingChunk;
+      id.then(
+        createModelResolver(
+          parentChunk,
+          parentObject,
+          key,
+          "cyclic" === id.status,
+          response,
+          map,
+          reference
+        ),
+        createModelReject(parentChunk)
+      );
+      return null;
+    default:
+      throw id.reason;
+  }
+}
+function createMap(response, model) {
+  return new Map(model);
+}
+function createSet(response, model) {
+  return new Set(model);
+}
+function extractIterator(response, model) {
+  return model[Symbol.iterator]();
+}
+function createModel(response, model) {
+  return model;
+}
+function parseTypedArray(
+  response,
+  reference,
+  constructor,
+  bytesPerElement,
+  parentObject,
+  parentKey
+) {
+  reference = parseInt(reference.slice(2), 16);
+  reference = response._formData.get(response._prefix + reference);
+  reference =
+    constructor === ArrayBuffer
+      ? reference.arrayBuffer()
+      : reference.arrayBuffer().then(function (buffer) {
+          return new constructor(buffer);
+        });
+  bytesPerElement = initializingChunk;
+  reference.then(
+    createModelResolver(
+      bytesPerElement,
+      parentObject,
+      parentKey,
+      !1,
+      response,
+      createModel,
+      []
+    ),
+    createModelReject(bytesPerElement)
+  );
+  return null;
+}
+function resolveStream(response, id, stream, controller) {
+  var chunks = response._chunks;
+  stream = new Chunk("fulfilled", stream, controller, response);
+  chunks.set(id, stream);
+  response = response._formData.getAll(response._prefix + id);
+  for (id = 0; id < response.length; id++)
+    (chunks = response[id]),
+      "C" === chunks[0]
+        ? controller.close("C" === chunks ? '"$undefined"' : chunks.slice(1))
+        : controller.enqueueModel(chunks);
+}
+function parseReadableStream(response, reference, type) {
+  reference = parseInt(reference.slice(2), 16);
+  var controller = null;
+  type = new ReadableStream({
+    type: type,
+    start: function (c) {
+      controller = c;
+    }
+  });
+  var previousBlockedChunk = null;
+  resolveStream(response, reference, type, {
+    enqueueModel: function (json) {
+      if (null === previousBlockedChunk) {
+        var chunk = new Chunk("resolved_model", json, -1, response);
+        initializeModelChunk(chunk);
+        "fulfilled" === chunk.status
+          ? controller.enqueue(chunk.value)
+          : (chunk.then(
+              function (v) {
+                return controller.enqueue(v);
+              },
+              function (e) {
+                return controller.error(e);
+              }
+            ),
+            (previousBlockedChunk = chunk));
+      } else {
+        chunk = previousBlockedChunk;
+        var chunk$30 = createPendingChunk(response);
+        chunk$30.then(
+          function (v) {
+            return controller.enqueue(v);
+          },
+          function (e) {
+            return controller.error(e);
+          }
+        );
+        previousBlockedChunk = chunk$30;
+        chunk.then(function () {
+          previousBlockedChunk === chunk$30 && (previousBlockedChunk = null);
+          resolveModelChunk(chunk$30, json, -1);
+        });
+      }
+    },
+    close: function () {
+      if (null === previousBlockedChunk) controller.close();
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.close();
+        });
+      }
+    },
+    error: function (error) {
+      if (null === previousBlockedChunk) controller.error(error);
+      else {
+        var blockedChunk = previousBlockedChunk;
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.error(error);
+        });
+      }
+    }
+  });
+  return type;
+}
+function asyncIterator() {
+  return this;
+}
+function createIterator(next) {
+  next = { next: next };
+  next[ASYNC_ITERATOR] = asyncIterator;
+  return next;
+}
+function parseAsyncIterable(response, reference, iterator) {
+  reference = parseInt(reference.slice(2), 16);
+  var buffer = [],
+    closed = !1,
+    nextWriteIndex = 0,
+    $jscomp$compprop2 = {};
+  $jscomp$compprop2 =
+    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {
+      var nextReadIndex = 0;
+      return createIterator(function (arg) {
+        if (void 0 !== arg)
+          throw Error(
+            "Values cannot be passed to next() of AsyncIterables passed to Client Components."
+          );
+        if (nextReadIndex === buffer.length) {
+          if (closed)
+            return new Chunk(
+              "fulfilled",
+              { done: !0, value: void 0 },
+              null,
+              response
+            );
+          buffer[nextReadIndex] = createPendingChunk(response);
+        }
+        return buffer[nextReadIndex++];
+      });
+    }),
+    $jscomp$compprop2);
+  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;
+  resolveStream(response, reference, iterator, {
+    enqueueModel: function (value) {
+      nextWriteIndex === buffer.length
+        ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+            response,
+            value,
+            !1
+          ))
+        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);
+      nextWriteIndex++;
+    },
+    close: function (value) {
+      closed = !0;
+      nextWriteIndex === buffer.length
+        ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(
+            response,
+            value,
+            !0
+          ))
+        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);
+      for (nextWriteIndex++; nextWriteIndex < buffer.length; )
+        resolveIteratorResultChunk(
+          buffer[nextWriteIndex++],
+          '"$undefined"',
+          !0
+        );
+    },
+    error: function (error) {
+      closed = !0;
+      for (
+        nextWriteIndex === buffer.length &&
+        (buffer[nextWriteIndex] = createPendingChunk(response));
+        nextWriteIndex < buffer.length;
+
+      )
+        triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+    }
+  });
+  return iterator;
+}
+function parseModelString(response, obj, key, value, reference) {
+  if ("$" === value[0]) {
+    switch (value[1]) {
+      case "$":
+        return value.slice(1);
+      case "@":
+        return (obj = parseInt(value.slice(2), 16)), getChunk(response, obj);
+      case "F":
+        return (
+          (value = value.slice(2)),
+          (value = getOutlinedModel(response, value, obj, key, createModel)),
+          loadServerReference$1(
+            response,
+            value.id,
+            value.bound,
+            initializingChunk,
+            obj,
+            key
+          )
+        );
+      case "T":
+        if (void 0 === reference || void 0 === response._temporaryReferences)
+          throw Error(
+            "Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server."
+          );
+        return createTemporaryReference(
+          response._temporaryReferences,
+          reference
+        );
+      case "Q":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, obj, key, createMap)
+        );
+      case "W":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, obj, key, createSet)
+        );
+      case "K":
+        obj = value.slice(2);
+        var formPrefix = response._prefix + obj + "_",
+          data = new FormData();
+        response._formData.forEach(function (entry, entryKey) {
+          entryKey.startsWith(formPrefix) &&
+            data.append(entryKey.slice(formPrefix.length), entry);
+        });
+        return data;
+      case "i":
+        return (
+          (value = value.slice(2)),
+          getOutlinedModel(response, value, obj, key, extractIterator)
+        );
+      case "I":
+        return Infinity;
+      case "-":
+        return "$-0" === value ? -0 : -Infinity;
+      case "N":
+        return NaN;
+      case "u":
+        return;
+      case "D":
+        return new Date(Date.parse(value.slice(2)));
+      case "n":
+        return BigInt(value.slice(2));
+    }
+    switch (value[1]) {
+      case "A":
+        return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);
+      case "O":
+        return parseTypedArray(response, value, Int8Array, 1, obj, key);
+      case "o":
+        return parseTypedArray(response, value, Uint8Array, 1, obj, key);
+      case "U":
+        return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);
+      case "S":
+        return parseTypedArray(response, value, Int16Array, 2, obj, key);
+      case "s":
+        return parseTypedArray(response, value, Uint16Array, 2, obj, key);
+      case "L":
+        return parseTypedArray(response, value, Int32Array, 4, obj, key);
+      case "l":
+        return parseTypedArray(response, value, Uint32Array, 4, obj, key);
+      case "G":
+        return parseTypedArray(response, value, Float32Array, 4, obj, key);
+      case "g":
+        return parseTypedArray(response, value, Float64Array, 8, obj, key);
+      case "M":
+        return parseTypedArray(response, value, BigInt64Array, 8, obj, key);
+      case "m":
+        return parseTypedArray(response, value, BigUint64Array, 8, obj, key);
+      case "V":
+        return parseTypedArray(response, value, DataView, 1, obj, key);
+      case "B":
+        return (
+          (obj = parseInt(value.slice(2), 16)),
+          response._formData.get(response._prefix + obj)
+        );
+    }
+    switch (value[1]) {
+      case "R":
+        return parseReadableStream(response, value, void 0);
+      case "r":
+        return parseReadableStream(response, value, "bytes");
+      case "X":
+        return parseAsyncIterable(response, value, !1);
+      case "x":
+        return parseAsyncIterable(response, value, !0);
+    }
+    value = value.slice(1);
+    return getOutlinedModel(response, value, obj, key, createModel);
+  }
+  return value;
+}
+function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {
+  var backingFormData =
+      3 < arguments.length && void 0 !== arguments[3]
+        ? arguments[3]
+        : new FormData(),
+    chunks = new Map();
+  return {
+    _bundlerConfig: bundlerConfig,
+    _prefix: formFieldPrefix,
+    _formData: backingFormData,
+    _chunks: chunks,
+    _closed: !1,
+    _closedReason: null,
+    _temporaryReferences: temporaryReferences
+  };
+}
+function resolveField(response, key, value) {
+  response._formData.append(key, value);
+  var prefix = response._prefix;
+  key.startsWith(prefix) &&
+    ((response = response._chunks),
+    (key = +key.slice(prefix.length)),
+    (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
+}
+function close(response) {
+  reportGlobalError(response, Error("Connection closed."));
+}
+function loadServerReference(bundlerConfig, id, bound) {
+  var serverReference = resolveServerReference(bundlerConfig, id);
+  bundlerConfig = preloadModule(serverReference);
+  return bound
+    ? Promise.all([bound, bundlerConfig]).then(function (_ref) {
+        _ref = _ref[0];
+        var fn = requireModule(serverReference);
+        return fn.bind.apply(fn, [null].concat(_ref));
+      })
+    : bundlerConfig
+      ? Promise.resolve(bundlerConfig).then(function () {
+          return requireModule(serverReference);
+        })
+      : Promise.resolve(requireModule(serverReference));
+}
+function decodeBoundActionMetaData(body, serverManifest, formFieldPrefix) {
+  body = createResponse(serverManifest, formFieldPrefix, void 0, body);
+  close(body);
+  body = getChunk(body, 0);
+  body.then(function () {});
+  if ("fulfilled" !== body.status) throw body.reason;
+  return body.value;
+}
+function createDrainHandler(destination, request) {
+  return function () {
+    return startFlowing(request, destination);
+  };
+}
+function createCancelHandler(request, reason) {
+  return function () {
+    request.destination = null;
+    abort(request, Error(reason));
+  };
+}
+function createFakeWritable(readable) {
+  return {
+    write: function (chunk) {
+      return readable.push(chunk);
+    },
+    end: function () {
+      readable.push(null);
+    },
+    destroy: function (error) {
+      readable.destroy(error);
+    }
+  };
+}
+exports.createTemporaryReferenceSet = function () {
+  return new WeakMap();
+};
+exports.decodeAction = function (body, serverManifest) {
+  var formData = new FormData(),
+    action = null;
+  body.forEach(function (value, key) {
+    key.startsWith("$ACTION_")
+      ? key.startsWith("$ACTION_REF_")
+        ? ((value = "$ACTION_" + key.slice(12) + ":"),
+          (value = decodeBoundActionMetaData(body, serverManifest, value)),
+          (action = loadServerReference(serverManifest, value.id, value.bound)))
+        : key.startsWith("$ACTION_ID_") &&
+          ((value = key.slice(11)),
+          (action = loadServerReference(serverManifest, value, null)))
+      : formData.append(key, value);
+  });
+  return null === action
+    ? null
+    : action.then(function (fn) {
+        return fn.bind(null, formData);
+      });
+};
+exports.decodeFormState = function (actionResult, body, serverManifest) {
+  var keyPath = body.get("$ACTION_KEY");
+  if ("string" !== typeof keyPath) return Promise.resolve(null);
+  var metaData = null;
+  body.forEach(function (value, key) {
+    key.startsWith("$ACTION_REF_") &&
+      ((value = "$ACTION_" + key.slice(12) + ":"),
+      (metaData = decodeBoundActionMetaData(body, serverManifest, value)));
+  });
+  if (null === metaData) return Promise.resolve(null);
+  var referenceId = metaData.id;
+  return Promise.resolve(metaData.bound).then(function (bound) {
+    return null === bound
+      ? null
+      : [actionResult, keyPath, referenceId, bound.length - 1];
+  });
+};
+exports.decodeReply = function (body, moduleBasePath, options) {
+  if ("string" === typeof body) {
+    var form = new FormData();
+    form.append("0", body);
+    body = form;
+  }
+  body = createResponse(
+    moduleBasePath,
+    "",
+    options ? options.temporaryReferences : void 0,
+    body
+  );
+  moduleBasePath = getChunk(body, 0);
+  close(body);
+  return moduleBasePath;
+};
+exports.decodeReplyFromBusboy = function (
+  busboyStream,
+  moduleBasePath,
+  options
+) {
+  var response = createResponse(
+      moduleBasePath,
+      "",
+      options ? options.temporaryReferences : void 0
+    ),
+    pendingFiles = 0,
+    queuedFields = [];
+  busboyStream.on("field", function (name, value) {
+    0 < pendingFiles
+      ? queuedFields.push(name, value)
+      : resolveField(response, name, value);
+  });
+  busboyStream.on("file", function (name, value, _ref) {
+    var filename = _ref.filename,
+      mimeType = _ref.mimeType;
+    if ("base64" === _ref.encoding.toLowerCase())
+      throw Error(
+        "React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it."
+      );
+    pendingFiles++;
+    var JSCompiler_object_inline_chunks_236 = [];
+    value.on("data", function (chunk) {
+      JSCompiler_object_inline_chunks_236.push(chunk);
+    });
+    value.on("end", function () {
+      var blob = new Blob(JSCompiler_object_inline_chunks_236, {
+        type: mimeType
+      });
+      response._formData.append(name, blob, filename);
+      pendingFiles--;
+      if (0 === pendingFiles) {
+        for (blob = 0; blob < queuedFields.length; blob += 2)
+          resolveField(response, queuedFields[blob], queuedFields[blob + 1]);
+        queuedFields.length = 0;
+      }
+    });
+  });
+  busboyStream.on("finish", function () {
+    close(response);
+  });
+  busboyStream.on("error", function (err) {
+    reportGlobalError(response, err);
+  });
+  return getChunk(response, 0);
+};
+exports.registerClientReference = function (
+  proxyImplementation,
+  id,
+  exportName
+) {
+  return Object.defineProperties(proxyImplementation, {
+    $$typeof: { value: CLIENT_REFERENCE_TAG$1 },
+    $$id: { value: id + "#" + exportName }
+  });
+};
+exports.registerServerReference = function (reference, id, exportName) {
+  return Object.defineProperties(reference, {
+    $$typeof: { value: SERVER_REFERENCE_TAG },
+    $$id: { value: id + "#" + exportName, configurable: !0 },
+    $$bound: { value: null, configurable: !0 },
+    bind: { value: bind, configurable: !0 }
+  });
+};
+exports.renderToPipeableStream = function (model, moduleBasePath, options) {
+  var request = new RequestInstance(
+      20,
+      model,
+      moduleBasePath,
+      options ? options.onError : void 0,
+      options ? options.identifierPrefix : void 0,
+      options ? options.onPostpone : void 0,
+      options ? options.temporaryReferences : void 0,
+      void 0,
+      void 0,
+      noop,
+      noop
+    ),
+    hasStartedFlowing = !1;
+  startWork(request);
+  return {
+    pipe: function (destination) {
+      if (hasStartedFlowing)
+        throw Error(
+          "React currently only supports piping to one writable stream."
+        );
+      hasStartedFlowing = !0;
+      startFlowing(request, destination);
+      destination.on("drain", createDrainHandler(destination, request));
+      destination.on(
+        "error",
+        createCancelHandler(
+          request,
+          "The destination stream errored while writing data."
+        )
+      );
+      destination.on(
+        "close",
+        createCancelHandler(request, "The destination stream closed early.")
+      );
+      return destination;
+    },
+    abort: function (reason) {
+      abort(request, reason);
+    }
+  };
+};
+exports.unstable_prerenderToNodeStream = function (
+  model,
+  moduleBasePath,
+  options
+) {
+  return new Promise(function (resolve, reject) {
+    var request = new RequestInstance(
+      21,
+      model,
+      moduleBasePath,
+      options ? options.onError : void 0,
+      options ? options.identifierPrefix : void 0,
+      options ? options.onPostpone : void 0,
+      options ? options.temporaryReferences : void 0,
+      void 0,
+      void 0,
+      function () {
+        var readable = new stream.Readable({
+            read: function () {
+              startFlowing(request, writable);
+            }
+          }),
+          writable = createFakeWritable(readable);
+        resolve({ prelude: readable });
+      },
+      reject
+    );
+    if (options && options.signal) {
+      var signal = options.signal;
+      if (signal.aborted) abort(request, signal.reason);
+      else {
+        var listener = function () {
+          abort(request, signal.reason);
+          signal.removeEventListener("abort", listener);
+        };
+        signal.addEventListener("abort", listener);
+      }
+    }
+    startWork(request);
+  });
+};
diff --git a/node_modules/react-server-dom-esm/client.browser.js b/node_modules/react-server-dom-esm/client.browser.js
new file mode 100644
index 0000000..b189a8c
--- /dev/null
+++ b/node_modules/react-server-dom-esm/client.browser.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === 'production') {
+  module.exports = require('./cjs/react-server-dom-esm-client.browser.production.js');
+} else {
+  module.exports = require('./cjs/react-server-dom-esm-client.browser.development.js');
+}
diff --git a/node_modules/react-server-dom-esm/client.js b/node_modules/react-server-dom-esm/client.js
new file mode 100644
index 0000000..89d93a7
--- /dev/null
+++ b/node_modules/react-server-dom-esm/client.js
@@ -0,0 +1,3 @@
+'use strict';
+
+module.exports = require('./client.browser');
diff --git a/node_modules/react-server-dom-esm/client.node.js b/node_modules/react-server-dom-esm/client.node.js
new file mode 100644
index 0000000..afd623e
--- /dev/null
+++ b/node_modules/react-server-dom-esm/client.node.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === 'production') {
+  module.exports = require('./cjs/react-server-dom-esm-client.node.production.js');
+} else {
+  module.exports = require('./cjs/react-server-dom-esm-client.node.development.js');
+}
diff --git a/node_modules/react-server-dom-esm/esm/package.json b/node_modules/react-server-dom-esm/esm/package.json
new file mode 100644
index 0000000..3dbc1ca
--- /dev/null
+++ b/node_modules/react-server-dom-esm/esm/package.json
@@ -0,0 +1,3 @@
+{
+  "type": "module"
+}
diff --git a/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.development.js b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.development.js
new file mode 100644
index 0000000..aa968f4
--- /dev/null
+++ b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.development.js
@@ -0,0 +1,4805 @@
+/**
+* @license React
+ * react-server-dom-esm-client.browser.development.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import * as React from 'react';
+import * as ReactDOM from 'react-dom';
+
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+
+  return obj;
+}
+
+var ReactVersion = '19.1.0-experimental-b3a95caf-20250113';
+
+function createStringDecoder() {
+  return new TextDecoder();
+}
+var decoderOptions = {
+  stream: true
+};
+function readPartialStringChunk(decoder, buffer) {
+  return decoder.decode(buffer, decoderOptions);
+}
+function readFinalStringChunk(decoder, buffer) {
+  return decoder.decode(buffer);
+}
+
+var badgeFormat = '%c%s%c '; // Same badge styling as DevTools.
+
+var badgeStyle = // We use a fixed background if light-dark is not supported, otherwise
+// we use a transparent background.
+'background: #e6e6e6;' + 'background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));' + 'color: #000000;' + 'color: light-dark(#000000, #ffffff);' + 'border-radius: 2px';
+var resetStyle = '';
+var pad = ' ';
+var bind = Function.prototype.bind;
+function bindToConsole(methodName, args, badgeName) {
+  var offset = 0;
+
+  switch (methodName) {
+    case 'dir':
+    case 'dirxml':
+    case 'groupEnd':
+    case 'table':
+      {
+        // These methods cannot be colorized because they don't take a formatting string.
+        // $FlowFixMe
+        return bind.apply(console[methodName], [console].concat(args)); // eslint-disable-line react-internal/no-production-logging
+      }
+
+    case 'assert':
+      {
+        // assert takes formatting options as the second argument.
+        offset = 1;
+      }
+  }
+
+  var newArgs = args.slice(0);
+
+  if (typeof newArgs[offset] === 'string') {
+    newArgs.splice(offset, 1, badgeFormat + newArgs[offset], badgeStyle, pad + badgeName + pad, resetStyle);
+  } else {
+    newArgs.splice(offset, 0, badgeFormat, badgeStyle, pad + badgeName + pad, resetStyle);
+  } // The "this" binding in the "bind";
+
+
+  newArgs.unshift(console); // $FlowFixMe
+
+  return bind.apply(console[methodName], newArgs); // eslint-disable-line react-internal/no-production-logging
+}
+
+// Module root path
+// Module root path
+function resolveClientReference(bundlerConfig, metadata) {
+  var baseURL = bundlerConfig;
+  return {
+    specifier: baseURL + metadata[0],
+    name: metadata[1]
+  };
+}
+function resolveServerReference(config, id) {
+  var baseURL = config;
+  var idx = id.lastIndexOf('#');
+  var exportName = id.slice(idx + 1);
+  var fullURL = id.slice(0, idx);
+
+  if (!fullURL.startsWith(baseURL)) {
+    throw new Error('Attempted to load a Server Reference outside the hosted root.');
+  }
+
+  return {
+    specifier: fullURL,
+    name: exportName
+  };
+}
+var asyncModuleCache = new Map();
+function preloadModule(metadata) {
+  var existingPromise = asyncModuleCache.get(metadata.specifier);
+
+  if (existingPromise) {
+    if (existingPromise.status === 'fulfilled') {
+      return null;
+    }
+
+    return existingPromise;
+  } else {
+    // $FlowFixMe[unsupported-syntax]
+    var modulePromise = import(metadata.specifier);
+    modulePromise.then(function (value) {
+      var fulfilledThenable = modulePromise;
+      fulfilledThenable.status = 'fulfilled';
+      fulfilledThenable.value = value;
+    }, function (reason) {
+      var rejectedThenable = modulePromise;
+      rejectedThenable.status = 'rejected';
+      rejectedThenable.reason = reason;
+    });
+    asyncModuleCache.set(metadata.specifier, modulePromise);
+    return modulePromise;
+  }
+}
+function requireModule(metadata) {
+  var moduleExports; // We assume that preloadModule has been called before, which
+  // should have added something to the module cache.
+
+  var promise = asyncModuleCache.get(metadata.specifier);
+
+  if (promise.status === 'fulfilled') {
+    moduleExports = promise.value;
+  } else {
+    throw promise.reason;
+  }
+
+  return moduleExports[metadata.name];
+}
+
+var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+// This client file is in the shared folder because it applies to both SSR and browser contexts.
+// It is the configuration of the FlightClient behavior which can run in either environment.
+function dispatchHint(code, model) {
+  var dispatcher = ReactDOMSharedInternals.d;
+  /* ReactDOMCurrentDispatcher */
+
+  switch (code) {
+    case 'D':
+      {
+        var refined = refineModel(code, model);
+        var href = refined;
+        dispatcher.D(
+        /* prefetchDNS */
+        href);
+        return;
+      }
+
+    case 'C':
+      {
+        var _refined = refineModel(code, model);
+
+        if (typeof _refined === 'string') {
+          var _href = _refined;
+          dispatcher.C(
+          /* preconnect */
+          _href);
+        } else {
+          var _href2 = _refined[0];
+          var crossOrigin = _refined[1];
+          dispatcher.C(
+          /* preconnect */
+          _href2, crossOrigin);
+        }
+
+        return;
+      }
+
+    case 'L':
+      {
+        var _refined2 = refineModel(code, model);
+
+        var _href3 = _refined2[0];
+        var as = _refined2[1];
+
+        if (_refined2.length === 3) {
+          var options = _refined2[2];
+          dispatcher.L(
+          /* preload */
+          _href3, as, options);
+        } else {
+          dispatcher.L(
+          /* preload */
+          _href3, as);
+        }
+
+        return;
+      }
+
+    case 'm':
+      {
+        var _refined3 = refineModel(code, model);
+
+        if (typeof _refined3 === 'string') {
+          var _href4 = _refined3;
+          dispatcher.m(
+          /* preloadModule */
+          _href4);
+        } else {
+          var _href5 = _refined3[0];
+          var _options = _refined3[1];
+          dispatcher.m(
+          /* preloadModule */
+          _href5, _options);
+        }
+
+        return;
+      }
+
+    case 'X':
+      {
+        var _refined4 = refineModel(code, model);
+
+        if (typeof _refined4 === 'string') {
+          var _href6 = _refined4;
+          dispatcher.X(
+          /* preinitScript */
+          _href6);
+        } else {
+          var _href7 = _refined4[0];
+          var _options2 = _refined4[1];
+          dispatcher.X(
+          /* preinitScript */
+          _href7, _options2);
+        }
+
+        return;
+      }
+
+    case 'S':
+      {
+        var _refined5 = refineModel(code, model);
+
+        if (typeof _refined5 === 'string') {
+          var _href8 = _refined5;
+          dispatcher.S(
+          /* preinitStyle */
+          _href8);
+        } else {
+          var _href9 = _refined5[0];
+          var precedence = _refined5[1] === 0 ? undefined : _refined5[1];
+
+          var _options3 = _refined5.length === 3 ? _refined5[2] : undefined;
+
+          dispatcher.S(
+          /* preinitStyle */
+          _href9, precedence, _options3);
+        }
+
+        return;
+      }
+
+    case 'M':
+      {
+        var _refined6 = refineModel(code, model);
+
+        if (typeof _refined6 === 'string') {
+          var _href10 = _refined6;
+          dispatcher.M(
+          /* preinitModuleScript */
+          _href10);
+        } else {
+          var _href11 = _refined6[0];
+          var _options4 = _refined6[1];
+          dispatcher.M(
+          /* preinitModuleScript */
+          _href11, _options4);
+        }
+
+        return;
+      }
+  }
+} // Flow is having trouble refining the HintModels so we help it a bit.
+// This should be compiled out in the production build.
+
+function refineModel(code, model) {
+  return model;
+}
+
+var rendererPackageName = 'react-server-dom-esm';
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext
+
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+var FAUX_ITERATOR_SYMBOL = '@@iterator';
+function getIteratorFn(maybeIterable) {
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+
+  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+
+  return null;
+}
+var ASYNC_ITERATOR = Symbol.asyncIterator;
+
+var isArrayImpl = Array.isArray;
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var getPrototypeOf = Object.getPrototypeOf;
+
+// in case they error.
+
+var jsxPropsParents = new WeakMap();
+var jsxChildrenParents = new WeakMap();
+
+function isObjectPrototype(object) {
+  if (!object) {
+    return false;
+  }
+
+  var ObjectPrototype = Object.prototype;
+
+  if (object === ObjectPrototype) {
+    return true;
+  } // It might be an object from a different Realm which is
+  // still just a plain simple object.
+
+
+  if (getPrototypeOf(object)) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    if (!(names[i] in ObjectPrototype)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+function isSimpleObject(object) {
+  if (!isObjectPrototype(getPrototypeOf(object))) {
+    return false;
+  }
+
+  var names = Object.getOwnPropertyNames(object);
+
+  for (var i = 0; i < names.length; i++) {
+    var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);
+
+    if (!descriptor) {
+      return false;
+    }
+
+    if (!descriptor.enumerable) {
+      if ((names[i] === 'key' || names[i] === 'ref') && typeof descriptor.get === 'function') {
+        // React adds key and ref getters to props objects to issue warnings.
+        // Those getters will not be transferred to the client, but that's ok,
+        // so we'll special case them.
+        continue;
+      }
+
+      return false;
+    }
+  }
+
+  return true;
+}
+function objectName(object) {
+  // $FlowFixMe[method-unbinding]
+  var name = Object.prototype.toString.call(object);
+  return name.replace(/^\[object (.*)\]$/, function (m, p0) {
+    return p0;
+  });
+}
+
+function describeKeyForErrorMessage(key) {
+  var encodedKey = JSON.stringify(key);
+  return '"' + key + '"' === encodedKey ? key : encodedKey;
+}
+
+function describeValueForErrorMessage(value) {
+  switch (typeof value) {
+    case 'string':
+      {
+        return JSON.stringify(value.length <= 10 ? value : value.slice(0, 10) + '...');
+      }
+
+    case 'object':
+      {
+        if (isArray(value)) {
+          return '[...]';
+        }
+
+        if (value !== null && value.$$typeof === CLIENT_REFERENCE_TAG) {
+          return describeClientReference();
+        }
+
+        var name = objectName(value);
+
+        if (name === 'Object') {
+          return '{...}';
+        }
+
+        return name;
+      }
+
+    case 'function':
+      {
+        if (value.$$typeof === CLIENT_REFERENCE_TAG) {
+          return describeClientReference();
+        }
+
+        var _name = value.displayName || value.name;
+
+        return _name ? 'function ' + _name : 'function';
+      }
+
+    default:
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      return String(value);
+  }
+}
+
+function describeElementType(type) {
+  if (typeof type === 'string') {
+    return type;
+  }
+
+  switch (type) {
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
+      }
+
+  }
+
+  if (typeof type === 'object') {
+    switch (type.$$typeof) {
+      case REACT_FORWARD_REF_TYPE:
+        return describeElementType(type.render);
+
+      case REACT_MEMO_TYPE:
+        return describeElementType(type.type);
+
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+
+          try {
+            // Lazy may contain any component type so we recursively resolve it.
+            return describeElementType(init(payload));
+          } catch (x) {}
+        }
+    }
+  }
+
+  return '';
+}
+
+var CLIENT_REFERENCE_TAG = Symbol.for('react.client.reference');
+
+function describeClientReference(ref) {
+  return 'client';
+}
+
+function describeObjectForErrorMessage(objectOrArray, expandedName) {
+  var objKind = objectName(objectOrArray);
+
+  if (objKind !== 'Object' && objKind !== 'Array') {
+    return objKind;
+  }
+
+  var str = '';
+  var start = -1;
+  var length = 0;
+
+  if (isArray(objectOrArray)) {
+    if (jsxChildrenParents.has(objectOrArray)) {
+      // Print JSX Children
+      var type = jsxChildrenParents.get(objectOrArray);
+      str = '<' + describeElementType(type) + '>';
+      var array = objectOrArray;
+
+      for (var i = 0; i < array.length; i++) {
+        var value = array[i];
+        var substr = void 0;
+
+        if (typeof value === 'string') {
+          substr = value;
+        } else if (typeof value === 'object' && value !== null) {
+          substr = '{' + describeObjectForErrorMessage(value) + '}';
+        } else {
+          substr = '{' + describeValueForErrorMessage(value) + '}';
+        }
+
+        if ('' + i === expandedName) {
+          start = str.length;
+          length = substr.length;
+          str += substr;
+        } else if (substr.length < 15 && str.length + substr.length < 40) {
+          str += substr;
+        } else {
+          str += '{...}';
+        }
+      }
+
+      str += '</' + describeElementType(type) + '>';
+    } else {
+      // Print Array
+      str = '[';
+      var _array = objectOrArray;
+
+      for (var _i = 0; _i < _array.length; _i++) {
+        if (_i > 0) {
+          str += ', ';
+        }
+
+        var _value = _array[_i];
+
+        var _substr = void 0;
+
+        if (typeof _value === 'object' && _value !== null) {
+          _substr = describeObjectForErrorMessage(_value);
+        } else {
+          _substr = describeValueForErrorMessage(_value);
+        }
+
+        if ('' + _i === expandedName) {
+          start = str.length;
+          length = _substr.length;
+          str += _substr;
+        } else if (_substr.length < 10 && str.length + _substr.length < 40) {
+          str += _substr;
+        } else {
+          str += '...';
+        }
+      }
+
+      str += ']';
+    }
+  } else {
+    if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) {
+      str = '<' + describeElementType(objectOrArray.type) + '/>';
+    } else if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) {
+      return describeClientReference();
+    } else if (jsxPropsParents.has(objectOrArray)) {
+      // Print JSX
+      var _type = jsxPropsParents.get(objectOrArray);
+
+      str = '<' + (describeElementType(_type) || '...');
+      var object = objectOrArray;
+      var names = Object.keys(object);
+
+      for (var _i2 = 0; _i2 < names.length; _i2++) {
+        str += ' ';
+        var name = names[_i2];
+        str += describeKeyForErrorMessage(name) + '=';
+        var _value2 = object[name];
+
+        var _substr2 = void 0;
+
+        if (name === expandedName && typeof _value2 === 'object' && _value2 !== null) {
+          _substr2 = describeObjectForErrorMessage(_value2);
+        } else {
+          _substr2 = describeValueForErrorMessage(_value2);
+        }
+
+        if (typeof _value2 !== 'string') {
+          _substr2 = '{' + _substr2 + '}';
+        }
+
+        if (name === expandedName) {
+          start = str.length;
+          length = _substr2.length;
+          str += _substr2;
+        } else if (_substr2.length < 10 && str.length + _substr2.length < 40) {
+          str += _substr2;
+        } else {
+          str += '...';
+        }
+      }
+
+      str += '>';
+    } else {
+      // Print Object
+      str = '{';
+      var _object = objectOrArray;
+
+      var _names = Object.keys(_object);
+
+      for (var _i3 = 0; _i3 < _names.length; _i3++) {
+        if (_i3 > 0) {
+          str += ', ';
+        }
+
+        var _name2 = _names[_i3];
+        str += describeKeyForErrorMessage(_name2) + ': ';
+        var _value3 = _object[_name2];
+
+        var _substr3 = void 0;
+
+        if (typeof _value3 === 'object' && _value3 !== null) {
+          _substr3 = describeObjectForErrorMessage(_value3);
+        } else {
+          _substr3 = describeValueForErrorMessage(_value3);
+        }
+
+        if (_name2 === expandedName) {
+          start = str.length;
+          length = _substr3.length;
+          str += _substr3;
+        } else if (_substr3.length < 10 && str.length + _substr3.length < 40) {
+          str += _substr3;
+        } else {
+          str += '...';
+        }
+      }
+
+      str += '}';
+    }
+  }
+
+  if (expandedName === undefined) {
+    return str;
+  }
+
+  if (start > -1 && length > 0) {
+    var highlight = ' '.repeat(start) + '^'.repeat(length);
+    return '\n  ' + str + '\n  ' + highlight;
+  }
+
+  return '\n  ' + str;
+}
+
+function createTemporaryReferenceSet() {
+  return new Map();
+}
+function writeTemporaryReference(set, reference, object) {
+  set.set(reference, object);
+}
+function readTemporaryReference(set, reference) {
+  return set.get(reference);
+}
+
+var ObjectPrototype = Object.prototype;
+var knownServerReferences = new WeakMap(); // Serializable values
+// Thenable<ReactServerValue>
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializePromiseID(id) {
+  return '$@' + id.toString(16);
+}
+
+function serializeServerReferenceID(id) {
+  return '$F' + id.toString(16);
+}
+
+function serializeTemporaryReferenceMarker() {
+  return '$T';
+}
+
+function serializeFormDataReference(id) {
+  // Why K? F is "Function". D is "Date". What else?
+  return '$K' + id.toString(16);
+}
+
+function serializeNumber(number) {
+  if (Number.isFinite(number)) {
+    if (number === 0 && 1 / number === -Infinity) {
+      return '$-0';
+    } else {
+      return number;
+    }
+  } else {
+    if (number === Infinity) {
+      return '$Infinity';
+    } else if (number === -Infinity) {
+      return '$-Infinity';
+    } else {
+      return '$NaN';
+    }
+  }
+}
+
+function serializeUndefined() {
+  return '$undefined';
+}
+
+function serializeDateFromDateJSON(dateJSON) {
+  // JSON.stringify automatically calls Date.prototype.toJSON which calls toISOString.
+  // We need only tack on a $D prefix.
+  return '$D' + dateJSON;
+}
+
+function serializeBigInt(n) {
+  return '$n' + n.toString(10);
+}
+
+function serializeMapID(id) {
+  return '$Q' + id.toString(16);
+}
+
+function serializeSetID(id) {
+  return '$W' + id.toString(16);
+}
+
+function serializeBlobID(id) {
+  return '$B' + id.toString(16);
+}
+
+function serializeIteratorID(id) {
+  return '$i' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$') {
+    // We need to escape $ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function processReply(root, formFieldPrefix, temporaryReferences, resolve, reject) {
+  var nextPartId = 1;
+  var pendingParts = 0;
+  var formData = null;
+  var writtenObjects = new WeakMap();
+  var modelRoot = root;
+
+  function serializeTypedArray(tag, typedArray) {
+    var blob = new Blob([// We should be able to pass the buffer straight through but Node < 18 treat
+    // multi-byte array blobs differently so we first convert it to single-byte.
+    new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)]);
+    var blobId = nextPartId++;
+
+    if (formData === null) {
+      formData = new FormData();
+    }
+
+    formData.append(formFieldPrefix + blobId, blob);
+    return '$' + tag + blobId.toString(16);
+  }
+
+  function serializeBinaryReader(reader) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+    var buffer = [];
+
+    function progress(entry) {
+      if (entry.done) {
+        var blobId = nextPartId++;
+        data.append(formFieldPrefix + blobId, new Blob(buffer));
+        data.append(formFieldPrefix + streamId, '"$o' + blobId.toString(16) + '"');
+        data.append(formFieldPrefix + streamId, 'C'); // Close signal
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        buffer.push(entry.value);
+        reader.read(new Uint8Array(1024)).then(progress, reject);
+      }
+    }
+
+    reader.read(new Uint8Array(1024)).then(progress, reject);
+    return '$r' + streamId.toString(16);
+  }
+
+  function serializeReader(reader) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++;
+
+    function progress(entry) {
+      if (entry.done) {
+        data.append(formFieldPrefix + streamId, 'C'); // Close signal
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        try {
+          // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+          var partJSON = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON);
+          reader.read().then(progress, reject);
+        } catch (x) {
+          reject(x);
+        }
+      }
+    }
+
+    reader.read().then(progress, reject);
+    return '$R' + streamId.toString(16);
+  }
+
+  function serializeReadableStream(stream) {
+    // Detect if this is a BYOB stream. BYOB streams should be able to be read as bytes on the
+    // receiving side. For binary streams, we serialize them as plain Blobs.
+    var binaryReader;
+
+    try {
+      // $FlowFixMe[extra-arg]: This argument is accepted.
+      binaryReader = stream.getReader({
+        mode: 'byob'
+      });
+    } catch (x) {
+      return serializeReader(stream.getReader());
+    }
+
+    return serializeBinaryReader(binaryReader);
+  }
+
+  function serializeAsyncIterable(iterable, iterator) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    var data = formData;
+    pendingParts++;
+    var streamId = nextPartId++; // Generators/Iterators are Iterables but they're also their own iterator
+    // functions. If that's the case, we treat them as single-shot. Otherwise,
+    // we assume that this iterable might be a multi-shot and allow it to be
+    // iterated more than once on the receiving server.
+
+    var isIterator = iterable === iterator; // There's a race condition between when the stream is aborted and when the promise
+    // resolves so we track whether we already aborted it to avoid writing twice.
+
+    function progress(entry) {
+      if (entry.done) {
+        if (entry.value === undefined) {
+          data.append(formFieldPrefix + streamId, 'C'); // Close signal
+        } else {
+          // Unlike streams, the last value may not be undefined. If it's not
+          // we outline it and encode a reference to it in the closing instruction.
+          try {
+            // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+            var partJSON = JSON.stringify(entry.value, resolveToJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON); // Close signal
+          } catch (x) {
+            reject(x);
+            return;
+          }
+        }
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        try {
+          // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+          var _partJSON = JSON.stringify(entry.value, resolveToJSON);
+
+          data.append(formFieldPrefix + streamId, _partJSON);
+          iterator.next().then(progress, reject);
+        } catch (x) {
+          reject(x);
+          return;
+        }
+      }
+    }
+
+    iterator.next().then(progress, reject);
+    return '$' + (isIterator ? 'x' : 'X') + streamId.toString(16);
+  }
+
+  function resolveToJSON(key, value) {
+    var parent = this; // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us
+
+    {
+      // $FlowFixMe[incompatible-use]
+      var originalValue = parent[key];
+
+      if (typeof originalValue === 'object' && originalValue !== value && !(originalValue instanceof Date)) {
+        if (objectName(originalValue) !== 'Object') {
+          console.error('Only plain objects can be passed to Server Functions from the Client. ' + '%s objects are not supported.%s', objectName(originalValue), describeObjectForErrorMessage(parent, key));
+        } else {
+          console.error('Only plain objects can be passed to Server Functions from the Client. ' + 'Objects with toJSON methods are not supported. Convert it manually ' + 'to a simple value before passing it to props.%s', describeObjectForErrorMessage(parent, key));
+        }
+      }
+    }
+
+    if (value === null) {
+      return null;
+    }
+
+    if (typeof value === 'object') {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+              // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+              var parentReference = writtenObjects.get(parent);
+
+              if (parentReference !== undefined) {
+                // If the parent has a reference, we can refer to this object indirectly
+                // through the property name inside that parent.
+                var reference = parentReference + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+                writeTemporaryReference(temporaryReferences, reference, value);
+                return serializeTemporaryReferenceMarker();
+              }
+            }
+
+            throw new Error('React Element cannot be passed to Server Functions from the Client without a ' + 'temporary reference set. Pass a TemporaryReferenceSet to the options.' + (describeObjectForErrorMessage(parent, key) ));
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            // Resolve lazy as if it wasn't here. In the future this will be encoded as a Promise.
+            var lazy = value;
+            var payload = lazy._payload;
+            var init = lazy._init;
+
+            if (formData === null) {
+              // Upgrade to use FormData to allow us to stream this value.
+              formData = new FormData();
+            }
+
+            pendingParts++;
+
+            try {
+              var resolvedModel = init(payload); // We always outline this as a separate part even though we could inline it
+              // because it ensures a more deterministic encoding.
+
+              var lazyId = nextPartId++;
+              var partJSON = serializeModel(resolvedModel, lazyId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+              var data = formData;
+              data.append(formFieldPrefix + lazyId, partJSON);
+              return serializeByValueID(lazyId);
+            } catch (x) {
+              if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+                // Suspended
+                pendingParts++;
+
+                var _lazyId = nextPartId++;
+
+                var thenable = x;
+
+                var retry = function () {
+                  // While the first promise resolved, its value isn't necessarily what we'll
+                  // resolve into because we might suspend again.
+                  try {
+                    var _partJSON2 = serializeModel(value, _lazyId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+
+                    var _data = formData;
+
+                    _data.append(formFieldPrefix + _lazyId, _partJSON2);
+
+                    pendingParts--;
+
+                    if (pendingParts === 0) {
+                      resolve(_data);
+                    }
+                  } catch (reason) {
+                    reject(reason);
+                  }
+                };
+
+                thenable.then(retry, retry);
+                return serializeByValueID(_lazyId);
+              } else {
+                // In the future we could consider serializing this as an error
+                // that throws on the server instead.
+                reject(x);
+                return null;
+              }
+            } finally {
+              pendingParts--;
+            }
+          }
+      } // $FlowFixMe[method-unbinding]
+
+
+      if (typeof value.then === 'function') {
+        // We assume that any object with a .then property is a "Thenable" type,
+        // or a Promise type. Either of which can be represented by a Promise.
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to stream this value.
+          formData = new FormData();
+        }
+
+        pendingParts++;
+        var promiseId = nextPartId++;
+        var _thenable = value;
+
+        _thenable.then(function (partValue) {
+          try {
+            var _partJSON3 = serializeModel(partValue, promiseId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+
+            var _data2 = formData;
+
+            _data2.append(formFieldPrefix + promiseId, _partJSON3);
+
+            pendingParts--;
+
+            if (pendingParts === 0) {
+              resolve(_data2);
+            }
+          } catch (reason) {
+            reject(reason);
+          }
+        }, // In the future we could consider serializing this as an error
+        // that throws on the server instead.
+        reject);
+
+        return serializePromiseID(promiseId);
+      }
+
+      var existingReference = writtenObjects.get(value);
+
+      if (existingReference !== undefined) {
+        if (modelRoot === value) {
+          // This is the ID we're currently emitting so we need to write it
+          // once but if we discover it again, we refer to it by id.
+          modelRoot = null;
+        } else {
+          // We've already emitted this as an outlined object, so we can
+          // just refer to that by its existing ID.
+          return existingReference;
+        }
+      } else if (key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        var _parentReference = writtenObjects.get(parent);
+
+        if (_parentReference !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          var _reference = _parentReference + ':' + key;
+
+          writtenObjects.set(value, _reference);
+
+          if (temporaryReferences !== undefined) {
+            // Store this object so that the server can refer to it later in responses.
+            writeTemporaryReference(temporaryReferences, _reference, value);
+          }
+        }
+      }
+
+      if (isArray(value)) {
+        // $FlowFixMe[incompatible-return]
+        return value;
+      } // TODO: Should we the Object.prototype.toString.call() to test for cross-realm objects?
+
+
+      if (value instanceof FormData) {
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to use rich objects as its values.
+          formData = new FormData();
+        }
+
+        var _data3 = formData;
+        var refId = nextPartId++; // Copy all the form fields with a prefix for this reference.
+        // These must come first in the form order because we assume that all the
+        // fields are available before this is referenced.
+
+        var prefix = formFieldPrefix + refId + '_'; // $FlowFixMe[prop-missing]: FormData has forEach.
+
+        value.forEach(function (originalValue, originalKey) {
+          // $FlowFixMe[incompatible-call]
+          _data3.append(prefix + originalKey, originalValue);
+        });
+        return serializeFormDataReference(refId);
+      }
+
+      if (value instanceof Map) {
+        var mapId = nextPartId++;
+
+        var _partJSON4 = serializeModel(Array.from(value), mapId);
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + mapId, _partJSON4);
+        return serializeMapID(mapId);
+      }
+
+      if (value instanceof Set) {
+        var setId = nextPartId++;
+
+        var _partJSON5 = serializeModel(Array.from(value), setId);
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + setId, _partJSON5);
+        return serializeSetID(setId);
+      }
+
+      if (value instanceof ArrayBuffer) {
+        var blob = new Blob([value]);
+        var blobId = nextPartId++;
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + blobId, blob);
+        return '$' + 'A' + blobId.toString(16);
+      }
+
+      if (value instanceof Int8Array) {
+        // char
+        return serializeTypedArray('O', value);
+      }
+
+      if (value instanceof Uint8Array) {
+        // unsigned char
+        return serializeTypedArray('o', value);
+      }
+
+      if (value instanceof Uint8ClampedArray) {
+        // unsigned clamped char
+        return serializeTypedArray('U', value);
+      }
+
+      if (value instanceof Int16Array) {
+        // sort
+        return serializeTypedArray('S', value);
+      }
+
+      if (value instanceof Uint16Array) {
+        // unsigned short
+        return serializeTypedArray('s', value);
+      }
+
+      if (value instanceof Int32Array) {
+        // long
+        return serializeTypedArray('L', value);
+      }
+
+      if (value instanceof Uint32Array) {
+        // unsigned long
+        return serializeTypedArray('l', value);
+      }
+
+      if (value instanceof Float32Array) {
+        // float
+        return serializeTypedArray('G', value);
+      }
+
+      if (value instanceof Float64Array) {
+        // double
+        return serializeTypedArray('g', value);
+      }
+
+      if (value instanceof BigInt64Array) {
+        // number
+        return serializeTypedArray('M', value);
+      }
+
+      if (value instanceof BigUint64Array) {
+        // unsigned number
+        // We use "m" instead of "n" since JSON can start with "null"
+        return serializeTypedArray('m', value);
+      }
+
+      if (value instanceof DataView) {
+        return serializeTypedArray('V', value);
+      } // TODO: Blob is not available in old Node/browsers. Remove the typeof check later.
+
+
+      if (typeof Blob === 'function' && value instanceof Blob) {
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        var _blobId = nextPartId++;
+
+        formData.append(formFieldPrefix + _blobId, value);
+        return serializeBlobID(_blobId);
+      }
+
+      var iteratorFn = getIteratorFn(value);
+
+      if (iteratorFn) {
+        var iterator = iteratorFn.call(value);
+
+        if (iterator === value) {
+          // Iterator, not Iterable
+          var iteratorId = nextPartId++;
+
+          var _partJSON6 = serializeModel(Array.from(iterator), iteratorId);
+
+          if (formData === null) {
+            formData = new FormData();
+          }
+
+          formData.append(formFieldPrefix + iteratorId, _partJSON6);
+          return serializeIteratorID(iteratorId);
+        }
+
+        return Array.from(iterator);
+      } // TODO: ReadableStream is not available in old Node. Remove the typeof check later.
+
+
+      if (typeof ReadableStream === 'function' && value instanceof ReadableStream) {
+        return serializeReadableStream(value);
+      }
+
+      var getAsyncIterator = value[ASYNC_ITERATOR];
+
+      if (typeof getAsyncIterator === 'function') {
+        // We treat AsyncIterables as a Fragment and as such we might need to key them.
+        return serializeAsyncIterable(value, getAsyncIterator.call(value));
+      } // Verify that this is a simple plain object.
+
+
+      var proto = getPrototypeOf(value);
+
+      if (proto !== ObjectPrototype && (proto === null || getPrototypeOf(proto) !== null)) {
+        if (temporaryReferences === undefined) {
+          throw new Error('Only plain objects, and a few built-ins, can be passed to Server Functions. ' + 'Classes or null prototypes are not supported.' + (describeObjectForErrorMessage(parent, key) ));
+        } // We will have written this object to the temporary reference set above
+        // so we can replace it with a marker to refer to this slot later.
+
+
+        return serializeTemporaryReferenceMarker();
+      }
+
+      {
+        if (value.$$typeof === (REACT_CONTEXT_TYPE )) {
+          console.error('React Context Providers cannot be passed to Server Functions from the Client.%s', describeObjectForErrorMessage(parent, key));
+        } else if (objectName(value) !== 'Object') {
+          console.error('Only plain objects can be passed to Server Functions from the Client. ' + '%s objects are not supported.%s', objectName(value), describeObjectForErrorMessage(parent, key));
+        } else if (!isSimpleObject(value)) {
+          console.error('Only plain objects can be passed to Server Functions from the Client. ' + 'Classes or other objects with methods are not supported.%s', describeObjectForErrorMessage(parent, key));
+        } else if (Object.getOwnPropertySymbols) {
+          var symbols = Object.getOwnPropertySymbols(value);
+
+          if (symbols.length > 0) {
+            console.error('Only plain objects can be passed to Server Functions from the Client. ' + 'Objects with symbol properties like %s are not supported.%s', symbols[0].description, describeObjectForErrorMessage(parent, key));
+          }
+        }
+      } // $FlowFixMe[incompatible-return]
+
+
+      return value;
+    }
+
+    if (typeof value === 'string') {
+      // TODO: Maybe too clever. If we support URL there's no similar trick.
+      if (value[value.length - 1] === 'Z') {
+        // Possibly a Date, whose toJSON automatically calls toISOString
+        // $FlowFixMe[incompatible-use]
+        var _originalValue = parent[key];
+
+        if (_originalValue instanceof Date) {
+          return serializeDateFromDateJSON(value);
+        }
+      }
+
+      return escapeStringValue(value);
+    }
+
+    if (typeof value === 'boolean') {
+      return value;
+    }
+
+    if (typeof value === 'number') {
+      return serializeNumber(value);
+    }
+
+    if (typeof value === 'undefined') {
+      return serializeUndefined();
+    }
+
+    if (typeof value === 'function') {
+      var metaData = knownServerReferences.get(value);
+
+      if (metaData !== undefined) {
+        var metaDataJSON = JSON.stringify(metaData, resolveToJSON);
+
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to stream this value.
+          formData = new FormData();
+        } // The reference to this function came from the same client so we can pass it back.
+
+
+        var _refId = nextPartId++;
+
+        formData.set(formFieldPrefix + _refId, metaDataJSON);
+        return serializeServerReferenceID(_refId);
+      }
+
+      if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        var _parentReference2 = writtenObjects.get(parent);
+
+        if (_parentReference2 !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          var _reference2 = _parentReference2 + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+
+          writeTemporaryReference(temporaryReferences, _reference2, value);
+          return serializeTemporaryReferenceMarker();
+        }
+      }
+
+      throw new Error('Client Functions cannot be passed directly to Server Functions. ' + 'Only Functions passed from the Server can be passed back again.');
+    }
+
+    if (typeof value === 'symbol') {
+      if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        var _parentReference3 = writtenObjects.get(parent);
+
+        if (_parentReference3 !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          var _reference3 = _parentReference3 + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+
+          writeTemporaryReference(temporaryReferences, _reference3, value);
+          return serializeTemporaryReferenceMarker();
+        }
+      }
+
+      throw new Error('Symbols cannot be passed to a Server Function without a ' + 'temporary reference set. Pass a TemporaryReferenceSet to the options.' + (describeObjectForErrorMessage(parent, key) ));
+    }
+
+    if (typeof value === 'bigint') {
+      return serializeBigInt(value);
+    }
+
+    throw new Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
+  }
+
+  function serializeModel(model, id) {
+    if (typeof model === 'object' && model !== null) {
+      var reference = serializeByValueID(id);
+      writtenObjects.set(model, reference);
+
+      if (temporaryReferences !== undefined) {
+        // Store this object so that the server can refer to it later in responses.
+        writeTemporaryReference(temporaryReferences, reference, model);
+      }
+    }
+
+    modelRoot = model; // $FlowFixMe[incompatible-return] it's not going to be undefined because we'll encode it.
+
+    return JSON.stringify(model, resolveToJSON);
+  }
+
+  function abort(reason) {
+    if (pendingParts > 0) {
+      pendingParts = 0; // Don't resolve again later.
+      // Resolve with what we have so far, which may have holes at this point.
+      // They'll error when the stream completes on the server.
+
+      if (formData === null) {
+        resolve(json);
+      } else {
+        resolve(formData);
+      }
+    }
+  }
+
+  var json = serializeModel(root, 0);
+
+  if (formData === null) {
+    // If it's a simple data structure, we just use plain JSON.
+    resolve(json);
+  } else {
+    // Otherwise, we use FormData to let us stream in the result.
+    formData.set(formFieldPrefix + '0', json);
+
+    if (pendingParts === 0) {
+      // $FlowFixMe[incompatible-call] this has already been refined.
+      resolve(formData);
+    }
+  }
+
+  return abort;
+}
+
+var fakeServerFunctionIdx = 0;
+
+function createFakeServerFunction(name, filename, sourceMap, line, col, environmentName, innerFunction) {
+  // This creates a fake copy of a Server Module. It represents the Server Action on the server.
+  // We use an eval so we can source map it to the original location.
+  var comment = '/* This module is a proxy to a Server Action. Turn on Source Maps to see the server source. */';
+
+  if (!name) {
+    // An eval:ed function with no name gets the name "eval". We give it something more descriptive.
+    name = '<anonymous>';
+  }
+
+  var encodedName = JSON.stringify(name); // We generate code where both the beginning of the function and its parenthesis is at the line
+  // and column of the server executed code. We use a method form since that lets us name it
+  // anything we want and because the beginning of the function and its parenthesis is the same
+  // column. Because Chrome inspects the location of the parenthesis and Firefox inspects the
+  // location of the beginning of the function. By not using a function expression we avoid the
+  // ambiguity.
+
+  var code;
+
+  if (line <= 1) {
+    var minSize = encodedName.length + 7;
+    code = 's=>({' + encodedName + ' '.repeat(col < minSize ? 0 : col - minSize) + ':' + '(...args) => s(...args)' + '})\n' + comment;
+  } else {
+    code = comment + '\n'.repeat(line - 2) + 'server=>({' + encodedName + ':\n' + ' '.repeat(col < 1 ? 0 : col - 1) + // The function body can get printed so we make it look nice.
+    // This "calls the server with the arguments".
+    '(...args) => server(...args)' + '})';
+  }
+
+  if (filename.startsWith('/')) {
+    // If the filename starts with `/` we assume that it is a file system file
+    // rather than relative to the current host. Since on the server fully qualified
+    // stack traces use the file path.
+    // TODO: What does this look like on Windows?
+    filename = 'file://' + filename;
+  }
+
+  if (sourceMap) {
+    // We use the prefix rsc://React/ to separate these from other files listed in
+    // the Chrome DevTools. We need a "host name" and not just a protocol because
+    // otherwise the group name becomes the root folder. Ideally we don't want to
+    // show these at all but there's two reasons to assign a fake URL.
+    // 1) A printed stack trace string needs a unique URL to be able to source map it.
+    // 2) If source maps are disabled or fails, you should at least be able to tell
+    //    which file it was.
+    code += '\n//# sourceURL=rsc://React/' + encodeURIComponent(environmentName) + '/' + filename + '?s' + // We add an extra s here to distinguish from the fake stack frames
+    fakeServerFunctionIdx++;
+    code += '\n//# sourceMappingURL=' + sourceMap;
+  } else if (filename) {
+    code += '\n//# sourceURL=' + filename;
+  }
+
+  try {
+    // Eval a factory and then call it to create a closure over the inner function.
+    // eslint-disable-next-line no-eval
+    return (0, eval)(code)(innerFunction)[name];
+  } catch (x) {
+    // If eval fails, such as if in an environment that doesn't support it,
+    // we fallback to just returning the inner function.
+    return innerFunction;
+  }
+}
+
+function registerServerReference(proxy, reference, encodeFormAction) {
+
+  knownServerReferences.set(proxy, reference);
+} // $FlowFixMe[method-unbinding]
+
+function createBoundServerReference(metaData, callServer, encodeFormAction, findSourceMapURL) // DEV-only
+{
+  var id = metaData.id;
+  var bound = metaData.bound;
+
+  var action = function () {
+    // $FlowFixMe[method-unbinding]
+    var args = Array.prototype.slice.call(arguments);
+    var p = bound;
+
+    if (!p) {
+      return callServer(id, args);
+    }
+
+    if (p.status === 'fulfilled') {
+      var boundArgs = p.value;
+      return callServer(id, boundArgs.concat(args));
+    } // Since this is a fake Promise whose .then doesn't chain, we have to wrap it.
+    // TODO: Remove the wrapper once that's fixed.
+
+
+    return Promise.resolve(p).then(function (boundArgs) {
+      return callServer(id, boundArgs.concat(args));
+    });
+  };
+
+  {
+    var location = metaData.location;
+
+    if (location) {
+      var functionName = metaData.name || '';
+      var filename = location[1],
+          line = location[2],
+          col = location[3];
+      var env = metaData.env || 'Server';
+      var sourceMap = findSourceMapURL == null ? null : findSourceMapURL(filename, env);
+      action = createFakeServerFunction(functionName, filename, sourceMap, line, col, env, action);
+    }
+  }
+
+  registerServerReference(action, {
+    id: id,
+    bound: bound
+  });
+  return action;
+} // This matches either of these V8 formats.
+//     at name (filename:0:0)
+//     at filename:0:0
+//     at async filename:0:0
+
+var v8FrameRegExp = /^ {3} at (?:(.+) \((.+):(\d+):(\d+)\)|(?:async )?(.+):(\d+):(\d+))$/; // This matches either of these JSC/SpiderMonkey formats.
+// name@filename:0:0
+// filename:0:0
+
+var jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\d+):(\d+)/;
+
+function parseStackLocation(error) {
+  // This parsing is special in that we know that the calling function will always
+  // be a module that initializes the server action. We also need this part to work
+  // cross-browser so not worth a Config. It's DEV only so not super code size
+  // sensitive but also a non-essential feature.
+  var stack = error.stack;
+
+  if (stack.startsWith('Error: react-stack-top-frame\n')) {
+    // V8's default formatting prefixes with the error message which we
+    // don't want/need.
+    stack = stack.slice(29);
+  }
+
+  var endOfFirst = stack.indexOf('\n');
+  var secondFrame;
+
+  if (endOfFirst !== -1) {
+    // Skip the first frame.
+    var endOfSecond = stack.indexOf('\n', endOfFirst + 1);
+
+    if (endOfSecond === -1) {
+      secondFrame = stack.slice(endOfFirst + 1);
+    } else {
+      secondFrame = stack.slice(endOfFirst + 1, endOfSecond);
+    }
+  } else {
+    secondFrame = stack;
+  }
+
+  var parsed = v8FrameRegExp.exec(secondFrame);
+
+  if (!parsed) {
+    parsed = jscSpiderMonkeyFrameRegExp.exec(secondFrame);
+
+    if (!parsed) {
+      return null;
+    }
+  }
+
+  var name = parsed[1] || '';
+
+  if (name === '<anonymous>') {
+    name = '';
+  }
+
+  var filename = parsed[2] || parsed[5] || '';
+
+  if (filename === '<anonymous>') {
+    filename = '';
+  }
+
+  var line = +(parsed[3] || parsed[6]);
+  var col = +(parsed[4] || parsed[7]);
+  return [name, filename, line, col];
+}
+
+function createServerReference(id, callServer, encodeFormAction, findSourceMapURL, // DEV-only
+functionName) {
+  var action = function () {
+    // $FlowFixMe[method-unbinding]
+    var args = Array.prototype.slice.call(arguments);
+    return callServer(id, args);
+  };
+
+  {
+    // Let's see if we can find a source map for the file which contained the
+    // server action. We extract it from the runtime so that it's resilient to
+    // multiple passes of compilation as long as we can find the final source map.
+    var location = parseStackLocation(new Error('react-stack-top-frame'));
+
+    if (location !== null) {
+      var filename = location[1],
+          line = location[2],
+          col = location[3]; // While the environment that the Server Reference points to can be
+      // in any environment, what matters here is where the compiled source
+      // is from and that's in the currently executing environment. We hard
+      // code that as the value "Client" in case the findSourceMapURL helper
+      // needs it.
+
+      var env = 'Client';
+      var sourceMap = findSourceMapURL == null ? null : findSourceMapURL(filename, env);
+      action = createFakeServerFunction(functionName || '', filename, sourceMap, line, col, env, action);
+    }
+  }
+
+  registerServerReference(action, {
+    id: id,
+    bound: null
+  });
+  return action;
+}
+
+var supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]
+typeof performance.measure === 'function';
+var COMPONENTS_TRACK = 'Server Components ⚛';
+var componentsTrackMarker = {
+  startTime: 0.001,
+  detail: {
+    devtools: {
+      color: 'primary-light',
+      track: 'Primary',
+      trackGroup: COMPONENTS_TRACK
+    }
+  }
+};
+function markAllTracksInOrder() {
+  if (supportsUserTiming) {
+    // Ensure we create the Server Component track groups earlier than the Client Scheduler
+    // and Client Components. We can always add the 0 time slot even if it's in the past.
+    // That's still considered for ordering.
+    performance.mark('Server Components Track', componentsTrackMarker);
+  }
+} // Reused to avoid thrashing the GC.
+
+var reusableComponentDevToolDetails = {
+  color: 'primary',
+  track: '',
+  trackGroup: COMPONENTS_TRACK
+};
+var reusableComponentOptions = {
+  start: -0,
+  end: -0,
+  detail: {
+    devtools: reusableComponentDevToolDetails
+  }
+};
+var trackNames = ['Primary', 'Parallel', "Parallel\u200B", // Padded with zero-width space to give each track a unique name.
+"Parallel\u200B\u200B", "Parallel\u200B\u200B\u200B", "Parallel\u200B\u200B\u200B\u200B", "Parallel\u200B\u200B\u200B\u200B\u200B", "Parallel\u200B\u200B\u200B\u200B\u200B\u200B", "Parallel\u200B\u200B\u200B\u200B\u200B\u200B\u200B", "Parallel\u200B\u200B\u200B\u200B\u200B\u200B\u200B\u200B"];
+function logComponentRender(componentInfo, trackIdx, startTime, endTime, childrenEndTime, rootEnv) {
+  if (supportsUserTiming && childrenEndTime >= 0 && trackIdx < 10) {
+    var env = componentInfo.env;
+    var name = componentInfo.name;
+    var isPrimaryEnv = env === rootEnv;
+    var selfTime = endTime - startTime;
+    reusableComponentDevToolDetails.color = selfTime < 0.5 ? isPrimaryEnv ? 'primary-light' : 'secondary-light' : selfTime < 50 ? isPrimaryEnv ? 'primary' : 'secondary' : selfTime < 500 ? isPrimaryEnv ? 'primary-dark' : 'secondary-dark' : 'error';
+    reusableComponentDevToolDetails.track = trackNames[trackIdx];
+    reusableComponentOptions.start = startTime < 0 ? 0 : startTime;
+    reusableComponentOptions.end = childrenEndTime;
+    var entryName = isPrimaryEnv || env === undefined ? name : name + ' [' + env + ']';
+    performance.measure(entryName, reusableComponentOptions);
+  }
+}
+function logComponentErrored(componentInfo, trackIdx, startTime, endTime, childrenEndTime, rootEnv, error) {
+  if (supportsUserTiming) {
+    var properties = [];
+
+    {
+      var message = typeof error === 'object' && error !== null && typeof error.message === 'string' ? // eslint-disable-next-line react-internal/safe-string-coercion
+      String(error.message) : // eslint-disable-next-line react-internal/safe-string-coercion
+      String(error);
+      properties.push(['Error', message]);
+    }
+
+    var env = componentInfo.env;
+    var name = componentInfo.name;
+    var isPrimaryEnv = env === rootEnv;
+    var entryName = isPrimaryEnv || env === undefined ? name : name + ' [' + env + ']';
+    performance.measure(entryName, {
+      start: startTime < 0 ? 0 : startTime,
+      end: childrenEndTime,
+      detail: {
+        devtools: {
+          color: 'error',
+          track: trackNames[trackIdx],
+          trackGroup: COMPONENTS_TRACK,
+          tooltipText: entryName + ' Errored',
+          properties: properties
+        }
+      }
+    });
+  }
+}
+function logDedupedComponentRender(componentInfo, trackIdx, startTime, endTime) {
+  if (supportsUserTiming && endTime >= 0 && trackIdx < 10) {
+    var name = componentInfo.name;
+    reusableComponentDevToolDetails.color = 'tertiary-light';
+    reusableComponentDevToolDetails.track = trackNames[trackIdx];
+    reusableComponentOptions.start = startTime < 0 ? 0 : startTime;
+    reusableComponentOptions.end = endTime;
+    var entryName = name + ' [deduped]';
+    performance.measure(entryName, reusableComponentOptions);
+  }
+}
+
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+
+  if (displayName) {
+    return displayName;
+  }
+
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+} // Keep in sync with react-reconciler/getComponentNameFromFiber
+
+
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
+      return null;
+    }
+
+    return type.displayName || type.name || null;
+  }
+
+  if (typeof type === 'string') {
+    return type;
+  }
+
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+
+    case REACT_PORTAL_TYPE:
+      return 'Portal';
+
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    // Fall through
+
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
+      }
+
+  }
+
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
+      }
+    }
+
+    switch (type.$$typeof) {
+      case REACT_PROVIDER_TYPE:
+        {
+          return null;
+        }
+
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+
+        {
+          return getContextName(context) + '.Provider';
+        }
+
+      case REACT_CONSUMER_TYPE:
+        {
+          var consumer = type;
+          return getContextName(consumer._context) + '.Consumer';
+        }
+
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+
+        if (outerName !== null) {
+          return outerName;
+        }
+
+        return getComponentNameFromType(type.type) || 'Memo';
+
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
+    }
+  }
+
+  return null;
+}
+
+// This is forked in server builds where the default stack frame may be source mapped.
+var DefaultPrepareStackTrace = undefined;
+
+var prefix;
+var suffix;
+function describeBuiltInComponentFrame(name) {
+  if (prefix === undefined) {
+    // Extract the VM specific prefix used by each line.
+    try {
+      throw Error();
+    } catch (x) {
+      var match = x.stack.trim().match(/\n( *(at )?)/);
+      prefix = match && match[1] || '';
+      suffix = x.stack.indexOf('\n    at') > -1 ? // V8
+      ' (<anonymous>)' : // JSC/Spidermonkey
+      x.stack.indexOf('@') > -1 ? '@unknown:0:0' : // Other
+      '';
+    }
+  } // We use the prefix to ensure our stacks line up with native stack frames.
+
+
+  return '\n' + prefix + name + suffix;
+}
+
+{
+  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
+  new PossiblyWeakMap();
+}
+
+function formatOwnerStack(error) {
+  var prevPrepareStackTrace = Error.prepareStackTrace;
+  Error.prepareStackTrace = DefaultPrepareStackTrace;
+  var stack = error.stack;
+  Error.prepareStackTrace = prevPrepareStackTrace;
+
+  if (stack.startsWith('Error: react-stack-top-frame\n')) {
+    // V8's default formatting prefixes with the error message which we
+    // don't want/need.
+    stack = stack.slice(29);
+  }
+
+  var idx = stack.indexOf('\n');
+
+  if (idx !== -1) {
+    // Pop the JSX frame.
+    stack = stack.slice(idx + 1);
+  }
+
+  idx = stack.indexOf('react-stack-bottom-frame');
+
+  if (idx !== -1) {
+    idx = stack.lastIndexOf('\n', idx);
+  }
+
+  if (idx !== -1) {
+    // Cut off everything after the bottom frame since it'll be internals.
+    stack = stack.slice(0, idx);
+  } else {
+    // We didn't find any internal callsite out to user space.
+    // This means that this was called outside an owner or the owner is fully internal.
+    // To keep things light we exclude the entire trace in this case.
+    return '';
+  }
+
+  return stack;
+}
+
+function getOwnerStackByComponentInfoInDev(componentInfo) {
+
+  try {
+    var info = ''; // The owner stack of the current component will be where it was created, i.e. inside its owner.
+    // There's no actual name of the currently executing component. Instead, that is available
+    // on the regular stack that's currently executing. However, if there is no owner at all, then
+    // there's no stack frame so we add the name of the root component to the stack to know which
+    // component is currently executing.
+
+    if (!componentInfo.owner && typeof componentInfo.name === 'string') {
+      return describeBuiltInComponentFrame(componentInfo.name);
+    }
+
+    var owner = componentInfo;
+
+    while (owner) {
+      var ownerStack = owner.debugStack;
+
+      if (ownerStack != null) {
+        // Server Component
+        owner = owner.owner;
+
+        if (owner) {
+          // TODO: Should we stash this somewhere for caching purposes?
+          info += '\n' + formatOwnerStack(ownerStack);
+        }
+      } else {
+        break;
+      }
+    }
+
+    return info;
+  } catch (x) {
+    return '\nError generating stack: ' + x.message + '\n' + x.stack;
+  }
+}
+
+function injectInternals(internals) {
+  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
+    // No DevTools
+    return false;
+  }
+
+  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+
+  if (hook.isDisabled) {
+    // This isn't a real property on the hook, but it can be set to opt out
+    // of DevTools integration and associated warnings and logs.
+    // https://github.com/facebook/react/issues/3877
+    return true;
+  }
+
+  if (!hook.supportsFlight) {
+    // DevTools exists, even though it doesn't support Flight.
+    return true;
+  }
+
+  try {
+    hook.inject(internals);
+  } catch (err) {
+    // Catch all errors because it is unsafe to throw during initialization.
+    {
+      console.error('React instrumentation encountered an error: %s.', err);
+    }
+  }
+
+  if (hook.checkDCE) {
+    // This is the real DevTools.
+    return true;
+  } else {
+    // This is likely a hook installed by Fast Refresh runtime.
+    return false;
+  }
+}
+
+// like this. It's just that for now we support the same build of the Flight
+// client both in the RSC environment, in the SSR environments as well as the
+// browser client. We should probably have a separate RSC build. This is DEV
+// only though.
+
+var ReactSharedInteralsServer = React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE || ReactSharedInteralsServer;
+var ROW_ID = 0;
+var ROW_TAG = 1;
+var ROW_LENGTH = 2;
+var ROW_CHUNK_BY_NEWLINE = 3;
+var ROW_CHUNK_BY_LENGTH = 4;
+var PENDING = 'pending';
+var BLOCKED = 'blocked';
+var RESOLVED_MODEL = 'resolved_model';
+var RESOLVED_MODULE = 'resolved_module';
+var INITIALIZED = 'fulfilled';
+var ERRORED = 'rejected'; // $FlowFixMe[missing-this-annot]
+
+function ReactPromise(status, value, reason, response) {
+  this.status = status;
+  this.value = value;
+  this.reason = reason;
+  this._response = response;
+
+  {
+    this._children = [];
+  }
+
+  {
+    this._debugInfo = null;
+  }
+} // We subclass Promise.prototype so that we get other methods like .catch
+
+
+ReactPromise.prototype = Object.create(Promise.prototype); // TODO: This doesn't return a new Promise chain unlike the real .then
+
+ReactPromise.prototype.then = function (resolve, reject) {
+  var chunk = this; // If we have resolved content, we try to initialize it first which
+  // might put us back into one of the other states.
+
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      resolve(chunk.value);
+      break;
+
+    case PENDING:
+    case BLOCKED:
+      if (resolve) {
+        if (chunk.value === null) {
+          chunk.value = [];
+        }
+
+        chunk.value.push(resolve);
+      }
+
+      if (reject) {
+        if (chunk.reason === null) {
+          chunk.reason = [];
+        }
+
+        chunk.reason.push(reject);
+      }
+
+      break;
+
+    default:
+      if (reject) {
+        reject(chunk.reason);
+      }
+
+      break;
+  }
+};
+
+function readChunk(chunk) {
+  // If we have resolved content, we try to initialize it first which
+  // might put us back into one of the other states.
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      return chunk.value;
+
+    case PENDING:
+    case BLOCKED:
+      // eslint-disable-next-line no-throw-literal
+      throw chunk;
+
+    default:
+      throw chunk.reason;
+  }
+}
+
+function getRoot(response) {
+  var chunk = getChunk(response, 0);
+  return chunk;
+}
+
+function createPendingChunk(response) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(PENDING, null, null, response);
+}
+
+function createBlockedChunk(response) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(BLOCKED, null, null, response);
+}
+
+function createErrorChunk(response, error) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(ERRORED, null, error, response);
+}
+
+function wakeChunk(listeners, value) {
+  for (var i = 0; i < listeners.length; i++) {
+    var listener = listeners[i];
+    listener(value);
+  }
+}
+
+function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+  switch (chunk.status) {
+    case INITIALIZED:
+      wakeChunk(resolveListeners, chunk.value);
+      break;
+
+    case PENDING:
+    case BLOCKED:
+      if (chunk.value) {
+        for (var i = 0; i < resolveListeners.length; i++) {
+          chunk.value.push(resolveListeners[i]);
+        }
+      } else {
+        chunk.value = resolveListeners;
+      }
+
+      if (chunk.reason) {
+        if (rejectListeners) {
+          for (var _i = 0; _i < rejectListeners.length; _i++) {
+            chunk.reason.push(rejectListeners[_i]);
+          }
+        }
+      } else {
+        chunk.reason = rejectListeners;
+      }
+
+      break;
+
+    case ERRORED:
+      if (rejectListeners) {
+        wakeChunk(rejectListeners, chunk.reason);
+      }
+
+      break;
+  }
+}
+
+function triggerErrorOnChunk(chunk, error) {
+  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    var streamChunk = chunk;
+    var controller = streamChunk.reason; // $FlowFixMe[incompatible-call]: The error method should accept mixed.
+
+    controller.error(error);
+    return;
+  }
+
+  var listeners = chunk.reason;
+  var erroredChunk = chunk;
+  erroredChunk.status = ERRORED;
+  erroredChunk.reason = error;
+
+  if (listeners !== null) {
+    wakeChunk(listeners, error);
+  }
+}
+
+function createResolvedModelChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(RESOLVED_MODEL, value, null, response);
+}
+
+function createResolvedModuleChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(RESOLVED_MODULE, value, null, response);
+}
+
+function createInitializedTextChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, null, response);
+}
+
+function createInitializedBufferChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, null, response);
+}
+
+function createInitializedIteratorResultChunk(response, value, done) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, {
+    done: done,
+    value: value
+  }, null, response);
+}
+
+function createInitializedStreamChunk(response, value, controller) {
+  // We use the reason field to stash the controller since we already have that
+  // field. It's a bit of a hack but efficient.
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, controller, response);
+}
+
+function createResolvedIteratorResultChunk(response, value, done) {
+  // To reuse code as much code as possible we add the wrapper element as part of the JSON.
+  var iteratorResultJSON = (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}'; // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+
+  return new ReactPromise(RESOLVED_MODEL, iteratorResultJSON, null, response);
+}
+
+function resolveIteratorResultChunk(chunk, value, done) {
+  // To reuse code as much code as possible we add the wrapper element as part of the JSON.
+  var iteratorResultJSON = (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}';
+  resolveModelChunk(chunk, iteratorResultJSON);
+}
+
+function resolveModelChunk(chunk, value) {
+  if (chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    var streamChunk = chunk;
+    var controller = streamChunk.reason;
+    controller.enqueueModel(value);
+    return;
+  }
+
+  var resolveListeners = chunk.value;
+  var rejectListeners = chunk.reason;
+  var resolvedChunk = chunk;
+  resolvedChunk.status = RESOLVED_MODEL;
+  resolvedChunk.value = value;
+
+  if (resolveListeners !== null) {
+    // This is unfortunate that we're reading this eagerly if
+    // we already have listeners attached since they might no
+    // longer be rendered or might not be the highest pri.
+    initializeModelChunk(resolvedChunk); // The status might have changed after initialization.
+
+    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+  }
+}
+
+function resolveModuleChunk(chunk, value) {
+  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var resolveListeners = chunk.value;
+  var rejectListeners = chunk.reason;
+  var resolvedChunk = chunk;
+  resolvedChunk.status = RESOLVED_MODULE;
+  resolvedChunk.value = value;
+
+  if (resolveListeners !== null) {
+    initializeModuleChunk(resolvedChunk);
+    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+  }
+}
+
+var initializingHandler = null;
+var initializingChunk = null;
+
+function initializeModelChunk(chunk) {
+  var prevHandler = initializingHandler;
+  var prevChunk = initializingChunk;
+  initializingHandler = null;
+  var resolvedModel = chunk.value; // We go to the BLOCKED state until we've fully resolved this.
+  // We do this before parsing in case we try to initialize the same chunk
+  // while parsing the model. Such as in a cyclic reference.
+
+  var cyclicChunk = chunk;
+  cyclicChunk.status = BLOCKED;
+  cyclicChunk.value = null;
+  cyclicChunk.reason = null;
+
+  {
+    initializingChunk = cyclicChunk;
+  }
+
+  try {
+    var value = parseModel(chunk._response, resolvedModel); // Invoke any listeners added while resolving this model. I.e. cyclic
+    // references. This may or may not fully resolve the model depending on
+    // if they were blocked.
+
+    var resolveListeners = cyclicChunk.value;
+
+    if (resolveListeners !== null) {
+      cyclicChunk.value = null;
+      cyclicChunk.reason = null;
+      wakeChunk(resolveListeners, value);
+    }
+
+    if (initializingHandler !== null) {
+      if (initializingHandler.errored) {
+        throw initializingHandler.value;
+      }
+
+      if (initializingHandler.deps > 0) {
+        // We discovered new dependencies on modules that are not yet resolved.
+        // We have to keep the BLOCKED state until they're resolved.
+        initializingHandler.value = value;
+        initializingHandler.chunk = cyclicChunk;
+        return;
+      }
+    }
+
+    var initializedChunk = chunk;
+    initializedChunk.status = INITIALIZED;
+    initializedChunk.value = value;
+  } catch (error) {
+    var erroredChunk = chunk;
+    erroredChunk.status = ERRORED;
+    erroredChunk.reason = error;
+  } finally {
+    initializingHandler = prevHandler;
+
+    {
+      initializingChunk = prevChunk;
+    }
+  }
+}
+
+function initializeModuleChunk(chunk) {
+  try {
+    var value = requireModule(chunk.value);
+    var initializedChunk = chunk;
+    initializedChunk.status = INITIALIZED;
+    initializedChunk.value = value;
+  } catch (error) {
+    var erroredChunk = chunk;
+    erroredChunk.status = ERRORED;
+    erroredChunk.reason = error;
+  }
+} // Report that any missing chunks in the model is now going to throw this
+// error upon read. Also notify any pending promises.
+
+
+function reportGlobalError(response, error) {
+  response._closed = true;
+  response._closedReason = error;
+
+  response._chunks.forEach(function (chunk) {
+    // If this chunk was already resolved or errored, it won't
+    // trigger an error but if it wasn't then we need to
+    // because we won't be getting any new data to resolve it.
+    if (chunk.status === PENDING) {
+      triggerErrorOnChunk(chunk, error);
+    }
+  });
+
+  {
+    markAllTracksInOrder();
+    flushComponentPerformance(response, getChunk(response, 0), 0, -Infinity, -Infinity);
+  }
+}
+
+function nullRefGetter() {
+  {
+    return null;
+  }
+}
+
+function getServerComponentTaskName(componentInfo) {
+  return '<' + (componentInfo.name || '...') + '>';
+}
+
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+
+  if (typeof type === 'function') {
+    // This is a function so it must have been a Client Reference that resolved to
+    // a function. We use "use client" to indicate that this is the boundary into
+    // the client. There should only be one for any given owner chain.
+    return '"use client"';
+  }
+
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    if (type._init === readChunk) {
+      // This is a lazy node created by Flight. It is probably a client reference.
+      // We use the "use client" string to indicate that this is the boundary into
+      // the client. There will only be one for any given owner chain.
+      return '"use client"';
+    } // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+
+
+    return '<...>';
+  }
+
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+
+function createElement(response, type, key, props, owner, // DEV-only
+stack, // DEV-only
+validated) // DEV-only
+{
+  var element;
+
+  {
+    // `ref` is non-enumerable in dev
+    element = {
+      $$typeof: REACT_ELEMENT_TYPE,
+      type: type,
+      key: key,
+      props: props,
+      _owner: owner === null ? response._debugRootOwner : owner
+    };
+    Object.defineProperty(element, 'ref', {
+      enumerable: false,
+      get: nullRefGetter
+    });
+  }
+
+  {
+    // We don't really need to add any of these but keeping them for good measure.
+    // Unfortunately, _store is enumerable in jest matchers so for equality to
+    // work, I need to keep it or make _store non-enumerable in the other file.
+    element._store = {};
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: validated  // Whether the element has already been validated on the server.
+
+    }); // debugInfo contains Server Component debug information.
+
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    var env = response._rootEnvironmentName;
+
+    {
+      if (owner !== null && owner.env != null) {
+        // Interestingly we don't actually have the environment name of where
+        // this JSX was created if it doesn't have an owner but if it does
+        // it must be the same environment as the owner. We could send it separately
+        // but it seems a bit unnecessary for this edge case.
+        env = owner.env;
+      }
+
+      var normalizedStackTrace = null;
+
+      if (owner === null && response._debugRootStack != null) {
+        // We override the stack if we override the owner since the stack where the root JSX
+        // was created on the server isn't very useful but where the request was made is.
+        normalizedStackTrace = response._debugRootStack;
+      } else if (stack !== null) {
+        // We create a fake stack and then create an Error object inside of it.
+        // This means that the stack trace is now normalized into the native format
+        // of the browser and the stack frames will have been registered with
+        // source mapping information.
+        // This can unfortunately happen within a user space callstack which will
+        // remain on the stack.
+        normalizedStackTrace = createFakeJSXCallStackInDEV(response, stack, env);
+      }
+
+      Object.defineProperty(element, '_debugStack', {
+        configurable: false,
+        enumerable: false,
+        writable: true,
+        value: normalizedStackTrace
+      });
+      var task = null;
+
+      if (supportsCreateTask && stack !== null) {
+        var createTaskFn = console.createTask.bind(console, getTaskName(type));
+        var callStack = buildFakeCallStack(response, stack, env, createTaskFn); // This owner should ideally have already been initialized to avoid getting
+        // user stack frames on the stack.
+
+        var ownerTask = owner === null ? null : initializeFakeTask(response, owner, env);
+
+        if (ownerTask === null) {
+          var rootTask = response._debugRootTask;
+
+          if (rootTask != null) {
+            task = rootTask.run(callStack);
+          } else {
+            task = callStack();
+          }
+        } else {
+          task = ownerTask.run(callStack);
+        }
+      }
+
+      Object.defineProperty(element, '_debugTask', {
+        configurable: false,
+        enumerable: false,
+        writable: true,
+        value: task
+      }); // This owner should ideally have already been initialized to avoid getting
+      // user stack frames on the stack.
+
+      if (owner !== null) {
+        initializeFakeStack(response, owner);
+      }
+    }
+  }
+
+  if (initializingHandler !== null) {
+    var handler = initializingHandler; // We pop the stack to the previous outer handler before leaving the Element.
+    // This is effectively the complete phase.
+
+    initializingHandler = handler.parent;
+
+    if (handler.errored) {
+      // Something errored inside this Element's props. We can turn this Element
+      // into a Lazy so that we can still render up until that Lazy is rendered.
+      var erroredChunk = createErrorChunk(response, handler.value);
+
+      {
+        // Conceptually the error happened inside this Element but right before
+        // it was rendered. We don't have a client side component to render but
+        // we can add some DebugInfo to explain that this was conceptually a
+        // Server side error that errored inside this element. That way any stack
+        // traces will point to the nearest JSX that errored - e.g. during
+        // serialization.
+        var erroredComponent = {
+          name: getComponentNameFromType(element.type) || '',
+          owner: element._owner
+        };
+
+        {
+          // $FlowFixMe[cannot-write]
+          erroredComponent.debugStack = element._debugStack;
+
+          if (supportsCreateTask) {
+            // $FlowFixMe[cannot-write]
+            erroredComponent.debugTask = element._debugTask;
+          }
+        }
+
+        erroredChunk._debugInfo = [erroredComponent];
+      }
+
+      return createLazyChunkWrapper(erroredChunk);
+    }
+
+    if (handler.deps > 0) {
+      // We have blocked references inside this Element but we can turn this into
+      // a Lazy node referencing this Element to let everything around it proceed.
+      var blockedChunk = createBlockedChunk(response);
+      handler.value = element;
+      handler.chunk = blockedChunk;
+
+      {
+        var freeze = Object.freeze.bind(Object, element.props);
+        blockedChunk.then(freeze, freeze);
+      }
+
+      return createLazyChunkWrapper(blockedChunk);
+    }
+  } else {
+    // TODO: We should be freezing the element but currently, we might write into
+    // _debugInfo later. We could move it into _store which remains mutable.
+    Object.freeze(element.props);
+  }
+
+  return element;
+}
+
+function createLazyChunkWrapper(chunk) {
+  var lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: chunk,
+    _init: readChunk
+  };
+
+  {
+    // Ensure we have a live array to track future debug info.
+    var chunkDebugInfo = chunk._debugInfo || (chunk._debugInfo = []);
+    lazyType._debugInfo = chunkDebugInfo;
+  }
+
+  return lazyType;
+}
+
+function getChunk(response, id) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    if (response._closed) {
+      // We have already errored the response and we're not going to get
+      // anything more streaming in so this will immediately error.
+      chunk = createErrorChunk(response, response._closedReason);
+    } else {
+      chunk = createPendingChunk(response);
+    }
+
+    chunks.set(id, chunk);
+  }
+
+  return chunk;
+}
+
+function waitForReference(referencedChunk, parentObject, key, response, map, path) {
+  var handler;
+
+  if (initializingHandler) {
+    handler = initializingHandler;
+    handler.deps++;
+  } else {
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: false
+    };
+  }
+
+  function fulfill(value) {
+    for (var i = 1; i < path.length; i++) {
+      while (value.$$typeof === REACT_LAZY_TYPE) {
+        // We never expect to see a Lazy node on this path because we encode those as
+        // separate models. This must mean that we have inserted an extra lazy node
+        // e.g. to replace a blocked element. We must instead look for it inside.
+        var chunk = value._payload;
+
+        if (chunk === handler.chunk) {
+          // This is a reference to the thing we're currently blocking. We can peak
+          // inside of it to get the value.
+          value = handler.value;
+          continue;
+        } else if (chunk.status === INITIALIZED) {
+          value = chunk.value;
+          continue;
+        } else {
+          // If we're not yet initialized we need to skip what we've already drilled
+          // through and then wait for the next value to become available.
+          path.splice(0, i - 1);
+          chunk.then(fulfill, reject);
+          return;
+        }
+      }
+
+      value = value[path[i]];
+    }
+
+    var mappedValue = map(response, value, parentObject, key);
+    parentObject[key] = mappedValue; // If this is the root object for a model reference, where `handler.value`
+    // is a stale `null`, the resolved value can be used directly.
+
+    if (key === '' && handler.value === null) {
+      handler.value = mappedValue;
+    } // If the parent object is an unparsed React element tuple, we also need to
+    // update the props and owner of the parsed element object (i.e.
+    // handler.value).
+
+
+    if (parentObject[0] === REACT_ELEMENT_TYPE && typeof handler.value === 'object' && handler.value !== null && handler.value.$$typeof === REACT_ELEMENT_TYPE) {
+      var element = handler.value;
+
+      switch (key) {
+        case '3':
+          element.props = mappedValue;
+          break;
+
+        case '4':
+          {
+            element._owner = mappedValue;
+          }
+
+          break;
+      }
+    }
+
+    handler.deps--;
+
+    if (handler.deps === 0) {
+      var _chunk = handler.chunk;
+
+      if (_chunk === null || _chunk.status !== BLOCKED) {
+        return;
+      }
+
+      var resolveListeners = _chunk.value;
+      var initializedChunk = _chunk;
+      initializedChunk.status = INITIALIZED;
+      initializedChunk.value = handler.value;
+
+      if (resolveListeners !== null) {
+        wakeChunk(resolveListeners, handler.value);
+      }
+    }
+  }
+
+  function reject(error) {
+    if (handler.errored) {
+      // We've already errored. We could instead build up an AggregateError
+      // but if there are multiple errors we just take the first one like
+      // Promise.all.
+      return;
+    }
+
+    var blockedValue = handler.value;
+    handler.errored = true;
+    handler.value = error;
+    var chunk = handler.chunk;
+
+    if (chunk === null || chunk.status !== BLOCKED) {
+      return;
+    }
+
+    {
+      if (typeof blockedValue === 'object' && blockedValue !== null && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
+        var element = blockedValue; // Conceptually the error happened inside this Element but right before
+        // it was rendered. We don't have a client side component to render but
+        // we can add some DebugInfo to explain that this was conceptually a
+        // Server side error that errored inside this element. That way any stack
+        // traces will point to the nearest JSX that errored - e.g. during
+        // serialization.
+
+        var erroredComponent = {
+          name: getComponentNameFromType(element.type) || '',
+          owner: element._owner
+        };
+
+        {
+          // $FlowFixMe[cannot-write]
+          erroredComponent.debugStack = element._debugStack;
+
+          if (supportsCreateTask) {
+            // $FlowFixMe[cannot-write]
+            erroredComponent.debugTask = element._debugTask;
+          }
+        }
+
+        var chunkDebugInfo = chunk._debugInfo || (chunk._debugInfo = []);
+        chunkDebugInfo.push(erroredComponent);
+      }
+    }
+
+    triggerErrorOnChunk(chunk, error);
+  }
+
+  referencedChunk.then(fulfill, reject); // Return a place holder value for now.
+
+  return null;
+}
+
+function loadServerReference(response, metaData, parentObject, key) {
+  if (!response._serverReferenceConfig) {
+    // In the normal case, we can't load this Server Reference in the current environment and
+    // we just return a proxy to it.
+    return createBoundServerReference(metaData, response._callServer, response._encodeFormAction, response._debugFindSourceMapURL );
+  } // If we have a module mapping we can load the real version of this Server Reference.
+
+
+  var serverReference = resolveServerReference(response._serverReferenceConfig, metaData.id);
+  var promise = preloadModule(serverReference);
+
+  if (!promise) {
+    if (!metaData.bound) {
+      return requireModule(serverReference);
+    } else {
+      promise = Promise.resolve(metaData.bound);
+    }
+  } else if (metaData.bound) {
+    promise = Promise.all([promise, metaData.bound]);
+  }
+
+  var handler;
+
+  if (initializingHandler) {
+    handler = initializingHandler;
+    handler.deps++;
+  } else {
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: false
+    };
+  }
+
+  function fulfill() {
+    var resolvedValue = requireModule(serverReference);
+
+    if (metaData.bound) {
+      // This promise is coming from us and should have initilialized by now.
+      var boundArgs = metaData.bound.value.slice(0);
+      boundArgs.unshift(null); // this
+
+      resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+    }
+
+    parentObject[key] = resolvedValue; // If this is the root object for a model reference, where `handler.value`
+    // is a stale `null`, the resolved value can be used directly.
+
+    if (key === '' && handler.value === null) {
+      handler.value = resolvedValue;
+    } // If the parent object is an unparsed React element tuple, we also need to
+    // update the props and owner of the parsed element object (i.e.
+    // handler.value).
+
+
+    if (parentObject[0] === REACT_ELEMENT_TYPE && typeof handler.value === 'object' && handler.value !== null && handler.value.$$typeof === REACT_ELEMENT_TYPE) {
+      var element = handler.value;
+
+      switch (key) {
+        case '3':
+          element.props = resolvedValue;
+          break;
+
+        case '4':
+          {
+            element._owner = resolvedValue;
+          }
+
+          break;
+      }
+    }
+
+    handler.deps--;
+
+    if (handler.deps === 0) {
+      var chunk = handler.chunk;
+
+      if (chunk === null || chunk.status !== BLOCKED) {
+        return;
+      }
+
+      var resolveListeners = chunk.value;
+      var initializedChunk = chunk;
+      initializedChunk.status = INITIALIZED;
+      initializedChunk.value = handler.value;
+
+      if (resolveListeners !== null) {
+        wakeChunk(resolveListeners, handler.value);
+      }
+    }
+  }
+
+  function reject(error) {
+    if (handler.errored) {
+      // We've already errored. We could instead build up an AggregateError
+      // but if there are multiple errors we just take the first one like
+      // Promise.all.
+      return;
+    }
+
+    var blockedValue = handler.value;
+    handler.errored = true;
+    handler.value = error;
+    var chunk = handler.chunk;
+
+    if (chunk === null || chunk.status !== BLOCKED) {
+      return;
+    }
+
+    {
+      if (typeof blockedValue === 'object' && blockedValue !== null && blockedValue.$$typeof === REACT_ELEMENT_TYPE) {
+        var element = blockedValue; // Conceptually the error happened inside this Element but right before
+        // it was rendered. We don't have a client side component to render but
+        // we can add some DebugInfo to explain that this was conceptually a
+        // Server side error that errored inside this element. That way any stack
+        // traces will point to the nearest JSX that errored - e.g. during
+        // serialization.
+
+        var erroredComponent = {
+          name: getComponentNameFromType(element.type) || '',
+          owner: element._owner
+        };
+
+        {
+          // $FlowFixMe[cannot-write]
+          erroredComponent.debugStack = element._debugStack;
+
+          if (supportsCreateTask) {
+            // $FlowFixMe[cannot-write]
+            erroredComponent.debugTask = element._debugTask;
+          }
+        }
+
+        var chunkDebugInfo = chunk._debugInfo || (chunk._debugInfo = []);
+        chunkDebugInfo.push(erroredComponent);
+      }
+    }
+
+    triggerErrorOnChunk(chunk, error);
+  }
+
+  promise.then(fulfill, reject); // Return a place holder value for now.
+
+  return null;
+}
+
+function getOutlinedModel(response, reference, parentObject, key, map) {
+  var path = reference.split(':');
+  var id = parseInt(path[0], 16);
+  var chunk = getChunk(response, id);
+
+  {
+    if (initializingChunk !== null && isArray(initializingChunk._children)) {
+      initializingChunk._children.push(chunk);
+    }
+  }
+
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      var value = chunk.value;
+
+      for (var i = 1; i < path.length; i++) {
+        while (value.$$typeof === REACT_LAZY_TYPE) {
+          var referencedChunk = value._payload;
+
+          if (referencedChunk.status === INITIALIZED) {
+            value = referencedChunk.value;
+          } else {
+            return waitForReference(referencedChunk, parentObject, key, response, map, path.slice(i - 1));
+          }
+        }
+
+        value = value[path[i]];
+      }
+
+      var chunkValue = map(response, value, parentObject, key);
+
+      if (chunk._debugInfo) {
+        // If we have a direct reference to an object that was rendered by a synchronous
+        // server component, it might have some debug info about how it was rendered.
+        // We forward this to the underlying object. This might be a React Element or
+        // an Array fragment.
+        // If this was a string / number return value we lose the debug info. We choose
+        // that tradeoff to allow sync server components to return plain values and not
+        // use them as React Nodes necessarily. We could otherwise wrap them in a Lazy.
+        if (typeof chunkValue === 'object' && chunkValue !== null && (isArray(chunkValue) || typeof chunkValue[ASYNC_ITERATOR] === 'function' || chunkValue.$$typeof === REACT_ELEMENT_TYPE) && !chunkValue._debugInfo) {
+          // We should maybe use a unique symbol for arrays but this is a React owned array.
+          // $FlowFixMe[prop-missing]: This should be added to elements.
+          Object.defineProperty(chunkValue, '_debugInfo', {
+            configurable: false,
+            enumerable: false,
+            writable: true,
+            value: chunk._debugInfo
+          });
+        }
+      }
+
+      return chunkValue;
+
+    case PENDING:
+    case BLOCKED:
+      return waitForReference(chunk, parentObject, key, response, map, path);
+
+    default:
+      // This is an error. Instead of erroring directly, we're going to encode this on
+      // an initialization handler so that we can catch it at the nearest Element.
+      if (initializingHandler) {
+        initializingHandler.errored = true;
+        initializingHandler.value = chunk.reason;
+      } else {
+        initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: chunk.reason,
+          deps: 0,
+          errored: true
+        };
+      } // Placeholder
+
+
+      return null;
+  }
+}
+
+function createMap(response, model) {
+  return new Map(model);
+}
+
+function createSet(response, model) {
+  return new Set(model);
+}
+
+function createBlob(response, model) {
+  return new Blob(model.slice(1), {
+    type: model[0]
+  });
+}
+
+function createFormData(response, model) {
+  var formData = new FormData();
+
+  for (var i = 0; i < model.length; i++) {
+    formData.append(model[i][0], model[i][1]);
+  }
+
+  return formData;
+}
+
+function extractIterator(response, model) {
+  // $FlowFixMe[incompatible-use]: This uses raw Symbols because we're extracting from a native array.
+  return model[Symbol.iterator]();
+}
+
+function createModel(response, model) {
+  return model;
+}
+
+function parseModelString(response, parentObject, key, value) {
+  if (value[0] === '$') {
+    if (value === '$') {
+      // A very common symbol.
+      if (initializingHandler !== null && key === '0') {
+        // We we already have an initializing handler and we're abound to enter
+        // a new element, we need to shadow it because we're now in a new scope.
+        // This is effectively the "begin" or "push" phase of Element parsing.
+        // We'll pop later when we parse the array itself.
+        initializingHandler = {
+          parent: initializingHandler,
+          chunk: null,
+          value: null,
+          deps: 0,
+          errored: false
+        };
+      }
+
+      return REACT_ELEMENT_TYPE;
+    }
+
+    switch (value[1]) {
+      case '$':
+        {
+          // This was an escaped string value.
+          return value.slice(1);
+        }
+
+      case 'L':
+        {
+          // Lazy node
+          var id = parseInt(value.slice(2), 16);
+          var chunk = getChunk(response, id);
+
+          {
+            if (initializingChunk !== null && isArray(initializingChunk._children)) {
+              initializingChunk._children.push(chunk);
+            }
+          } // We create a React.lazy wrapper around any lazy values.
+          // When passed into React, we'll know how to suspend on this.
+
+
+          return createLazyChunkWrapper(chunk);
+        }
+
+      case '@':
+        {
+          // Promise
+          if (value.length === 2) {
+            // Infinite promise that never resolves.
+            return new Promise(function () {});
+          }
+
+          var _id = parseInt(value.slice(2), 16);
+
+          var _chunk2 = getChunk(response, _id);
+
+          {
+            if (initializingChunk !== null && isArray(initializingChunk._children)) {
+              initializingChunk._children.push(_chunk2);
+            }
+          }
+
+          return _chunk2;
+        }
+
+      case 'S':
+        {
+          // Symbol
+          return Symbol.for(value.slice(2));
+        }
+
+      case 'F':
+        {
+          // Server Reference
+          var ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, loadServerReference);
+        }
+
+      case 'T':
+        {
+          // Temporary Reference
+          var reference = '$' + value.slice(2);
+          var temporaryReferences = response._tempRefs;
+
+          if (temporaryReferences == null) {
+            throw new Error('Missing a temporary reference set but the RSC response returned a temporary reference. ' + 'Pass a temporaryReference option with the set that was used with the reply.');
+          }
+
+          return readTemporaryReference(temporaryReferences, reference);
+        }
+
+      case 'Q':
+        {
+          // Map
+          var _ref = value.slice(2);
+
+          return getOutlinedModel(response, _ref, parentObject, key, createMap);
+        }
+
+      case 'W':
+        {
+          // Set
+          var _ref2 = value.slice(2);
+
+          return getOutlinedModel(response, _ref2, parentObject, key, createSet);
+        }
+
+      case 'B':
+        {
+          // Blob
+          var _ref3 = value.slice(2);
+
+          return getOutlinedModel(response, _ref3, parentObject, key, createBlob);
+        }
+
+      case 'K':
+        {
+          // FormData
+          var _ref4 = value.slice(2);
+
+          return getOutlinedModel(response, _ref4, parentObject, key, createFormData);
+        }
+
+      case 'Z':
+        {
+          // Error
+          {
+            var _ref5 = value.slice(2);
+
+            return getOutlinedModel(response, _ref5, parentObject, key, resolveErrorDev);
+          }
+        }
+
+      case 'i':
+        {
+          // Iterator
+          var _ref6 = value.slice(2);
+
+          return getOutlinedModel(response, _ref6, parentObject, key, extractIterator);
+        }
+
+      case 'I':
+        {
+          // $Infinity
+          return Infinity;
+        }
+
+      case '-':
+        {
+          // $-0 or $-Infinity
+          if (value === '$-0') {
+            return -0;
+          } else {
+            return -Infinity;
+          }
+        }
+
+      case 'N':
+        {
+          // $NaN
+          return NaN;
+        }
+
+      case 'u':
+        {
+          // matches "$undefined"
+          // Special encoding for `undefined` which can't be serialized as JSON otherwise.
+          return undefined;
+        }
+
+      case 'D':
+        {
+          // Date
+          return new Date(Date.parse(value.slice(2)));
+        }
+
+      case 'n':
+        {
+          // BigInt
+          return BigInt(value.slice(2));
+        }
+
+      case 'E':
+        {
+          {
+            // In DEV mode we allow indirect eval to produce functions for logging.
+            // This should not compile to eval() because then it has local scope access.
+            try {
+              // eslint-disable-next-line no-eval
+              return (0, eval)(value.slice(2));
+            } catch (x) {
+              // We currently use this to express functions so we fail parsing it,
+              // let's just return a blank function as a place holder.
+              return function () {};
+            }
+          } // Fallthrough
+
+        }
+
+      case 'Y':
+        {
+          {
+            // In DEV mode we encode omitted objects in logs as a getter that throws
+            // so that when you try to access it on the client, you know why that
+            // happened.
+            Object.defineProperty(parentObject, key, {
+              get: function () {
+                // TODO: We should ideally throw here to indicate a difference.
+                return 'This object has been omitted by React in the console log ' + 'to avoid sending too much data from the server. Try logging smaller ' + 'or more specific objects.';
+              },
+              enumerable: true,
+              configurable: false
+            });
+            return null;
+          } // Fallthrough
+
+        }
+
+      default:
+        {
+          // We assume that anything else is a reference ID.
+          var _ref7 = value.slice(1);
+
+          return getOutlinedModel(response, _ref7, parentObject, key, createModel);
+        }
+    }
+  }
+
+  return value;
+}
+
+function parseModelTuple(response, value) {
+  var tuple = value;
+
+  if (tuple[0] === REACT_ELEMENT_TYPE) {
+    // TODO: Consider having React just directly accept these arrays as elements.
+    // Or even change the ReactElement type to be an array.
+    return createElement(response, tuple[1], tuple[2], tuple[3], tuple[4] , tuple[5] , tuple[6] );
+  }
+
+  return value;
+}
+
+function missingCall() {
+  throw new Error('Trying to call a function from "use server" but the callServer option ' + 'was not implemented in your router runtime.');
+}
+
+function ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName) {
+  var chunks = new Map();
+  this._bundlerConfig = bundlerConfig;
+  this._serverReferenceConfig = serverReferenceConfig;
+  this._moduleLoading = moduleLoading;
+  this._callServer = callServer !== undefined ? callServer : missingCall;
+  this._encodeFormAction = encodeFormAction;
+  this._nonce = nonce;
+  this._chunks = chunks;
+  this._stringDecoder = createStringDecoder();
+  this._fromJSON = null;
+  this._rowState = 0;
+  this._rowID = 0;
+  this._rowTag = 0;
+  this._rowLength = 0;
+  this._buffer = [];
+  this._closed = false;
+  this._closedReason = null;
+  this._tempRefs = temporaryReferences;
+
+  {
+    this._timeOrigin = 0;
+  }
+
+  {
+    // TODO: The Flight Client can be used in a Client Environment too and we should really support
+    // getting the owner there as well, but currently the owner of ReactComponentInfo is typed as only
+    // supporting other ReactComponentInfo as owners (and not Fiber or Fizz's ComponentStackNode).
+    // We need to update all the callsites consuming ReactComponentInfo owners to support those.
+    // In the meantime we only check ReactSharedInteralsServer since we know that in an RSC environment
+    // the only owners will be ReactComponentInfo.
+    var rootOwner = ReactSharedInteralsServer === undefined || ReactSharedInteralsServer.A === null ? null : ReactSharedInteralsServer.A.getOwner();
+    this._debugRootOwner = rootOwner;
+    this._debugRootStack = rootOwner !== null ? // TODO: Consider passing the top frame in so we can avoid internals showing up.
+    new Error('react-stack-top-frame') : null;
+    var rootEnv = environmentName === undefined ? 'Server' : environmentName;
+
+    if (supportsCreateTask) {
+      // Any stacks that appear on the server need to be rooted somehow on the client
+      // so we create a root Task for this response which will be the root owner for any
+      // elements created by the server. We use the "use server" string to indicate that
+      // this is where we enter the server from the client.
+      // TODO: Make this string configurable.
+      this._debugRootTask = console.createTask('"use ' + rootEnv.toLowerCase() + '"');
+    }
+
+    this._debugFindSourceMapURL = findSourceMapURL;
+    this._replayConsole = replayConsole;
+    this._rootEnvironmentName = rootEnv;
+  } // Don't inline this call because it causes closure to outline the call above.
+
+
+  this._fromJSON = createFromJSONCallback(this);
+}
+
+function createResponse(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName) {
+  // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors
+  return new ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName);
+}
+
+function resolveModel(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModelChunk(response, model));
+  } else {
+    resolveModelChunk(chunk, model);
+  }
+}
+
+function resolveText(response, id, text) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (chunk && chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    var streamChunk = chunk;
+    var controller = streamChunk.reason;
+    controller.enqueueValue(text);
+    return;
+  }
+
+  chunks.set(id, createInitializedTextChunk(response, text));
+}
+
+function resolveBuffer(response, id, buffer) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (chunk && chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    var streamChunk = chunk;
+    var controller = streamChunk.reason;
+    controller.enqueueValue(buffer);
+    return;
+  }
+
+  chunks.set(id, createInitializedBufferChunk(response, buffer));
+}
+
+function resolveModule(response, id, model) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+  var clientReferenceMetadata = parseModel(response, model);
+  var clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
+  // For now we preload all modules as early as possible since it's likely
+  // that we'll need them.
+
+  var promise = preloadModule(clientReference);
+
+  if (promise) {
+    var blockedChunk;
+
+    if (!chunk) {
+      // Technically, we should just treat promise as the chunk in this
+      // case. Because it'll just behave as any other promise.
+      blockedChunk = createBlockedChunk(response);
+      chunks.set(id, blockedChunk);
+    } else {
+      // This can't actually happen because we don't have any forward
+      // references to modules.
+      blockedChunk = chunk;
+      blockedChunk.status = BLOCKED;
+    }
+
+    promise.then(function () {
+      return resolveModuleChunk(blockedChunk, clientReference);
+    }, function (error) {
+      return triggerErrorOnChunk(blockedChunk, error);
+    });
+  } else {
+    if (!chunk) {
+      chunks.set(id, createResolvedModuleChunk(response, clientReference));
+    } else {
+      // This can't actually happen because we don't have any forward
+      // references to modules.
+      resolveModuleChunk(chunk, clientReference);
+    }
+  }
+}
+
+function resolveStream(response, id, stream, controller) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createInitializedStreamChunk(response, stream, controller));
+    return;
+  }
+
+  if (chunk.status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  var resolveListeners = chunk.value;
+  var resolvedChunk = chunk;
+  resolvedChunk.status = INITIALIZED;
+  resolvedChunk.value = stream;
+  resolvedChunk.reason = controller;
+
+  if (resolveListeners !== null) {
+    wakeChunk(resolveListeners, chunk.value);
+  }
+}
+
+function startReadableStream(response, id, type) {
+  var controller = null;
+  var stream = new ReadableStream({
+    type: type,
+    start: function (c) {
+      controller = c;
+    }
+  });
+  var previousBlockedChunk = null;
+  var flightController = {
+    enqueueValue: function (value) {
+      if (previousBlockedChunk === null) {
+        controller.enqueue(value);
+      } else {
+        // We're still waiting on a previous chunk so we can't enqueue quite yet.
+        previousBlockedChunk.then(function () {
+          controller.enqueue(value);
+        });
+      }
+    },
+    enqueueModel: function (json) {
+      if (previousBlockedChunk === null) {
+        // If we're not blocked on any other chunks, we can try to eagerly initialize
+        // this as a fast-path to avoid awaiting them.
+        var chunk = createResolvedModelChunk(response, json);
+        initializeModelChunk(chunk);
+        var initializedChunk = chunk;
+
+        if (initializedChunk.status === INITIALIZED) {
+          controller.enqueue(initializedChunk.value);
+        } else {
+          chunk.then(function (v) {
+            return controller.enqueue(v);
+          }, function (e) {
+            return controller.error(e);
+          });
+          previousBlockedChunk = chunk;
+        }
+      } else {
+        // We're still waiting on a previous chunk so we can't enqueue quite yet.
+        var blockedChunk = previousBlockedChunk;
+
+        var _chunk3 = createPendingChunk(response);
+
+        _chunk3.then(function (v) {
+          return controller.enqueue(v);
+        }, function (e) {
+          return controller.error(e);
+        });
+
+        previousBlockedChunk = _chunk3;
+        blockedChunk.then(function () {
+          if (previousBlockedChunk === _chunk3) {
+            // We were still the last chunk so we can now clear the queue and return
+            // to synchronous emitting.
+            previousBlockedChunk = null;
+          }
+
+          resolveModelChunk(_chunk3, json);
+        });
+      }
+    },
+    close: function (json) {
+      if (previousBlockedChunk === null) {
+        controller.close();
+      } else {
+        var blockedChunk = previousBlockedChunk; // We shouldn't get any more enqueues after this so we can set it back to null.
+
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.close();
+        });
+      }
+    },
+    error: function (error) {
+      if (previousBlockedChunk === null) {
+        // $FlowFixMe[incompatible-call]
+        controller.error(error);
+      } else {
+        var blockedChunk = previousBlockedChunk; // We shouldn't get any more enqueues after this so we can set it back to null.
+
+        previousBlockedChunk = null;
+        blockedChunk.then(function () {
+          return controller.error(error);
+        });
+      }
+    }
+  };
+  resolveStream(response, id, stream, flightController);
+}
+
+function asyncIterator() {
+  // Self referencing iterator.
+  return this;
+}
+
+function createIterator(next) {
+  var iterator = {
+    next: next // TODO: Add return/throw as options for aborting.
+
+  }; // TODO: The iterator could inherit the AsyncIterator prototype which is not exposed as
+  // a global but exists as a prototype of an AsyncGenerator. However, it's not needed
+  // to satisfy the iterable protocol.
+
+  iterator[ASYNC_ITERATOR] = asyncIterator;
+  return iterator;
+}
+
+function startAsyncIterable(response, id, iterator) {
+  var buffer = [];
+  var closed = false;
+  var nextWriteIndex = 0;
+  var flightController = {
+    enqueueValue: function (value) {
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createInitializedIteratorResultChunk(response, value, false);
+      } else {
+        var chunk = buffer[nextWriteIndex];
+        var resolveListeners = chunk.value;
+        var rejectListeners = chunk.reason;
+        var initializedChunk = chunk;
+        initializedChunk.status = INITIALIZED;
+        initializedChunk.value = {
+          done: false,
+          value: value
+        };
+
+        if (resolveListeners !== null) {
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+        }
+      }
+
+      nextWriteIndex++;
+    },
+    enqueueModel: function (value) {
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, false);
+      } else {
+        resolveIteratorResultChunk(buffer[nextWriteIndex], value, false);
+      }
+
+      nextWriteIndex++;
+    },
+    close: function (value) {
+      closed = true;
+
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, true);
+      } else {
+        resolveIteratorResultChunk(buffer[nextWriteIndex], value, true);
+      }
+
+      nextWriteIndex++;
+
+      while (nextWriteIndex < buffer.length) {
+        // In generators, any extra reads from the iterator have the value undefined.
+        resolveIteratorResultChunk(buffer[nextWriteIndex++], '"$undefined"', true);
+      }
+    },
+    error: function (error) {
+      closed = true;
+
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createPendingChunk(response);
+      }
+
+      while (nextWriteIndex < buffer.length) {
+        triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+      }
+    }
+  };
+
+  var iterable = _defineProperty({}, ASYNC_ITERATOR, function () {
+    var nextReadIndex = 0;
+    return createIterator(function (arg) {
+      if (arg !== undefined) {
+        throw new Error('Values cannot be passed to next() of AsyncIterables passed to Client Components.');
+      }
+
+      if (nextReadIndex === buffer.length) {
+        if (closed) {
+          // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+          return new ReactPromise(INITIALIZED, {
+            done: true,
+            value: undefined
+          }, null, response);
+        }
+
+        buffer[nextReadIndex] = createPendingChunk(response);
+      }
+
+      return buffer[nextReadIndex++];
+    });
+  }); // TODO: If it's a single shot iterator we can optimize memory by cleaning up the buffer after
+  // reading through the end, but currently we favor code size over this optimization.
+
+
+  resolveStream(response, id, iterator ? iterable[ASYNC_ITERATOR]() : iterable, flightController);
+}
+
+function stopStream(response, id, row) {
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk || chunk.status !== INITIALIZED) {
+    // We didn't expect not to have an existing stream;
+    return;
+  }
+
+  var streamChunk = chunk;
+  var controller = streamChunk.reason;
+  controller.close(row === '' ? '"$undefined"' : row);
+}
+
+function resolveErrorDev(response, errorInfo) {
+  var message = errorInfo.message;
+  var stack = errorInfo.stack;
+  var env = errorInfo.env;
+
+  var error;
+  var callStack = buildFakeCallStack(response, stack, env, // $FlowFixMe[incompatible-use]
+  Error.bind(null, message || 'An error occurred in the Server Components render but no message was provided'));
+  var rootTask = getRootTask(response, env);
+
+  if (rootTask != null) {
+    error = rootTask.run(callStack);
+  } else {
+    error = callStack();
+  }
+
+  error.environmentName = env;
+  return error;
+}
+
+function resolvePostponeDev(response, id, reason, stack, env) {
+
+  var postponeInstance;
+
+  {
+    var callStack = buildFakeCallStack(response, stack, env, // $FlowFixMe[incompatible-use]
+    Error.bind(null, reason || ''));
+    var rootTask = response._debugRootTask;
+
+    if (rootTask != null) {
+      postponeInstance = rootTask.run(callStack);
+    } else {
+      postponeInstance = callStack();
+    }
+
+    postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  }
+
+  var chunks = response._chunks;
+  var chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createErrorChunk(response, postponeInstance));
+  } else {
+    triggerErrorOnChunk(chunk, postponeInstance);
+  }
+}
+
+function resolveHint(response, code, model) {
+  var hintModel = parseModel(response, model);
+  dispatchHint(code, hintModel);
+}
+
+var supportsCreateTask = !!console.createTask;
+var fakeFunctionCache = new Map() ;
+var fakeFunctionIdx = 0;
+
+function createFakeFunction(name, filename, sourceMap, line, col, environmentName) {
+  // This creates a fake copy of a Server Module. It represents a module that has already
+  // executed on the server but we re-execute a blank copy for its stack frames on the client.
+  var comment = '/* This module was rendered by a Server Component. Turn on Source Maps to see the server source. */';
+
+  if (!name) {
+    // An eval:ed function with no name gets the name "eval". We give it something more descriptive.
+    name = '<anonymous>';
+  }
+
+  var encodedName = JSON.stringify(name); // We generate code where the call is at the line and column of the server executed code.
+  // This allows us to use the original source map as the source map of this fake file to
+  // point to the original source.
+
+  var code;
+
+  if (line <= 1) {
+    var minSize = encodedName.length + 7;
+    code = '({' + encodedName + ':_=>' + ' '.repeat(col < minSize ? 0 : col - minSize) + '_()})\n' + comment;
+  } else {
+    code = comment + '\n'.repeat(line - 2) + '({' + encodedName + ':_=>\n' + ' '.repeat(col < 1 ? 0 : col - 1) + '_()})';
+  }
+
+  if (filename.startsWith('/')) {
+    // If the filename starts with `/` we assume that it is a file system file
+    // rather than relative to the current host. Since on the server fully qualified
+    // stack traces use the file path.
+    // TODO: What does this look like on Windows?
+    filename = 'file://' + filename;
+  }
+
+  if (sourceMap) {
+    // We use the prefix rsc://React/ to separate these from other files listed in
+    // the Chrome DevTools. We need a "host name" and not just a protocol because
+    // otherwise the group name becomes the root folder. Ideally we don't want to
+    // show these at all but there's two reasons to assign a fake URL.
+    // 1) A printed stack trace string needs a unique URL to be able to source map it.
+    // 2) If source maps are disabled or fails, you should at least be able to tell
+    //    which file it was.
+    code += '\n//# sourceURL=rsc://React/' + encodeURIComponent(environmentName) + '/' + encodeURI(filename) + '?' + fakeFunctionIdx++;
+    code += '\n//# sourceMappingURL=' + sourceMap;
+  } else if (filename) {
+    code += '\n//# sourceURL=' + encodeURI(filename);
+  } else {
+    code += '\n//# sourceURL=<anonymous>';
+  }
+
+  var fn;
+
+  try {
+    // eslint-disable-next-line no-eval
+    fn = (0, eval)(code)[name];
+  } catch (x) {
+    // If eval fails, such as if in an environment that doesn't support it,
+    // we fallback to creating a function here. It'll still have the right
+    // name but it'll lose line/column number and file name.
+    fn = function (_) {
+      return _();
+    };
+  }
+
+  return fn;
+}
+
+function buildFakeCallStack(response, stack, environmentName, innerCall) {
+  var callStack = innerCall;
+
+  for (var i = 0; i < stack.length; i++) {
+    var frame = stack[i];
+    var frameKey = frame.join('-') + '-' + environmentName;
+    var fn = fakeFunctionCache.get(frameKey);
+
+    if (fn === undefined) {
+      var name = frame[0],
+          filename = frame[1],
+          line = frame[2],
+          col = frame[3];
+      var findSourceMapURL = response._debugFindSourceMapURL;
+      var sourceMap = findSourceMapURL ? findSourceMapURL(filename, environmentName) : null;
+      fn = createFakeFunction(name, filename, sourceMap, line, col, environmentName); // TODO: This cache should technically live on the response since the _debugFindSourceMapURL
+      // function is an input and can vary by response.
+
+      fakeFunctionCache.set(frameKey, fn);
+    }
+
+    callStack = fn.bind(null, callStack);
+  }
+
+  return callStack;
+}
+
+function getRootTask(response, childEnvironmentName) {
+  var rootTask = response._debugRootTask;
+
+  if (!rootTask) {
+    return null;
+  }
+
+  if (response._rootEnvironmentName !== childEnvironmentName) {
+    // If the root most owner component is itself in a different environment than the requested
+    // environment then we create an extra task to indicate that we're transitioning into it.
+    // Like if one environment just requests another environment.
+    var createTaskFn = console.createTask.bind(console, '"use ' + childEnvironmentName.toLowerCase() + '"');
+    return rootTask.run(createTaskFn);
+  }
+
+  return rootTask;
+}
+
+function initializeFakeTask(response, debugInfo, childEnvironmentName) {
+  if (!supportsCreateTask) {
+    return null;
+  }
+
+  var componentInfo = debugInfo; // Refined
+
+  if (debugInfo.stack == null) {
+    // If this is an error, we should've really already initialized the task.
+    // If it's null, we can't initialize a task.
+    return null;
+  }
+
+  var stack = debugInfo.stack;
+  var env = componentInfo.env == null ? response._rootEnvironmentName : componentInfo.env;
+
+  if (env !== childEnvironmentName) {
+    // This is the boundary between two environments so we'll annotate the task name.
+    // That is unusual so we don't cache it.
+    var ownerTask = componentInfo.owner == null ? null : initializeFakeTask(response, componentInfo.owner, env);
+    return buildFakeTask(response, ownerTask, stack, '"use ' + childEnvironmentName.toLowerCase() + '"', env);
+  } else {
+    var cachedEntry = componentInfo.debugTask;
+
+    if (cachedEntry !== undefined) {
+      return cachedEntry;
+    }
+
+    var _ownerTask = componentInfo.owner == null ? null : initializeFakeTask(response, componentInfo.owner, env); // $FlowFixMe[cannot-write]: We consider this part of initialization.
+
+
+    return componentInfo.debugTask = buildFakeTask(response, _ownerTask, stack, getServerComponentTaskName(componentInfo), env);
+  }
+}
+
+function buildFakeTask(response, ownerTask, stack, taskName, env) {
+  var createTaskFn = console.createTask.bind(console, taskName);
+  var callStack = buildFakeCallStack(response, stack, env, createTaskFn);
+
+  if (ownerTask === null) {
+    var rootTask = getRootTask(response, env);
+
+    if (rootTask != null) {
+      return rootTask.run(callStack);
+    } else {
+      return callStack();
+    }
+  } else {
+    return ownerTask.run(callStack);
+  }
+}
+
+var createFakeJSXCallStack = {
+  'react-stack-bottom-frame': function (response, stack, environmentName) {
+    var callStackForError = buildFakeCallStack(response, stack, environmentName, fakeJSXCallSite);
+    return callStackForError();
+  }
+};
+var createFakeJSXCallStackInDEV = // We use this technique to trick minifiers to preserve the function name.
+createFakeJSXCallStack['react-stack-bottom-frame'].bind(createFakeJSXCallStack) ;
+/** @noinline */
+
+function fakeJSXCallSite() {
+  // This extra call frame represents the JSX creation function. We always pop this frame
+  // off before presenting so it needs to be part of the stack.
+  return new Error('react-stack-top-frame');
+}
+
+function initializeFakeStack(response, debugInfo) {
+  var cachedEntry = debugInfo.debugStack;
+
+  if (cachedEntry !== undefined) {
+    return;
+  }
+
+  if (debugInfo.stack != null) {
+    var stack = debugInfo.stack;
+    var env = debugInfo.env == null ? '' : debugInfo.env; // $FlowFixMe[cannot-write]
+
+    debugInfo.debugStack = createFakeJSXCallStackInDEV(response, stack, env);
+  }
+
+  if (debugInfo.owner != null) {
+    // Initialize any owners not yet initialized.
+    initializeFakeStack(response, debugInfo.owner);
+  }
+}
+
+function resolveDebugInfo(response, id, debugInfo) {
+  // render phase so we're not inside a user space stack at this point. If we waited
+  // to initialize it when we need it, we might be inside user code.
+
+
+  var env = debugInfo.env === undefined ? response._rootEnvironmentName : debugInfo.env;
+
+  if (debugInfo.stack !== undefined) {
+    var componentInfoOrAsyncInfo = // $FlowFixMe[incompatible-type]
+    debugInfo;
+    initializeFakeTask(response, componentInfoOrAsyncInfo, env);
+  }
+
+  if (debugInfo.owner === null && response._debugRootOwner != null) {
+    // $FlowFixMe[prop-missing] By narrowing `owner` to `null`, we narrowed `debugInfo` to `ReactComponentInfo`
+    var componentInfo = debugInfo; // $FlowFixMe[cannot-write]
+
+    componentInfo.owner = response._debugRootOwner; // We override the stack if we override the owner since the stack where the root JSX
+    // was created on the server isn't very useful but where the request was made is.
+    // $FlowFixMe[cannot-write]
+
+    componentInfo.debugStack = response._debugRootStack;
+  } else if (debugInfo.stack !== undefined) {
+    var _componentInfoOrAsyncInfo = // $FlowFixMe[incompatible-type]
+    debugInfo;
+    initializeFakeStack(response, _componentInfoOrAsyncInfo);
+  }
+
+  {
+    if (typeof debugInfo.time === 'number') {
+      // Adjust the time to the current environment's time space.
+      // Since this might be a deduped object, we clone it to avoid
+      // applying the adjustment twice.
+      debugInfo = {
+        time: debugInfo.time + response._timeOrigin
+      };
+    }
+  }
+
+  var chunk = getChunk(response, id);
+  var chunkDebugInfo = chunk._debugInfo || (chunk._debugInfo = []);
+  chunkDebugInfo.push(debugInfo);
+}
+
+var currentOwnerInDEV = null;
+
+function getCurrentStackInDEV() {
+  {
+    {
+      var owner = currentOwnerInDEV;
+
+      if (owner === null) {
+        return '';
+      }
+
+      return getOwnerStackByComponentInfoInDev(owner);
+    } // We don't have Parent Stacks in Flight.
+  }
+}
+
+var replayConsoleWithCallStack = {
+  'react-stack-bottom-frame': function (response, methodName, stackTrace, owner, env, args) {
+    // There really shouldn't be anything else on the stack atm.
+    var prevStack = ReactSharedInternals.getCurrentStack;
+    ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
+    currentOwnerInDEV = owner === null ? response._debugRootOwner : owner;
+
+    try {
+      var callStack = buildFakeCallStack(response, stackTrace, env, bindToConsole(methodName, args, env));
+
+      if (owner != null) {
+        var task = initializeFakeTask(response, owner, env);
+        initializeFakeStack(response, owner);
+
+        if (task !== null) {
+          task.run(callStack);
+          return;
+        }
+      }
+
+      var rootTask = getRootTask(response, env);
+
+      if (rootTask != null) {
+        rootTask.run(callStack);
+        return;
+      }
+
+      callStack();
+    } finally {
+      currentOwnerInDEV = null;
+      ReactSharedInternals.getCurrentStack = prevStack;
+    }
+  }
+};
+var replayConsoleWithCallStackInDEV = // We use this technique to trick minifiers to preserve the function name.
+replayConsoleWithCallStack['react-stack-bottom-frame'].bind(replayConsoleWithCallStack) ;
+
+function resolveConsoleEntry(response, value) {
+
+  if (!response._replayConsole) {
+    return;
+  }
+
+  var payload = parseModel(response, value);
+  var methodName = payload[0];
+  var stackTrace = payload[1];
+  var owner = payload[2];
+  var env = payload[3];
+  var args = payload.slice(4);
+  replayConsoleWithCallStackInDEV(response, methodName, stackTrace, owner, env, args);
+}
+
+function mergeBuffer(buffer, lastChunk) {
+  var l = buffer.length; // Count the bytes we'll need
+
+  var byteLength = lastChunk.length;
+
+  for (var i = 0; i < l; i++) {
+    byteLength += buffer[i].byteLength;
+  } // Allocate enough contiguous space
+
+
+  var result = new Uint8Array(byteLength);
+  var offset = 0; // Copy all the buffers into it.
+
+  for (var _i2 = 0; _i2 < l; _i2++) {
+    var chunk = buffer[_i2];
+    result.set(chunk, offset);
+    offset += chunk.byteLength;
+  }
+
+  result.set(lastChunk, offset);
+  return result;
+}
+
+function resolveTypedArray(response, id, buffer, lastChunk, constructor, bytesPerElement) {
+  // If the view fits into one original buffer, we just reuse that buffer instead of
+  // copying it out to a separate copy. This means that it's not always possible to
+  // transfer these values to other threads without copying first since they may
+  // share array buffer. For this to work, it must also have bytes aligned to a
+  // multiple of a size of the type.
+  var chunk = buffer.length === 0 && lastChunk.byteOffset % bytesPerElement === 0 ? lastChunk : mergeBuffer(buffer, lastChunk); // TODO: The transfer protocol of RSC is little-endian. If the client isn't little-endian
+  // we should convert it instead. In practice big endian isn't really Web compatible so it's
+  // somewhat safe to assume that browsers aren't going to run it, but maybe there's some SSR
+  // server that's affected.
+
+  var view = new constructor(chunk.buffer, chunk.byteOffset, chunk.byteLength / bytesPerElement);
+  resolveBuffer(response, id, view);
+}
+
+function flushComponentPerformance(response, root, trackIdx, // Next available track
+trackTime, // The time after which it is available,
+parentEndTime) {
+  // This must be done at the end to collect the end time from the whole tree.
+
+
+  if (!isArray(root._children)) {
+    // We have already written this chunk. If this was a cycle, then this will
+    // be -Infinity and it won't contribute to the parent end time.
+    // If this was already emitted by another sibling then we reused the same
+    // chunk in two places. We should extend the current end time as if it was
+    // rendered as part of this tree.
+    var previousResult = root._children;
+    var previousEndTime = previousResult.endTime;
+
+    if (parentEndTime > -Infinity && parentEndTime < previousEndTime && previousResult.component !== null) {
+      // Log a placeholder for the deduped value under this child starting
+      // from the end of the self time of the parent and spanning until the
+      // the deduped end.
+      logDedupedComponentRender(previousResult.component, trackIdx, parentEndTime, previousEndTime);
+    } // Since we didn't bump the track this time, we just return the same track.
+
+
+    previousResult.track = trackIdx;
+    return previousResult;
+  }
+
+  var children = root._children;
+
+  if (root.status === RESOLVED_MODEL) {
+    // If the model is not initialized by now, do that now so we can find its
+    // children. This part is a little sketchy since it significantly changes
+    // the performance characteristics of the app by profiling.
+    initializeModelChunk(root);
+  } // First find the start time of the first component to know if it was running
+  // in parallel with the previous.
+
+
+  var debugInfo = root._debugInfo;
+
+  if (debugInfo) {
+    for (var i = 1; i < debugInfo.length; i++) {
+      var info = debugInfo[i];
+
+      if (typeof info.name === 'string') {
+        // $FlowFixMe: Refined.
+        var startTimeInfo = debugInfo[i - 1];
+
+        if (typeof startTimeInfo.time === 'number') {
+          var startTime = startTimeInfo.time;
+
+          if (startTime < trackTime) {
+            // The start time of this component is before the end time of the previous
+            // component on this track so we need to bump the next one to a parallel track.
+            trackIdx++;
+          }
+
+          trackTime = startTime;
+          break;
+        }
+      }
+    }
+
+    for (var _i3 = debugInfo.length - 1; _i3 >= 0; _i3--) {
+      var _info = debugInfo[_i3];
+
+      if (typeof _info.time === 'number') {
+        if (_info.time > parentEndTime) {
+          parentEndTime = _info.time;
+        }
+      }
+    }
+  }
+
+  var result = {
+    track: trackIdx,
+    endTime: -Infinity,
+    component: null
+  };
+  root._children = result;
+  var childrenEndTime = -Infinity;
+  var childTrackIdx = trackIdx;
+  var childTrackTime = trackTime;
+
+  for (var _i4 = 0; _i4 < children.length; _i4++) {
+    var childResult = flushComponentPerformance(response, children[_i4], childTrackIdx, childTrackTime, parentEndTime);
+
+    if (childResult.component !== null) {
+      result.component = childResult.component;
+    }
+
+    childTrackIdx = childResult.track;
+    var childEndTime = childResult.endTime;
+    childTrackTime = childEndTime;
+
+    if (childEndTime > childrenEndTime) {
+      childrenEndTime = childEndTime;
+    }
+  }
+
+  if (debugInfo) {
+    var endTime = 0;
+    var isLastComponent = true;
+
+    for (var _i5 = debugInfo.length - 1; _i5 >= 0; _i5--) {
+      var _info2 = debugInfo[_i5];
+
+      if (typeof _info2.time === 'number') {
+        endTime = _info2.time;
+
+        if (endTime > childrenEndTime) {
+          childrenEndTime = endTime;
+        }
+      }
+
+      if (typeof _info2.name === 'string' && _i5 > 0) {
+        // $FlowFixMe: Refined.
+        var componentInfo = _info2;
+        var _startTimeInfo = debugInfo[_i5 - 1];
+
+        if (typeof _startTimeInfo.time === 'number') {
+          var _startTime = _startTimeInfo.time;
+
+          if (isLastComponent && root.status === ERRORED && root.reason !== response._closedReason) {
+            // If this is the last component to render before this chunk rejected, then conceptually
+            // this component errored. If this was a cancellation then it wasn't this component that
+            // errored.
+            logComponentErrored(componentInfo, trackIdx, _startTime, endTime, childrenEndTime, response._rootEnvironmentName, root.reason);
+          } else {
+            logComponentRender(componentInfo, trackIdx, _startTime, endTime, childrenEndTime, response._rootEnvironmentName);
+          } // Track the root most component of the result for deduping logging.
+
+
+          result.component = componentInfo;
+        }
+
+        isLastComponent = false;
+      }
+    }
+  }
+
+  result.endTime = childrenEndTime;
+  return result;
+}
+
+function processFullBinaryRow(response, id, tag, buffer, chunk) {
+  switch (tag) {
+    case 65
+    /* "A" */
+    :
+      // We must always clone to extract it into a separate buffer instead of just a view.
+      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+      return;
+
+    case 79
+    /* "O" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+      return;
+
+    case 111
+    /* "o" */
+    :
+      resolveBuffer(response, id, buffer.length === 0 ? chunk : mergeBuffer(buffer, chunk));
+      return;
+
+    case 85
+    /* "U" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+      return;
+
+    case 83
+    /* "S" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+      return;
+
+    case 115
+    /* "s" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+      return;
+
+    case 76
+    /* "L" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+      return;
+
+    case 108
+    /* "l" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+      return;
+
+    case 71
+    /* "G" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+      return;
+
+    case 103
+    /* "g" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+      return;
+
+    case 77
+    /* "M" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+      return;
+
+    case 109
+    /* "m" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+      return;
+
+    case 86
+    /* "V" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+      return;
+  }
+
+  var stringDecoder = response._stringDecoder;
+  var row = '';
+
+  for (var i = 0; i < buffer.length; i++) {
+    row += readPartialStringChunk(stringDecoder, buffer[i]);
+  }
+
+  row += readFinalStringChunk(stringDecoder, chunk);
+  processFullStringRow(response, id, tag, row);
+}
+
+function processFullStringRow(response, id, tag, row) {
+  switch (tag) {
+    case 73
+    /* "I" */
+    :
+      {
+        resolveModule(response, id, row);
+        return;
+      }
+
+    case 72
+    /* "H" */
+    :
+      {
+        var code = row[0];
+        resolveHint(response, code, row.slice(1));
+        return;
+      }
+
+    case 69
+    /* "E" */
+    :
+      {
+        var errorInfo = JSON.parse(row);
+        var error;
+
+        {
+          error = resolveErrorDev(response, errorInfo);
+        }
+
+        error.digest = errorInfo.digest;
+        var errorWithDigest = error;
+        var chunks = response._chunks;
+        var chunk = chunks.get(id);
+
+        if (!chunk) {
+          chunks.set(id, createErrorChunk(response, errorWithDigest));
+        } else {
+          triggerErrorOnChunk(chunk, errorWithDigest);
+        }
+
+        return;
+      }
+
+    case 84
+    /* "T" */
+    :
+      {
+        resolveText(response, id, row);
+        return;
+      }
+
+    case 78
+    /* "N" */
+    :
+      {
+        {
+          // Track the time origin for future debug info. We track it relative
+          // to the current environment's time space.
+          var timeOrigin = +row;
+          response._timeOrigin = timeOrigin - // $FlowFixMe[prop-missing]
+          performance.timeOrigin;
+          return;
+        } // Fallthrough to share the error with Debug and Console entries.
+
+      }
+
+    case 68
+    /* "D" */
+    :
+      {
+        {
+          var _chunk4 = createResolvedModelChunk(response, row);
+
+          initializeModelChunk(_chunk4);
+          var initializedChunk = _chunk4;
+
+          if (initializedChunk.status === INITIALIZED) {
+            resolveDebugInfo(response, id, initializedChunk.value);
+          } else {
+            // TODO: This is not going to resolve in the right order if there's more than one.
+            _chunk4.then(function (v) {
+              return resolveDebugInfo(response, id, v);
+            }, function (e) {// Ignore debug info errors for now. Unnecessary noise.
+            });
+          }
+
+          return;
+        } // Fallthrough to share the error with Console entries.
+
+      }
+
+    case 87
+    /* "W" */
+    :
+      {
+        {
+          resolveConsoleEntry(response, row);
+          return;
+        }
+      }
+
+    case 82
+    /* "R" */
+    :
+      {
+        startReadableStream(response, id, undefined);
+        return;
+      }
+    // Fallthrough
+
+    case 114
+    /* "r" */
+    :
+      {
+        startReadableStream(response, id, 'bytes');
+        return;
+      }
+    // Fallthrough
+
+    case 88
+    /* "X" */
+    :
+      {
+        startAsyncIterable(response, id, false);
+        return;
+      }
+    // Fallthrough
+
+    case 120
+    /* "x" */
+    :
+      {
+        startAsyncIterable(response, id, true);
+        return;
+      }
+    // Fallthrough
+
+    case 67
+    /* "C" */
+    :
+      {
+        stopStream(response, id, row);
+        return;
+      }
+    // Fallthrough
+
+    case 80
+    /* "P" */
+    :
+      {
+        {
+          {
+            var postponeInfo = JSON.parse(row);
+            resolvePostponeDev(response, id, postponeInfo.reason, postponeInfo.stack, postponeInfo.env);
+          }
+
+          return;
+        }
+      }
+    // Fallthrough
+
+    default:
+      /* """ "{" "[" "t" "f" "n" "0" - "9" */
+      {
+        // We assume anything else is JSON.
+        resolveModel(response, id, row);
+        return;
+      }
+  }
+}
+
+function processBinaryChunk(response, chunk) {
+  var i = 0;
+  var rowState = response._rowState;
+  var rowID = response._rowID;
+  var rowTag = response._rowTag;
+  var rowLength = response._rowLength;
+  var buffer = response._buffer;
+  var chunkLength = chunk.length;
+
+  while (i < chunkLength) {
+    var lastIdx = -1;
+
+    switch (rowState) {
+      case ROW_ID:
+        {
+          var byte = chunk[i++];
+
+          if (byte === 58
+          /* ":" */
+          ) {
+              // Finished the rowID, next we'll parse the tag.
+              rowState = ROW_TAG;
+            } else {
+            rowID = rowID << 4 | (byte > 96 ? byte - 87 : byte - 48);
+          }
+
+          continue;
+        }
+
+      case ROW_TAG:
+        {
+          var resolvedRowTag = chunk[i];
+
+          if (resolvedRowTag === 84
+          /* "T" */
+          || resolvedRowTag === 65
+          /* "A" */
+          || resolvedRowTag === 79
+          /* "O" */
+          || resolvedRowTag === 111
+          /* "o" */
+          || resolvedRowTag === 85
+          /* "U" */
+          || resolvedRowTag === 83
+          /* "S" */
+          || resolvedRowTag === 115
+          /* "s" */
+          || resolvedRowTag === 76
+          /* "L" */
+          || resolvedRowTag === 108
+          /* "l" */
+          || resolvedRowTag === 71
+          /* "G" */
+          || resolvedRowTag === 103
+          /* "g" */
+          || resolvedRowTag === 77
+          /* "M" */
+          || resolvedRowTag === 109
+          /* "m" */
+          || resolvedRowTag === 86
+          /* "V" */
+          ) {
+              rowTag = resolvedRowTag;
+              rowState = ROW_LENGTH;
+              i++;
+            } else if (resolvedRowTag > 64 && resolvedRowTag < 91 ||
+          /* "A"-"Z" */
+          resolvedRowTag === 35
+          /* "#" */
+          || resolvedRowTag === 114
+          /* "r" */
+          || resolvedRowTag === 120
+          /* "x" */
+          ) {
+              rowTag = resolvedRowTag;
+              rowState = ROW_CHUNK_BY_NEWLINE;
+              i++;
+            } else {
+            rowTag = 0;
+            rowState = ROW_CHUNK_BY_NEWLINE; // This was an unknown tag so it was probably part of the data.
+          }
+
+          continue;
+        }
+
+      case ROW_LENGTH:
+        {
+          var _byte = chunk[i++];
+
+          if (_byte === 44
+          /* "," */
+          ) {
+              // Finished the rowLength, next we'll buffer up to that length.
+              rowState = ROW_CHUNK_BY_LENGTH;
+            } else {
+            rowLength = rowLength << 4 | (_byte > 96 ? _byte - 87 : _byte - 48);
+          }
+
+          continue;
+        }
+
+      case ROW_CHUNK_BY_NEWLINE:
+        {
+          // We're looking for a newline
+          lastIdx = chunk.indexOf(10
+          /* "\n" */
+          , i);
+          break;
+        }
+
+      case ROW_CHUNK_BY_LENGTH:
+        {
+          // We're looking for the remaining byte length
+          lastIdx = i + rowLength;
+
+          if (lastIdx > chunk.length) {
+            lastIdx = -1;
+          }
+
+          break;
+        }
+    }
+
+    var offset = chunk.byteOffset + i;
+
+    if (lastIdx > -1) {
+      // We found the last chunk of the row
+      var length = lastIdx - i;
+      var lastChunk = new Uint8Array(chunk.buffer, offset, length);
+      processFullBinaryRow(response, rowID, rowTag, buffer, lastChunk); // Reset state machine for a new row
+
+      i = lastIdx;
+
+      if (rowState === ROW_CHUNK_BY_NEWLINE) {
+        // If we're trailing by a newline we need to skip it.
+        i++;
+      }
+
+      rowState = ROW_ID;
+      rowTag = 0;
+      rowID = 0;
+      rowLength = 0;
+      buffer.length = 0;
+    } else {
+      // The rest of this row is in a future chunk. We stash the rest of the
+      // current chunk until we can process the full row.
+      var _length = chunk.byteLength - i;
+
+      var remainingSlice = new Uint8Array(chunk.buffer, offset, _length);
+      buffer.push(remainingSlice); // Update how many bytes we're still waiting for. If we're looking for
+      // a newline, this doesn't hurt since we'll just ignore it.
+
+      rowLength -= remainingSlice.byteLength;
+      break;
+    }
+  }
+
+  response._rowState = rowState;
+  response._rowID = rowID;
+  response._rowTag = rowTag;
+  response._rowLength = rowLength;
+}
+
+function parseModel(response, json) {
+  return JSON.parse(json, response._fromJSON);
+}
+
+function createFromJSONCallback(response) {
+  // $FlowFixMe[missing-this-annot]
+  return function (key, value) {
+    if (typeof value === 'string') {
+      // We can't use .bind here because we need the "this" value.
+      return parseModelString(response, this, key, value);
+    }
+
+    if (typeof value === 'object' && value !== null) {
+      return parseModelTuple(response, value);
+    }
+
+    return value;
+  };
+}
+
+function close(response) {
+  // In case there are any remaining unresolved chunks, they won't
+  // be resolved now. So we need to issue an error to those.
+  // Ideally we should be able to early bail out if we kept a
+  // ref count of pending chunks.
+  reportGlobalError(response, new Error('Connection closed.'));
+}
+
+function getCurrentOwnerInDEV() {
+  return currentOwnerInDEV;
+}
+
+function injectIntoDevTools() {
+  var internals = {
+    bundleType: 1 ,
+    // Might add PROFILE later.
+    version: ReactVersion,
+    rendererPackageName: rendererPackageName,
+    currentDispatcherRef: ReactSharedInternals,
+    // Enables DevTools to detect reconciler version rather than renderer version
+    // which may not match for third party renderers.
+    reconcilerVersion: ReactVersion,
+    getCurrentComponentInfo: getCurrentOwnerInDEV
+  };
+  return injectInternals(internals);
+}
+
+function createResponseFromOptions(options) {
+  return createResponse(options && options.moduleBaseURL ? options.moduleBaseURL : '', null, null, options && options.callServer ? options.callServer : undefined, undefined, // encodeFormAction
+  undefined, // nonce
+  options && options.temporaryReferences ? options.temporaryReferences : undefined, options && options.findSourceMapURL ? options.findSourceMapURL : undefined, options ? options.replayConsoleLogs !== false : true , // defaults to true
+  options && options.environmentName ? options.environmentName : undefined);
+}
+
+function startReadingFromStream(response, stream) {
+  var reader = stream.getReader();
+
+  function progress(_ref) {
+    var done = _ref.done,
+        value = _ref.value;
+
+    if (done) {
+      close(response);
+      return;
+    }
+
+    var buffer = value;
+    processBinaryChunk(response, buffer);
+    return reader.read().then(progress).catch(error);
+  }
+
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+
+  reader.read().then(progress).catch(error);
+}
+
+function createFromReadableStream(stream, options) {
+  var response = createResponseFromOptions(options);
+  startReadingFromStream(response, stream);
+  return getRoot(response);
+}
+
+function createFromFetch(promiseForResponse, options) {
+  var response = createResponseFromOptions(options);
+  promiseForResponse.then(function (r) {
+    startReadingFromStream(response, r.body);
+  }, function (e) {
+    reportGlobalError(response, e);
+  });
+  return getRoot(response);
+}
+
+function encodeReply(value, options)
+/* We don't use URLSearchParams yet but maybe */
+{
+  return new Promise(function (resolve, reject) {
+    var abort = processReply(value, '', options && options.temporaryReferences ? options.temporaryReferences : undefined, resolve, reject);
+
+    if (options && options.signal) {
+      var signal = options.signal;
+
+      if (signal.aborted) {
+        abort(signal.reason);
+      } else {
+        var listener = function () {
+          abort(signal.reason);
+          signal.removeEventListener('abort', listener);
+        };
+
+        signal.addEventListener('abort', listener);
+      }
+    }
+  });
+}
+
+{
+  injectIntoDevTools();
+}
+
+export { createFromFetch, createFromReadableStream, createServerReference, createTemporaryReferenceSet, encodeReply };
diff --git a/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.production.js b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.production.js
new file mode 100644
index 0000000..b4ded23
--- /dev/null
+++ b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-client.browser.production.js
@@ -0,0 +1,2882 @@
+/**
+* @license React
+ * react-server-dom-esm-client.browser.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import * as ReactDOM from 'react-dom';
+
+function createStringDecoder() {
+  return new TextDecoder();
+}
+const decoderOptions = {
+  stream: true
+};
+function readPartialStringChunk(decoder, buffer) {
+  return decoder.decode(buffer, decoderOptions);
+}
+function readFinalStringChunk(decoder, buffer) {
+  return decoder.decode(buffer);
+}
+
+// Module root path
+// Module root path
+function resolveClientReference(bundlerConfig, metadata) {
+  const baseURL = bundlerConfig;
+  return {
+    specifier: baseURL + metadata[0],
+    name: metadata[1]
+  };
+}
+function resolveServerReference(config, id) {
+  const baseURL = config;
+  const idx = id.lastIndexOf('#');
+  const exportName = id.slice(idx + 1);
+  const fullURL = id.slice(0, idx);
+
+  if (!fullURL.startsWith(baseURL)) {
+    throw new Error('Attempted to load a Server Reference outside the hosted root.');
+  }
+
+  return {
+    specifier: fullURL,
+    name: exportName
+  };
+}
+const asyncModuleCache = new Map();
+function preloadModule(metadata) {
+  const existingPromise = asyncModuleCache.get(metadata.specifier);
+
+  if (existingPromise) {
+    if (existingPromise.status === 'fulfilled') {
+      return null;
+    }
+
+    return existingPromise;
+  } else {
+    // $FlowFixMe[unsupported-syntax]
+    const modulePromise = import(metadata.specifier);
+    modulePromise.then(value => {
+      const fulfilledThenable = modulePromise;
+      fulfilledThenable.status = 'fulfilled';
+      fulfilledThenable.value = value;
+    }, reason => {
+      const rejectedThenable = modulePromise;
+      rejectedThenable.status = 'rejected';
+      rejectedThenable.reason = reason;
+    });
+    asyncModuleCache.set(metadata.specifier, modulePromise);
+    return modulePromise;
+  }
+}
+function requireModule(metadata) {
+  let moduleExports; // We assume that preloadModule has been called before, which
+  // should have added something to the module cache.
+
+  const promise = asyncModuleCache.get(metadata.specifier);
+
+  if (promise.status === 'fulfilled') {
+    moduleExports = promise.value;
+  } else {
+    throw promise.reason;
+  }
+
+  return moduleExports[metadata.name];
+}
+
+const ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+// This client file is in the shared folder because it applies to both SSR and browser contexts.
+// It is the configuration of the FlightClient behavior which can run in either environment.
+function dispatchHint(code, model) {
+  const dispatcher = ReactDOMSharedInternals.d;
+  /* ReactDOMCurrentDispatcher */
+
+  switch (code) {
+    case 'D':
+      {
+        const refined = refineModel(code, model);
+        const href = refined;
+        dispatcher.D(
+        /* prefetchDNS */
+        href);
+        return;
+      }
+
+    case 'C':
+      {
+        const refined = refineModel(code, model);
+
+        if (typeof refined === 'string') {
+          const href = refined;
+          dispatcher.C(
+          /* preconnect */
+          href);
+        } else {
+          const href = refined[0];
+          const crossOrigin = refined[1];
+          dispatcher.C(
+          /* preconnect */
+          href, crossOrigin);
+        }
+
+        return;
+      }
+
+    case 'L':
+      {
+        const refined = refineModel(code, model);
+        const href = refined[0];
+        const as = refined[1];
+
+        if (refined.length === 3) {
+          const options = refined[2];
+          dispatcher.L(
+          /* preload */
+          href, as, options);
+        } else {
+          dispatcher.L(
+          /* preload */
+          href, as);
+        }
+
+        return;
+      }
+
+    case 'm':
+      {
+        const refined = refineModel(code, model);
+
+        if (typeof refined === 'string') {
+          const href = refined;
+          dispatcher.m(
+          /* preloadModule */
+          href);
+        } else {
+          const href = refined[0];
+          const options = refined[1];
+          dispatcher.m(
+          /* preloadModule */
+          href, options);
+        }
+
+        return;
+      }
+
+    case 'X':
+      {
+        const refined = refineModel(code, model);
+
+        if (typeof refined === 'string') {
+          const href = refined;
+          dispatcher.X(
+          /* preinitScript */
+          href);
+        } else {
+          const href = refined[0];
+          const options = refined[1];
+          dispatcher.X(
+          /* preinitScript */
+          href, options);
+        }
+
+        return;
+      }
+
+    case 'S':
+      {
+        const refined = refineModel(code, model);
+
+        if (typeof refined === 'string') {
+          const href = refined;
+          dispatcher.S(
+          /* preinitStyle */
+          href);
+        } else {
+          const href = refined[0];
+          const precedence = refined[1] === 0 ? undefined : refined[1];
+          const options = refined.length === 3 ? refined[2] : undefined;
+          dispatcher.S(
+          /* preinitStyle */
+          href, precedence, options);
+        }
+
+        return;
+      }
+
+    case 'M':
+      {
+        const refined = refineModel(code, model);
+
+        if (typeof refined === 'string') {
+          const href = refined;
+          dispatcher.M(
+          /* preinitModuleScript */
+          href);
+        } else {
+          const href = refined[0];
+          const options = refined[1];
+          dispatcher.M(
+          /* preinitModuleScript */
+          href, options);
+        }
+
+        return;
+      }
+  }
+} // Flow is having trouble refining the HintModels so we help it a bit.
+// This should be compiled out in the production build.
+
+function refineModel(code, model) {
+  return model;
+}
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_LAZY_TYPE = Symbol.for('react.lazy');
+const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+const MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+const FAUX_ITERATOR_SYMBOL = '@@iterator';
+function getIteratorFn(maybeIterable) {
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+
+  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+
+  return null;
+}
+const ASYNC_ITERATOR = Symbol.asyncIterator;
+
+const isArrayImpl = Array.isArray;
+
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+const getPrototypeOf = Object.getPrototypeOf;
+
+function createTemporaryReferenceSet() {
+  return new Map();
+}
+function writeTemporaryReference(set, reference, object) {
+  set.set(reference, object);
+}
+function readTemporaryReference(set, reference) {
+  return set.get(reference);
+}
+
+const ObjectPrototype = Object.prototype;
+const knownServerReferences = new WeakMap(); // Serializable values
+// Thenable<ReactServerValue>
+
+function serializeByValueID(id) {
+  return '$' + id.toString(16);
+}
+
+function serializePromiseID(id) {
+  return '$@' + id.toString(16);
+}
+
+function serializeServerReferenceID(id) {
+  return '$F' + id.toString(16);
+}
+
+function serializeTemporaryReferenceMarker() {
+  return '$T';
+}
+
+function serializeFormDataReference(id) {
+  // Why K? F is "Function". D is "Date". What else?
+  return '$K' + id.toString(16);
+}
+
+function serializeNumber(number) {
+  if (Number.isFinite(number)) {
+    if (number === 0 && 1 / number === -Infinity) {
+      return '$-0';
+    } else {
+      return number;
+    }
+  } else {
+    if (number === Infinity) {
+      return '$Infinity';
+    } else if (number === -Infinity) {
+      return '$-Infinity';
+    } else {
+      return '$NaN';
+    }
+  }
+}
+
+function serializeUndefined() {
+  return '$undefined';
+}
+
+function serializeDateFromDateJSON(dateJSON) {
+  // JSON.stringify automatically calls Date.prototype.toJSON which calls toISOString.
+  // We need only tack on a $D prefix.
+  return '$D' + dateJSON;
+}
+
+function serializeBigInt(n) {
+  return '$n' + n.toString(10);
+}
+
+function serializeMapID(id) {
+  return '$Q' + id.toString(16);
+}
+
+function serializeSetID(id) {
+  return '$W' + id.toString(16);
+}
+
+function serializeBlobID(id) {
+  return '$B' + id.toString(16);
+}
+
+function serializeIteratorID(id) {
+  return '$i' + id.toString(16);
+}
+
+function escapeStringValue(value) {
+  if (value[0] === '$') {
+    // We need to escape $ prefixed strings since we use those to encode
+    // references to IDs and as special symbol values.
+    return '$' + value;
+  } else {
+    return value;
+  }
+}
+
+function processReply(root, formFieldPrefix, temporaryReferences, resolve, reject) {
+  let nextPartId = 1;
+  let pendingParts = 0;
+  let formData = null;
+  const writtenObjects = new WeakMap();
+  let modelRoot = root;
+
+  function serializeTypedArray(tag, typedArray) {
+    const blob = new Blob([// We should be able to pass the buffer straight through but Node < 18 treat
+    // multi-byte array blobs differently so we first convert it to single-byte.
+    new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)]);
+    const blobId = nextPartId++;
+
+    if (formData === null) {
+      formData = new FormData();
+    }
+
+    formData.append(formFieldPrefix + blobId, blob);
+    return '$' + tag + blobId.toString(16);
+  }
+
+  function serializeBinaryReader(reader) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    const data = formData;
+    pendingParts++;
+    const streamId = nextPartId++;
+    const buffer = [];
+
+    function progress(entry) {
+      if (entry.done) {
+        const blobId = nextPartId++;
+        data.append(formFieldPrefix + blobId, new Blob(buffer));
+        data.append(formFieldPrefix + streamId, '"$o' + blobId.toString(16) + '"');
+        data.append(formFieldPrefix + streamId, 'C'); // Close signal
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        buffer.push(entry.value);
+        reader.read(new Uint8Array(1024)).then(progress, reject);
+      }
+    }
+
+    reader.read(new Uint8Array(1024)).then(progress, reject);
+    return '$r' + streamId.toString(16);
+  }
+
+  function serializeReader(reader) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    const data = formData;
+    pendingParts++;
+    const streamId = nextPartId++;
+
+    function progress(entry) {
+      if (entry.done) {
+        data.append(formFieldPrefix + streamId, 'C'); // Close signal
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        try {
+          // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+          const partJSON = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON);
+          reader.read().then(progress, reject);
+        } catch (x) {
+          reject(x);
+        }
+      }
+    }
+
+    reader.read().then(progress, reject);
+    return '$R' + streamId.toString(16);
+  }
+
+  function serializeReadableStream(stream) {
+    // Detect if this is a BYOB stream. BYOB streams should be able to be read as bytes on the
+    // receiving side. For binary streams, we serialize them as plain Blobs.
+    let binaryReader;
+
+    try {
+      // $FlowFixMe[extra-arg]: This argument is accepted.
+      binaryReader = stream.getReader({
+        mode: 'byob'
+      });
+    } catch (x) {
+      return serializeReader(stream.getReader());
+    }
+
+    return serializeBinaryReader(binaryReader);
+  }
+
+  function serializeAsyncIterable(iterable, iterator) {
+    if (formData === null) {
+      // Upgrade to use FormData to allow us to stream this value.
+      formData = new FormData();
+    }
+
+    const data = formData;
+    pendingParts++;
+    const streamId = nextPartId++; // Generators/Iterators are Iterables but they're also their own iterator
+    // functions. If that's the case, we treat them as single-shot. Otherwise,
+    // we assume that this iterable might be a multi-shot and allow it to be
+    // iterated more than once on the receiving server.
+
+    const isIterator = iterable === iterator; // There's a race condition between when the stream is aborted and when the promise
+    // resolves so we track whether we already aborted it to avoid writing twice.
+
+    function progress(entry) {
+      if (entry.done) {
+        if (entry.value === undefined) {
+          data.append(formFieldPrefix + streamId, 'C'); // Close signal
+        } else {
+          // Unlike streams, the last value may not be undefined. If it's not
+          // we outline it and encode a reference to it in the closing instruction.
+          try {
+            // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+            const partJSON = JSON.stringify(entry.value, resolveToJSON);
+            data.append(formFieldPrefix + streamId, 'C' + partJSON); // Close signal
+          } catch (x) {
+            reject(x);
+            return;
+          }
+        }
+
+        pendingParts--;
+
+        if (pendingParts === 0) {
+          resolve(data);
+        }
+      } else {
+        try {
+          // $FlowFixMe[incompatible-type]: While plain JSON can return undefined we never do here.
+          const partJSON = JSON.stringify(entry.value, resolveToJSON);
+          data.append(formFieldPrefix + streamId, partJSON);
+          iterator.next().then(progress, reject);
+        } catch (x) {
+          reject(x);
+          return;
+        }
+      }
+    }
+
+    iterator.next().then(progress, reject);
+    return '$' + (isIterator ? 'x' : 'X') + streamId.toString(16);
+  }
+
+  function resolveToJSON(key, value) {
+    const parent = this; // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us
+
+    if (value === null) {
+      return null;
+    }
+
+    if (typeof value === 'object') {
+      switch (value.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          {
+            if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+              // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+              const parentReference = writtenObjects.get(parent);
+
+              if (parentReference !== undefined) {
+                // If the parent has a reference, we can refer to this object indirectly
+                // through the property name inside that parent.
+                const reference = parentReference + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+                writeTemporaryReference(temporaryReferences, reference, value);
+                return serializeTemporaryReferenceMarker();
+              }
+            }
+
+            throw new Error('React Element cannot be passed to Server Functions from the Client without a ' + 'temporary reference set. Pass a TemporaryReferenceSet to the options.' + (''));
+          }
+
+        case REACT_LAZY_TYPE:
+          {
+            // Resolve lazy as if it wasn't here. In the future this will be encoded as a Promise.
+            const lazy = value;
+            const payload = lazy._payload;
+            const init = lazy._init;
+
+            if (formData === null) {
+              // Upgrade to use FormData to allow us to stream this value.
+              formData = new FormData();
+            }
+
+            pendingParts++;
+
+            try {
+              const resolvedModel = init(payload); // We always outline this as a separate part even though we could inline it
+              // because it ensures a more deterministic encoding.
+
+              const lazyId = nextPartId++;
+              const partJSON = serializeModel(resolvedModel, lazyId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+              const data = formData;
+              data.append(formFieldPrefix + lazyId, partJSON);
+              return serializeByValueID(lazyId);
+            } catch (x) {
+              if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
+                // Suspended
+                pendingParts++;
+                const lazyId = nextPartId++;
+                const thenable = x;
+
+                const retry = function () {
+                  // While the first promise resolved, its value isn't necessarily what we'll
+                  // resolve into because we might suspend again.
+                  try {
+                    const partJSON = serializeModel(value, lazyId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+                    const data = formData;
+                    data.append(formFieldPrefix + lazyId, partJSON);
+                    pendingParts--;
+
+                    if (pendingParts === 0) {
+                      resolve(data);
+                    }
+                  } catch (reason) {
+                    reject(reason);
+                  }
+                };
+
+                thenable.then(retry, retry);
+                return serializeByValueID(lazyId);
+              } else {
+                // In the future we could consider serializing this as an error
+                // that throws on the server instead.
+                reject(x);
+                return null;
+              }
+            } finally {
+              pendingParts--;
+            }
+          }
+      } // $FlowFixMe[method-unbinding]
+
+
+      if (typeof value.then === 'function') {
+        // We assume that any object with a .then property is a "Thenable" type,
+        // or a Promise type. Either of which can be represented by a Promise.
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to stream this value.
+          formData = new FormData();
+        }
+
+        pendingParts++;
+        const promiseId = nextPartId++;
+        const thenable = value;
+        thenable.then(partValue => {
+          try {
+            const partJSON = serializeModel(partValue, promiseId); // $FlowFixMe[incompatible-type] We know it's not null because we assigned it above.
+
+            const data = formData;
+            data.append(formFieldPrefix + promiseId, partJSON);
+            pendingParts--;
+
+            if (pendingParts === 0) {
+              resolve(data);
+            }
+          } catch (reason) {
+            reject(reason);
+          }
+        }, // In the future we could consider serializing this as an error
+        // that throws on the server instead.
+        reject);
+        return serializePromiseID(promiseId);
+      }
+
+      const existingReference = writtenObjects.get(value);
+
+      if (existingReference !== undefined) {
+        if (modelRoot === value) {
+          // This is the ID we're currently emitting so we need to write it
+          // once but if we discover it again, we refer to it by id.
+          modelRoot = null;
+        } else {
+          // We've already emitted this as an outlined object, so we can
+          // just refer to that by its existing ID.
+          return existingReference;
+        }
+      } else if (key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        const parentReference = writtenObjects.get(parent);
+
+        if (parentReference !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          const reference = parentReference + ':' + key;
+          writtenObjects.set(value, reference);
+
+          if (temporaryReferences !== undefined) {
+            // Store this object so that the server can refer to it later in responses.
+            writeTemporaryReference(temporaryReferences, reference, value);
+          }
+        }
+      }
+
+      if (isArray(value)) {
+        // $FlowFixMe[incompatible-return]
+        return value;
+      } // TODO: Should we the Object.prototype.toString.call() to test for cross-realm objects?
+
+
+      if (value instanceof FormData) {
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to use rich objects as its values.
+          formData = new FormData();
+        }
+
+        const data = formData;
+        const refId = nextPartId++; // Copy all the form fields with a prefix for this reference.
+        // These must come first in the form order because we assume that all the
+        // fields are available before this is referenced.
+
+        const prefix = formFieldPrefix + refId + '_'; // $FlowFixMe[prop-missing]: FormData has forEach.
+
+        value.forEach((originalValue, originalKey) => {
+          // $FlowFixMe[incompatible-call]
+          data.append(prefix + originalKey, originalValue);
+        });
+        return serializeFormDataReference(refId);
+      }
+
+      if (value instanceof Map) {
+        const mapId = nextPartId++;
+        const partJSON = serializeModel(Array.from(value), mapId);
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + mapId, partJSON);
+        return serializeMapID(mapId);
+      }
+
+      if (value instanceof Set) {
+        const setId = nextPartId++;
+        const partJSON = serializeModel(Array.from(value), setId);
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + setId, partJSON);
+        return serializeSetID(setId);
+      }
+
+      if (value instanceof ArrayBuffer) {
+        const blob = new Blob([value]);
+        const blobId = nextPartId++;
+
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        formData.append(formFieldPrefix + blobId, blob);
+        return '$' + 'A' + blobId.toString(16);
+      }
+
+      if (value instanceof Int8Array) {
+        // char
+        return serializeTypedArray('O', value);
+      }
+
+      if (value instanceof Uint8Array) {
+        // unsigned char
+        return serializeTypedArray('o', value);
+      }
+
+      if (value instanceof Uint8ClampedArray) {
+        // unsigned clamped char
+        return serializeTypedArray('U', value);
+      }
+
+      if (value instanceof Int16Array) {
+        // sort
+        return serializeTypedArray('S', value);
+      }
+
+      if (value instanceof Uint16Array) {
+        // unsigned short
+        return serializeTypedArray('s', value);
+      }
+
+      if (value instanceof Int32Array) {
+        // long
+        return serializeTypedArray('L', value);
+      }
+
+      if (value instanceof Uint32Array) {
+        // unsigned long
+        return serializeTypedArray('l', value);
+      }
+
+      if (value instanceof Float32Array) {
+        // float
+        return serializeTypedArray('G', value);
+      }
+
+      if (value instanceof Float64Array) {
+        // double
+        return serializeTypedArray('g', value);
+      }
+
+      if (value instanceof BigInt64Array) {
+        // number
+        return serializeTypedArray('M', value);
+      }
+
+      if (value instanceof BigUint64Array) {
+        // unsigned number
+        // We use "m" instead of "n" since JSON can start with "null"
+        return serializeTypedArray('m', value);
+      }
+
+      if (value instanceof DataView) {
+        return serializeTypedArray('V', value);
+      } // TODO: Blob is not available in old Node/browsers. Remove the typeof check later.
+
+
+      if (typeof Blob === 'function' && value instanceof Blob) {
+        if (formData === null) {
+          formData = new FormData();
+        }
+
+        const blobId = nextPartId++;
+        formData.append(formFieldPrefix + blobId, value);
+        return serializeBlobID(blobId);
+      }
+
+      const iteratorFn = getIteratorFn(value);
+
+      if (iteratorFn) {
+        const iterator = iteratorFn.call(value);
+
+        if (iterator === value) {
+          // Iterator, not Iterable
+          const iteratorId = nextPartId++;
+          const partJSON = serializeModel(Array.from(iterator), iteratorId);
+
+          if (formData === null) {
+            formData = new FormData();
+          }
+
+          formData.append(formFieldPrefix + iteratorId, partJSON);
+          return serializeIteratorID(iteratorId);
+        }
+
+        return Array.from(iterator);
+      } // TODO: ReadableStream is not available in old Node. Remove the typeof check later.
+
+
+      if (typeof ReadableStream === 'function' && value instanceof ReadableStream) {
+        return serializeReadableStream(value);
+      }
+
+      const getAsyncIterator = value[ASYNC_ITERATOR];
+
+      if (typeof getAsyncIterator === 'function') {
+        // We treat AsyncIterables as a Fragment and as such we might need to key them.
+        return serializeAsyncIterable(value, getAsyncIterator.call(value));
+      } // Verify that this is a simple plain object.
+
+
+      const proto = getPrototypeOf(value);
+
+      if (proto !== ObjectPrototype && (proto === null || getPrototypeOf(proto) !== null)) {
+        if (temporaryReferences === undefined) {
+          throw new Error('Only plain objects, and a few built-ins, can be passed to Server Functions. ' + 'Classes or null prototypes are not supported.' + (''));
+        } // We will have written this object to the temporary reference set above
+        // so we can replace it with a marker to refer to this slot later.
+
+
+        return serializeTemporaryReferenceMarker();
+      }
+
+
+      return value;
+    }
+
+    if (typeof value === 'string') {
+      // TODO: Maybe too clever. If we support URL there's no similar trick.
+      if (value[value.length - 1] === 'Z') {
+        // Possibly a Date, whose toJSON automatically calls toISOString
+        // $FlowFixMe[incompatible-use]
+        const originalValue = parent[key];
+
+        if (originalValue instanceof Date) {
+          return serializeDateFromDateJSON(value);
+        }
+      }
+
+      return escapeStringValue(value);
+    }
+
+    if (typeof value === 'boolean') {
+      return value;
+    }
+
+    if (typeof value === 'number') {
+      return serializeNumber(value);
+    }
+
+    if (typeof value === 'undefined') {
+      return serializeUndefined();
+    }
+
+    if (typeof value === 'function') {
+      const metaData = knownServerReferences.get(value);
+
+      if (metaData !== undefined) {
+        const metaDataJSON = JSON.stringify(metaData, resolveToJSON);
+
+        if (formData === null) {
+          // Upgrade to use FormData to allow us to stream this value.
+          formData = new FormData();
+        } // The reference to this function came from the same client so we can pass it back.
+
+
+        const refId = nextPartId++;
+        formData.set(formFieldPrefix + refId, metaDataJSON);
+        return serializeServerReferenceID(refId);
+      }
+
+      if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        const parentReference = writtenObjects.get(parent);
+
+        if (parentReference !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          const reference = parentReference + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+          writeTemporaryReference(temporaryReferences, reference, value);
+          return serializeTemporaryReferenceMarker();
+        }
+      }
+
+      throw new Error('Client Functions cannot be passed directly to Server Functions. ' + 'Only Functions passed from the Server can be passed back again.');
+    }
+
+    if (typeof value === 'symbol') {
+      if (temporaryReferences !== undefined && key.indexOf(':') === -1) {
+        // TODO: If the property name contains a colon, we don't dedupe. Escape instead.
+        const parentReference = writtenObjects.get(parent);
+
+        if (parentReference !== undefined) {
+          // If the parent has a reference, we can refer to this object indirectly
+          // through the property name inside that parent.
+          const reference = parentReference + ':' + key; // Store this object so that the server can refer to it later in responses.
+
+          writeTemporaryReference(temporaryReferences, reference, value);
+          return serializeTemporaryReferenceMarker();
+        }
+      }
+
+      throw new Error('Symbols cannot be passed to a Server Function without a ' + 'temporary reference set. Pass a TemporaryReferenceSet to the options.' + (''));
+    }
+
+    if (typeof value === 'bigint') {
+      return serializeBigInt(value);
+    }
+
+    throw new Error("Type " + typeof value + " is not supported as an argument to a Server Function.");
+  }
+
+  function serializeModel(model, id) {
+    if (typeof model === 'object' && model !== null) {
+      const reference = serializeByValueID(id);
+      writtenObjects.set(model, reference);
+
+      if (temporaryReferences !== undefined) {
+        // Store this object so that the server can refer to it later in responses.
+        writeTemporaryReference(temporaryReferences, reference, model);
+      }
+    }
+
+    modelRoot = model; // $FlowFixMe[incompatible-return] it's not going to be undefined because we'll encode it.
+
+    return JSON.stringify(model, resolveToJSON);
+  }
+
+  function abort(reason) {
+    if (pendingParts > 0) {
+      pendingParts = 0; // Don't resolve again later.
+      // Resolve with what we have so far, which may have holes at this point.
+      // They'll error when the stream completes on the server.
+
+      if (formData === null) {
+        resolve(json);
+      } else {
+        resolve(formData);
+      }
+    }
+  }
+
+  const json = serializeModel(root, 0);
+
+  if (formData === null) {
+    // If it's a simple data structure, we just use plain JSON.
+    resolve(json);
+  } else {
+    // Otherwise, we use FormData to let us stream in the result.
+    formData.set(formFieldPrefix + '0', json);
+
+    if (pendingParts === 0) {
+      // $FlowFixMe[incompatible-call] this has already been refined.
+      resolve(formData);
+    }
+  }
+
+  return abort;
+}
+
+function registerServerReference(proxy, reference, encodeFormAction) {
+
+  knownServerReferences.set(proxy, reference);
+} // $FlowFixMe[method-unbinding]
+
+function createBoundServerReference(metaData, callServer, encodeFormAction, findSourceMapURL) // DEV-only
+{
+  const id = metaData.id;
+  const bound = metaData.bound;
+
+  let action = function () {
+    // $FlowFixMe[method-unbinding]
+    const args = Array.prototype.slice.call(arguments);
+    const p = bound;
+
+    if (!p) {
+      return callServer(id, args);
+    }
+
+    if (p.status === 'fulfilled') {
+      const boundArgs = p.value;
+      return callServer(id, boundArgs.concat(args));
+    } // Since this is a fake Promise whose .then doesn't chain, we have to wrap it.
+    // TODO: Remove the wrapper once that's fixed.
+
+
+    return Promise.resolve(p).then(function (boundArgs) {
+      return callServer(id, boundArgs.concat(args));
+    });
+  };
+
+  registerServerReference(action, {
+    id,
+    bound
+  });
+  return action;
+} // This matches either of these V8 formats.
+
+function createServerReference(id, callServer, encodeFormAction, findSourceMapURL, // DEV-only
+functionName) {
+  let action = function () {
+    // $FlowFixMe[method-unbinding]
+    const args = Array.prototype.slice.call(arguments);
+    return callServer(id, args);
+  };
+
+  registerServerReference(action, {
+    id,
+    bound: null
+  });
+  return action;
+}
+
+const ROW_ID = 0;
+const ROW_TAG = 1;
+const ROW_LENGTH = 2;
+const ROW_CHUNK_BY_NEWLINE = 3;
+const ROW_CHUNK_BY_LENGTH = 4;
+const PENDING = 'pending';
+const BLOCKED = 'blocked';
+const RESOLVED_MODEL = 'resolved_model';
+const RESOLVED_MODULE = 'resolved_module';
+const INITIALIZED = 'fulfilled';
+const ERRORED = 'rejected'; // $FlowFixMe[missing-this-annot]
+
+function ReactPromise(status, value, reason, response) {
+  this.status = status;
+  this.value = value;
+  this.reason = reason;
+  this._response = response;
+} // We subclass Promise.prototype so that we get other methods like .catch
+
+
+ReactPromise.prototype = Object.create(Promise.prototype); // TODO: This doesn't return a new Promise chain unlike the real .then
+
+ReactPromise.prototype.then = function (resolve, reject) {
+  const chunk = this; // If we have resolved content, we try to initialize it first which
+  // might put us back into one of the other states.
+
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      resolve(chunk.value);
+      break;
+
+    case PENDING:
+    case BLOCKED:
+      if (resolve) {
+        if (chunk.value === null) {
+          chunk.value = [];
+        }
+
+        chunk.value.push(resolve);
+      }
+
+      if (reject) {
+        if (chunk.reason === null) {
+          chunk.reason = [];
+        }
+
+        chunk.reason.push(reject);
+      }
+
+      break;
+
+    default:
+      if (reject) {
+        reject(chunk.reason);
+      }
+
+      break;
+  }
+};
+
+function readChunk(chunk) {
+  // If we have resolved content, we try to initialize it first which
+  // might put us back into one of the other states.
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      return chunk.value;
+
+    case PENDING:
+    case BLOCKED:
+      // eslint-disable-next-line no-throw-literal
+      throw chunk;
+
+    default:
+      throw chunk.reason;
+  }
+}
+
+function getRoot(response) {
+  const chunk = getChunk(response, 0);
+  return chunk;
+}
+
+function createPendingChunk(response) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(PENDING, null, null, response);
+}
+
+function createBlockedChunk(response) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(BLOCKED, null, null, response);
+}
+
+function createErrorChunk(response, error) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(ERRORED, null, error, response);
+}
+
+function wakeChunk(listeners, value) {
+  for (let i = 0; i < listeners.length; i++) {
+    const listener = listeners[i];
+    listener(value);
+  }
+}
+
+function wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {
+  switch (chunk.status) {
+    case INITIALIZED:
+      wakeChunk(resolveListeners, chunk.value);
+      break;
+
+    case PENDING:
+    case BLOCKED:
+      if (chunk.value) {
+        for (let i = 0; i < resolveListeners.length; i++) {
+          chunk.value.push(resolveListeners[i]);
+        }
+      } else {
+        chunk.value = resolveListeners;
+      }
+
+      if (chunk.reason) {
+        if (rejectListeners) {
+          for (let i = 0; i < rejectListeners.length; i++) {
+            chunk.reason.push(rejectListeners[i]);
+          }
+        }
+      } else {
+        chunk.reason = rejectListeners;
+      }
+
+      break;
+
+    case ERRORED:
+      if (rejectListeners) {
+        wakeChunk(rejectListeners, chunk.reason);
+      }
+
+      break;
+  }
+}
+
+function triggerErrorOnChunk(chunk, error) {
+  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    const streamChunk = chunk;
+    const controller = streamChunk.reason; // $FlowFixMe[incompatible-call]: The error method should accept mixed.
+
+    controller.error(error);
+    return;
+  }
+
+  const listeners = chunk.reason;
+  const erroredChunk = chunk;
+  erroredChunk.status = ERRORED;
+  erroredChunk.reason = error;
+
+  if (listeners !== null) {
+    wakeChunk(listeners, error);
+  }
+}
+
+function createResolvedModelChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(RESOLVED_MODEL, value, null, response);
+}
+
+function createResolvedModuleChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(RESOLVED_MODULE, value, null, response);
+}
+
+function createInitializedTextChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, null, response);
+}
+
+function createInitializedBufferChunk(response, value) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, null, response);
+}
+
+function createInitializedIteratorResultChunk(response, value, done) {
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, {
+    done: done,
+    value: value
+  }, null, response);
+}
+
+function createInitializedStreamChunk(response, value, controller) {
+  // We use the reason field to stash the controller since we already have that
+  // field. It's a bit of a hack but efficient.
+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+  return new ReactPromise(INITIALIZED, value, controller, response);
+}
+
+function createResolvedIteratorResultChunk(response, value, done) {
+  // To reuse code as much code as possible we add the wrapper element as part of the JSON.
+  const iteratorResultJSON = (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}'; // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+
+  return new ReactPromise(RESOLVED_MODEL, iteratorResultJSON, null, response);
+}
+
+function resolveIteratorResultChunk(chunk, value, done) {
+  // To reuse code as much code as possible we add the wrapper element as part of the JSON.
+  const iteratorResultJSON = (done ? '{"done":true,"value":' : '{"done":false,"value":') + value + '}';
+  resolveModelChunk(chunk, iteratorResultJSON);
+}
+
+function resolveModelChunk(chunk, value) {
+  if (chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    const streamChunk = chunk;
+    const controller = streamChunk.reason;
+    controller.enqueueModel(value);
+    return;
+  }
+
+  const resolveListeners = chunk.value;
+  const rejectListeners = chunk.reason;
+  const resolvedChunk = chunk;
+  resolvedChunk.status = RESOLVED_MODEL;
+  resolvedChunk.value = value;
+
+  if (resolveListeners !== null) {
+    // This is unfortunate that we're reading this eagerly if
+    // we already have listeners attached since they might no
+    // longer be rendered or might not be the highest pri.
+    initializeModelChunk(resolvedChunk); // The status might have changed after initialization.
+
+    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+  }
+}
+
+function resolveModuleChunk(chunk, value) {
+  if (chunk.status !== PENDING && chunk.status !== BLOCKED) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  const resolveListeners = chunk.value;
+  const rejectListeners = chunk.reason;
+  const resolvedChunk = chunk;
+  resolvedChunk.status = RESOLVED_MODULE;
+  resolvedChunk.value = value;
+
+  if (resolveListeners !== null) {
+    initializeModuleChunk(resolvedChunk);
+    wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+  }
+}
+
+let initializingHandler = null;
+
+function initializeModelChunk(chunk) {
+  const prevHandler = initializingHandler;
+  initializingHandler = null;
+  const resolvedModel = chunk.value; // We go to the BLOCKED state until we've fully resolved this.
+  // We do this before parsing in case we try to initialize the same chunk
+  // while parsing the model. Such as in a cyclic reference.
+
+  const cyclicChunk = chunk;
+  cyclicChunk.status = BLOCKED;
+  cyclicChunk.value = null;
+  cyclicChunk.reason = null;
+
+  try {
+    const value = parseModel(chunk._response, resolvedModel); // Invoke any listeners added while resolving this model. I.e. cyclic
+    // references. This may or may not fully resolve the model depending on
+    // if they were blocked.
+
+    const resolveListeners = cyclicChunk.value;
+
+    if (resolveListeners !== null) {
+      cyclicChunk.value = null;
+      cyclicChunk.reason = null;
+      wakeChunk(resolveListeners, value);
+    }
+
+    if (initializingHandler !== null) {
+      if (initializingHandler.errored) {
+        throw initializingHandler.value;
+      }
+
+      if (initializingHandler.deps > 0) {
+        // We discovered new dependencies on modules that are not yet resolved.
+        // We have to keep the BLOCKED state until they're resolved.
+        initializingHandler.value = value;
+        initializingHandler.chunk = cyclicChunk;
+        return;
+      }
+    }
+
+    const initializedChunk = chunk;
+    initializedChunk.status = INITIALIZED;
+    initializedChunk.value = value;
+  } catch (error) {
+    const erroredChunk = chunk;
+    erroredChunk.status = ERRORED;
+    erroredChunk.reason = error;
+  } finally {
+    initializingHandler = prevHandler;
+  }
+}
+
+function initializeModuleChunk(chunk) {
+  try {
+    const value = requireModule(chunk.value);
+    const initializedChunk = chunk;
+    initializedChunk.status = INITIALIZED;
+    initializedChunk.value = value;
+  } catch (error) {
+    const erroredChunk = chunk;
+    erroredChunk.status = ERRORED;
+    erroredChunk.reason = error;
+  }
+} // Report that any missing chunks in the model is now going to throw this
+// error upon read. Also notify any pending promises.
+
+
+function reportGlobalError(response, error) {
+  response._closed = true;
+  response._closedReason = error;
+
+  response._chunks.forEach(chunk => {
+    // If this chunk was already resolved or errored, it won't
+    // trigger an error but if it wasn't then we need to
+    // because we won't be getting any new data to resolve it.
+    if (chunk.status === PENDING) {
+      triggerErrorOnChunk(chunk, error);
+    }
+  });
+}
+
+function createElement(response, type, key, props, owner, // DEV-only
+stack, // DEV-only
+validated) // DEV-only
+{
+  let element;
+
+  {
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      type,
+      key,
+      ref: null,
+      props
+    };
+  }
+
+  if (initializingHandler !== null) {
+    const handler = initializingHandler; // We pop the stack to the previous outer handler before leaving the Element.
+    // This is effectively the complete phase.
+
+    initializingHandler = handler.parent;
+
+    if (handler.errored) {
+      // Something errored inside this Element's props. We can turn this Element
+      // into a Lazy so that we can still render up until that Lazy is rendered.
+      const erroredChunk = createErrorChunk(response, handler.value);
+
+      return createLazyChunkWrapper(erroredChunk);
+    }
+
+    if (handler.deps > 0) {
+      // We have blocked references inside this Element but we can turn this into
+      // a Lazy node referencing this Element to let everything around it proceed.
+      const blockedChunk = createBlockedChunk(response);
+      handler.value = element;
+      handler.chunk = blockedChunk;
+
+      return createLazyChunkWrapper(blockedChunk);
+    }
+  }
+
+  return element;
+}
+
+function createLazyChunkWrapper(chunk) {
+  const lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: chunk,
+    _init: readChunk
+  };
+
+  return lazyType;
+}
+
+function getChunk(response, id) {
+  const chunks = response._chunks;
+  let chunk = chunks.get(id);
+
+  if (!chunk) {
+    if (response._closed) {
+      // We have already errored the response and we're not going to get
+      // anything more streaming in so this will immediately error.
+      chunk = createErrorChunk(response, response._closedReason);
+    } else {
+      chunk = createPendingChunk(response);
+    }
+
+    chunks.set(id, chunk);
+  }
+
+  return chunk;
+}
+
+function waitForReference(referencedChunk, parentObject, key, response, map, path) {
+  let handler;
+
+  if (initializingHandler) {
+    handler = initializingHandler;
+    handler.deps++;
+  } else {
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: false
+    };
+  }
+
+  function fulfill(value) {
+    for (let i = 1; i < path.length; i++) {
+      while (value.$$typeof === REACT_LAZY_TYPE) {
+        // We never expect to see a Lazy node on this path because we encode those as
+        // separate models. This must mean that we have inserted an extra lazy node
+        // e.g. to replace a blocked element. We must instead look for it inside.
+        const chunk = value._payload;
+
+        if (chunk === handler.chunk) {
+          // This is a reference to the thing we're currently blocking. We can peak
+          // inside of it to get the value.
+          value = handler.value;
+          continue;
+        } else if (chunk.status === INITIALIZED) {
+          value = chunk.value;
+          continue;
+        } else {
+          // If we're not yet initialized we need to skip what we've already drilled
+          // through and then wait for the next value to become available.
+          path.splice(0, i - 1);
+          chunk.then(fulfill, reject);
+          return;
+        }
+      }
+
+      value = value[path[i]];
+    }
+
+    const mappedValue = map(response, value, parentObject, key);
+    parentObject[key] = mappedValue; // If this is the root object for a model reference, where `handler.value`
+    // is a stale `null`, the resolved value can be used directly.
+
+    if (key === '' && handler.value === null) {
+      handler.value = mappedValue;
+    } // If the parent object is an unparsed React element tuple, we also need to
+    // update the props and owner of the parsed element object (i.e.
+    // handler.value).
+
+
+    if (parentObject[0] === REACT_ELEMENT_TYPE && typeof handler.value === 'object' && handler.value !== null && handler.value.$$typeof === REACT_ELEMENT_TYPE) {
+      const element = handler.value;
+
+      switch (key) {
+        case '3':
+          element.props = mappedValue;
+          break;
+      }
+    }
+
+    handler.deps--;
+
+    if (handler.deps === 0) {
+      const chunk = handler.chunk;
+
+      if (chunk === null || chunk.status !== BLOCKED) {
+        return;
+      }
+
+      const resolveListeners = chunk.value;
+      const initializedChunk = chunk;
+      initializedChunk.status = INITIALIZED;
+      initializedChunk.value = handler.value;
+
+      if (resolveListeners !== null) {
+        wakeChunk(resolveListeners, handler.value);
+      }
+    }
+  }
+
+  function reject(error) {
+    if (handler.errored) {
+      // We've already errored. We could instead build up an AggregateError
+      // but if there are multiple errors we just take the first one like
+      // Promise.all.
+      return;
+    }
+    handler.errored = true;
+    handler.value = error;
+    const chunk = handler.chunk;
+
+    if (chunk === null || chunk.status !== BLOCKED) {
+      return;
+    }
+
+    triggerErrorOnChunk(chunk, error);
+  }
+
+  referencedChunk.then(fulfill, reject); // Return a place holder value for now.
+
+  return null;
+}
+
+function loadServerReference(response, metaData, parentObject, key) {
+  if (!response._serverReferenceConfig) {
+    // In the normal case, we can't load this Server Reference in the current environment and
+    // we just return a proxy to it.
+    return createBoundServerReference(metaData, response._callServer);
+  } // If we have a module mapping we can load the real version of this Server Reference.
+
+
+  const serverReference = resolveServerReference(response._serverReferenceConfig, metaData.id);
+  let promise = preloadModule(serverReference);
+
+  if (!promise) {
+    if (!metaData.bound) {
+      return requireModule(serverReference);
+    } else {
+      promise = Promise.resolve(metaData.bound);
+    }
+  } else if (metaData.bound) {
+    promise = Promise.all([promise, metaData.bound]);
+  }
+
+  let handler;
+
+  if (initializingHandler) {
+    handler = initializingHandler;
+    handler.deps++;
+  } else {
+    handler = initializingHandler = {
+      parent: null,
+      chunk: null,
+      value: null,
+      deps: 1,
+      errored: false
+    };
+  }
+
+  function fulfill() {
+    let resolvedValue = requireModule(serverReference);
+
+    if (metaData.bound) {
+      // This promise is coming from us and should have initilialized by now.
+      const boundArgs = metaData.bound.value.slice(0);
+      boundArgs.unshift(null); // this
+
+      resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);
+    }
+
+    parentObject[key] = resolvedValue; // If this is the root object for a model reference, where `handler.value`
+    // is a stale `null`, the resolved value can be used directly.
+
+    if (key === '' && handler.value === null) {
+      handler.value = resolvedValue;
+    } // If the parent object is an unparsed React element tuple, we also need to
+    // update the props and owner of the parsed element object (i.e.
+    // handler.value).
+
+
+    if (parentObject[0] === REACT_ELEMENT_TYPE && typeof handler.value === 'object' && handler.value !== null && handler.value.$$typeof === REACT_ELEMENT_TYPE) {
+      const element = handler.value;
+
+      switch (key) {
+        case '3':
+          element.props = resolvedValue;
+          break;
+      }
+    }
+
+    handler.deps--;
+
+    if (handler.deps === 0) {
+      const chunk = handler.chunk;
+
+      if (chunk === null || chunk.status !== BLOCKED) {
+        return;
+      }
+
+      const resolveListeners = chunk.value;
+      const initializedChunk = chunk;
+      initializedChunk.status = INITIALIZED;
+      initializedChunk.value = handler.value;
+
+      if (resolveListeners !== null) {
+        wakeChunk(resolveListeners, handler.value);
+      }
+    }
+  }
+
+  function reject(error) {
+    if (handler.errored) {
+      // We've already errored. We could instead build up an AggregateError
+      // but if there are multiple errors we just take the first one like
+      // Promise.all.
+      return;
+    }
+    handler.errored = true;
+    handler.value = error;
+    const chunk = handler.chunk;
+
+    if (chunk === null || chunk.status !== BLOCKED) {
+      return;
+    }
+
+    triggerErrorOnChunk(chunk, error);
+  }
+
+  promise.then(fulfill, reject); // Return a place holder value for now.
+
+  return null;
+}
+
+function getOutlinedModel(response, reference, parentObject, key, map) {
+  const path = reference.split(':');
+  const id = parseInt(path[0], 16);
+  const chunk = getChunk(response, id);
+
+  switch (chunk.status) {
+    case RESOLVED_MODEL:
+      initializeModelChunk(chunk);
+      break;
+
+    case RESOLVED_MODULE:
+      initializeModuleChunk(chunk);
+      break;
+  } // The status might have changed after initialization.
+
+
+  switch (chunk.status) {
+    case INITIALIZED:
+      let value = chunk.value;
+
+      for (let i = 1; i < path.length; i++) {
+        while (value.$$typeof === REACT_LAZY_TYPE) {
+          const referencedChunk = value._payload;
+
+          if (referencedChunk.status === INITIALIZED) {
+            value = referencedChunk.value;
+          } else {
+            return waitForReference(referencedChunk, parentObject, key, response, map, path.slice(i - 1));
+          }
+        }
+
+        value = value[path[i]];
+      }
+
+      const chunkValue = map(response, value, parentObject, key);
+
+      return chunkValue;
+
+    case PENDING:
+    case BLOCKED:
+      return waitForReference(chunk, parentObject, key, response, map, path);
+
+    default:
+      // This is an error. Instead of erroring directly, we're going to encode this on
+      // an initialization handler so that we can catch it at the nearest Element.
+      if (initializingHandler) {
+        initializingHandler.errored = true;
+        initializingHandler.value = chunk.reason;
+      } else {
+        initializingHandler = {
+          parent: null,
+          chunk: null,
+          value: chunk.reason,
+          deps: 0,
+          errored: true
+        };
+      } // Placeholder
+
+
+      return null;
+  }
+}
+
+function createMap(response, model) {
+  return new Map(model);
+}
+
+function createSet(response, model) {
+  return new Set(model);
+}
+
+function createBlob(response, model) {
+  return new Blob(model.slice(1), {
+    type: model[0]
+  });
+}
+
+function createFormData(response, model) {
+  const formData = new FormData();
+
+  for (let i = 0; i < model.length; i++) {
+    formData.append(model[i][0], model[i][1]);
+  }
+
+  return formData;
+}
+
+function extractIterator(response, model) {
+  // $FlowFixMe[incompatible-use]: This uses raw Symbols because we're extracting from a native array.
+  return model[Symbol.iterator]();
+}
+
+function createModel(response, model) {
+  return model;
+}
+
+function parseModelString(response, parentObject, key, value) {
+  if (value[0] === '$') {
+    if (value === '$') {
+      // A very common symbol.
+      if (initializingHandler !== null && key === '0') {
+        // We we already have an initializing handler and we're abound to enter
+        // a new element, we need to shadow it because we're now in a new scope.
+        // This is effectively the "begin" or "push" phase of Element parsing.
+        // We'll pop later when we parse the array itself.
+        initializingHandler = {
+          parent: initializingHandler,
+          chunk: null,
+          value: null,
+          deps: 0,
+          errored: false
+        };
+      }
+
+      return REACT_ELEMENT_TYPE;
+    }
+
+    switch (value[1]) {
+      case '$':
+        {
+          // This was an escaped string value.
+          return value.slice(1);
+        }
+
+      case 'L':
+        {
+          // Lazy node
+          const id = parseInt(value.slice(2), 16);
+          const chunk = getChunk(response, id);
+          // When passed into React, we'll know how to suspend on this.
+
+
+          return createLazyChunkWrapper(chunk);
+        }
+
+      case '@':
+        {
+          // Promise
+          if (value.length === 2) {
+            // Infinite promise that never resolves.
+            return new Promise(() => {});
+          }
+
+          const id = parseInt(value.slice(2), 16);
+          const chunk = getChunk(response, id);
+
+          return chunk;
+        }
+
+      case 'S':
+        {
+          // Symbol
+          return Symbol.for(value.slice(2));
+        }
+
+      case 'F':
+        {
+          // Server Reference
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, loadServerReference);
+        }
+
+      case 'T':
+        {
+          // Temporary Reference
+          const reference = '$' + value.slice(2);
+          const temporaryReferences = response._tempRefs;
+
+          if (temporaryReferences == null) {
+            throw new Error('Missing a temporary reference set but the RSC response returned a temporary reference. ' + 'Pass a temporaryReference option with the set that was used with the reply.');
+          }
+
+          return readTemporaryReference(temporaryReferences, reference);
+        }
+
+      case 'Q':
+        {
+          // Map
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, createMap);
+        }
+
+      case 'W':
+        {
+          // Set
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, createSet);
+        }
+
+      case 'B':
+        {
+          // Blob
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, createBlob);
+        }
+
+      case 'K':
+        {
+          // FormData
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, createFormData);
+        }
+
+      case 'Z':
+        {
+          // Error
+          {
+            return resolveErrorProd();
+          }
+        }
+
+      case 'i':
+        {
+          // Iterator
+          const ref = value.slice(2);
+          return getOutlinedModel(response, ref, parentObject, key, extractIterator);
+        }
+
+      case 'I':
+        {
+          // $Infinity
+          return Infinity;
+        }
+
+      case '-':
+        {
+          // $-0 or $-Infinity
+          if (value === '$-0') {
+            return -0;
+          } else {
+            return -Infinity;
+          }
+        }
+
+      case 'N':
+        {
+          // $NaN
+          return NaN;
+        }
+
+      case 'u':
+        {
+          // matches "$undefined"
+          // Special encoding for `undefined` which can't be serialized as JSON otherwise.
+          return undefined;
+        }
+
+      case 'D':
+        {
+          // Date
+          return new Date(Date.parse(value.slice(2)));
+        }
+
+      case 'n':
+        {
+          // BigInt
+          return BigInt(value.slice(2));
+        }
+
+      case 'E':
+
+      case 'Y':
+
+      default:
+        {
+          // We assume that anything else is a reference ID.
+          const ref = value.slice(1);
+          return getOutlinedModel(response, ref, parentObject, key, createModel);
+        }
+    }
+  }
+
+  return value;
+}
+
+function parseModelTuple(response, value) {
+  const tuple = value;
+
+  if (tuple[0] === REACT_ELEMENT_TYPE) {
+    // TODO: Consider having React just directly accept these arrays as elements.
+    // Or even change the ReactElement type to be an array.
+    return createElement(response, tuple[1], tuple[2], tuple[3]);
+  }
+
+  return value;
+}
+
+function missingCall() {
+  throw new Error('Trying to call a function from "use server" but the callServer option ' + 'was not implemented in your router runtime.');
+}
+
+function ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName) {
+  const chunks = new Map();
+  this._bundlerConfig = bundlerConfig;
+  this._serverReferenceConfig = serverReferenceConfig;
+  this._moduleLoading = moduleLoading;
+  this._callServer = callServer !== undefined ? callServer : missingCall;
+  this._encodeFormAction = encodeFormAction;
+  this._nonce = nonce;
+  this._chunks = chunks;
+  this._stringDecoder = createStringDecoder();
+  this._fromJSON = null;
+  this._rowState = 0;
+  this._rowID = 0;
+  this._rowTag = 0;
+  this._rowLength = 0;
+  this._buffer = [];
+  this._closed = false;
+  this._closedReason = null;
+  this._tempRefs = temporaryReferences;
+
+
+  this._fromJSON = createFromJSONCallback(this);
+}
+
+function createResponse(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences, findSourceMapURL, replayConsole, environmentName) {
+  // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors
+  return new ResponseInstance(bundlerConfig, serverReferenceConfig, moduleLoading, callServer, encodeFormAction, nonce, temporaryReferences);
+}
+
+function resolveModel(response, id, model) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createResolvedModelChunk(response, model));
+  } else {
+    resolveModelChunk(chunk, model);
+  }
+}
+
+function resolveText(response, id, text) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (chunk && chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    const streamChunk = chunk;
+    const controller = streamChunk.reason;
+    controller.enqueueValue(text);
+    return;
+  }
+
+  chunks.set(id, createInitializedTextChunk(response, text));
+}
+
+function resolveBuffer(response, id, buffer) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (chunk && chunk.status !== PENDING) {
+    // If we get more data to an already resolved ID, we assume that it's
+    // a stream chunk since any other row shouldn't have more than one entry.
+    const streamChunk = chunk;
+    const controller = streamChunk.reason;
+    controller.enqueueValue(buffer);
+    return;
+  }
+
+  chunks.set(id, createInitializedBufferChunk(response, buffer));
+}
+
+function resolveModule(response, id, model) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+  const clientReferenceMetadata = parseModel(response, model);
+  const clientReference = resolveClientReference(response._bundlerConfig, clientReferenceMetadata);
+  // For now we preload all modules as early as possible since it's likely
+  // that we'll need them.
+
+  const promise = preloadModule(clientReference);
+
+  if (promise) {
+    let blockedChunk;
+
+    if (!chunk) {
+      // Technically, we should just treat promise as the chunk in this
+      // case. Because it'll just behave as any other promise.
+      blockedChunk = createBlockedChunk(response);
+      chunks.set(id, blockedChunk);
+    } else {
+      // This can't actually happen because we don't have any forward
+      // references to modules.
+      blockedChunk = chunk;
+      blockedChunk.status = BLOCKED;
+    }
+
+    promise.then(() => resolveModuleChunk(blockedChunk, clientReference), error => triggerErrorOnChunk(blockedChunk, error));
+  } else {
+    if (!chunk) {
+      chunks.set(id, createResolvedModuleChunk(response, clientReference));
+    } else {
+      // This can't actually happen because we don't have any forward
+      // references to modules.
+      resolveModuleChunk(chunk, clientReference);
+    }
+  }
+}
+
+function resolveStream(response, id, stream, controller) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createInitializedStreamChunk(response, stream, controller));
+    return;
+  }
+
+  if (chunk.status !== PENDING) {
+    // We already resolved. We didn't expect to see this.
+    return;
+  }
+
+  const resolveListeners = chunk.value;
+  const resolvedChunk = chunk;
+  resolvedChunk.status = INITIALIZED;
+  resolvedChunk.value = stream;
+  resolvedChunk.reason = controller;
+
+  if (resolveListeners !== null) {
+    wakeChunk(resolveListeners, chunk.value);
+  }
+}
+
+function startReadableStream(response, id, type) {
+  let controller = null;
+  const stream = new ReadableStream({
+    type: type,
+
+    start(c) {
+      controller = c;
+    }
+
+  });
+  let previousBlockedChunk = null;
+  const flightController = {
+    enqueueValue(value) {
+      if (previousBlockedChunk === null) {
+        controller.enqueue(value);
+      } else {
+        // We're still waiting on a previous chunk so we can't enqueue quite yet.
+        previousBlockedChunk.then(function () {
+          controller.enqueue(value);
+        });
+      }
+    },
+
+    enqueueModel(json) {
+      if (previousBlockedChunk === null) {
+        // If we're not blocked on any other chunks, we can try to eagerly initialize
+        // this as a fast-path to avoid awaiting them.
+        const chunk = createResolvedModelChunk(response, json);
+        initializeModelChunk(chunk);
+        const initializedChunk = chunk;
+
+        if (initializedChunk.status === INITIALIZED) {
+          controller.enqueue(initializedChunk.value);
+        } else {
+          chunk.then(v => controller.enqueue(v), e => controller.error(e));
+          previousBlockedChunk = chunk;
+        }
+      } else {
+        // We're still waiting on a previous chunk so we can't enqueue quite yet.
+        const blockedChunk = previousBlockedChunk;
+        const chunk = createPendingChunk(response);
+        chunk.then(v => controller.enqueue(v), e => controller.error(e));
+        previousBlockedChunk = chunk;
+        blockedChunk.then(function () {
+          if (previousBlockedChunk === chunk) {
+            // We were still the last chunk so we can now clear the queue and return
+            // to synchronous emitting.
+            previousBlockedChunk = null;
+          }
+
+          resolveModelChunk(chunk, json);
+        });
+      }
+    },
+
+    close(json) {
+      if (previousBlockedChunk === null) {
+        controller.close();
+      } else {
+        const blockedChunk = previousBlockedChunk; // We shouldn't get any more enqueues after this so we can set it back to null.
+
+        previousBlockedChunk = null;
+        blockedChunk.then(() => controller.close());
+      }
+    },
+
+    error(error) {
+      if (previousBlockedChunk === null) {
+        // $FlowFixMe[incompatible-call]
+        controller.error(error);
+      } else {
+        const blockedChunk = previousBlockedChunk; // We shouldn't get any more enqueues after this so we can set it back to null.
+
+        previousBlockedChunk = null;
+        blockedChunk.then(() => controller.error(error));
+      }
+    }
+
+  };
+  resolveStream(response, id, stream, flightController);
+}
+
+function asyncIterator() {
+  // Self referencing iterator.
+  return this;
+}
+
+function createIterator(next) {
+  const iterator = {
+    next: next // TODO: Add return/throw as options for aborting.
+
+  }; // TODO: The iterator could inherit the AsyncIterator prototype which is not exposed as
+  // a global but exists as a prototype of an AsyncGenerator. However, it's not needed
+  // to satisfy the iterable protocol.
+
+  iterator[ASYNC_ITERATOR] = asyncIterator;
+  return iterator;
+}
+
+function startAsyncIterable(response, id, iterator) {
+  const buffer = [];
+  let closed = false;
+  let nextWriteIndex = 0;
+  const flightController = {
+    enqueueValue(value) {
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createInitializedIteratorResultChunk(response, value, false);
+      } else {
+        const chunk = buffer[nextWriteIndex];
+        const resolveListeners = chunk.value;
+        const rejectListeners = chunk.reason;
+        const initializedChunk = chunk;
+        initializedChunk.status = INITIALIZED;
+        initializedChunk.value = {
+          done: false,
+          value: value
+        };
+
+        if (resolveListeners !== null) {
+          wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);
+        }
+      }
+
+      nextWriteIndex++;
+    },
+
+    enqueueModel(value) {
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, false);
+      } else {
+        resolveIteratorResultChunk(buffer[nextWriteIndex], value, false);
+      }
+
+      nextWriteIndex++;
+    },
+
+    close(value) {
+      closed = true;
+
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, true);
+      } else {
+        resolveIteratorResultChunk(buffer[nextWriteIndex], value, true);
+      }
+
+      nextWriteIndex++;
+
+      while (nextWriteIndex < buffer.length) {
+        // In generators, any extra reads from the iterator have the value undefined.
+        resolveIteratorResultChunk(buffer[nextWriteIndex++], '"$undefined"', true);
+      }
+    },
+
+    error(error) {
+      closed = true;
+
+      if (nextWriteIndex === buffer.length) {
+        buffer[nextWriteIndex] = createPendingChunk(response);
+      }
+
+      while (nextWriteIndex < buffer.length) {
+        triggerErrorOnChunk(buffer[nextWriteIndex++], error);
+      }
+    }
+
+  };
+  const iterable = {
+    [ASYNC_ITERATOR]() {
+      let nextReadIndex = 0;
+      return createIterator(arg => {
+        if (arg !== undefined) {
+          throw new Error('Values cannot be passed to next() of AsyncIterables passed to Client Components.');
+        }
+
+        if (nextReadIndex === buffer.length) {
+          if (closed) {
+            // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors
+            return new ReactPromise(INITIALIZED, {
+              done: true,
+              value: undefined
+            }, null, response);
+          }
+
+          buffer[nextReadIndex] = createPendingChunk(response);
+        }
+
+        return buffer[nextReadIndex++];
+      });
+    }
+
+  }; // TODO: If it's a single shot iterator we can optimize memory by cleaning up the buffer after
+  // reading through the end, but currently we favor code size over this optimization.
+
+  resolveStream(response, id, iterator ? iterable[ASYNC_ITERATOR]() : iterable, flightController);
+}
+
+function stopStream(response, id, row) {
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (!chunk || chunk.status !== INITIALIZED) {
+    // We didn't expect not to have an existing stream;
+    return;
+  }
+
+  const streamChunk = chunk;
+  const controller = streamChunk.reason;
+  controller.close(row === '' ? '"$undefined"' : row);
+}
+
+function resolveErrorProd(response) {
+
+  const error = new Error('An error occurred in the Server Components render. The specific message is omitted in production' + ' builds to avoid leaking sensitive details. A digest property is included on this error instance which' + ' may provide additional details about the nature of the error.');
+  error.stack = 'Error: ' + error.message;
+  return error;
+}
+
+function resolvePostponeProd(response, id) {
+
+  const error = new Error('A Server Component was postponed. The reason is omitted in production' + ' builds to avoid leaking sensitive details.');
+  const postponeInstance = error;
+  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  postponeInstance.stack = 'Error: ' + error.message;
+  const chunks = response._chunks;
+  const chunk = chunks.get(id);
+
+  if (!chunk) {
+    chunks.set(id, createErrorChunk(response, postponeInstance));
+  } else {
+    triggerErrorOnChunk(chunk, postponeInstance);
+  }
+}
+
+function resolveHint(response, code, model) {
+  const hintModel = parseModel(response, model);
+  dispatchHint(code, hintModel);
+}
+
+function mergeBuffer(buffer, lastChunk) {
+  const l = buffer.length; // Count the bytes we'll need
+
+  let byteLength = lastChunk.length;
+
+  for (let i = 0; i < l; i++) {
+    byteLength += buffer[i].byteLength;
+  } // Allocate enough contiguous space
+
+
+  const result = new Uint8Array(byteLength);
+  let offset = 0; // Copy all the buffers into it.
+
+  for (let i = 0; i < l; i++) {
+    const chunk = buffer[i];
+    result.set(chunk, offset);
+    offset += chunk.byteLength;
+  }
+
+  result.set(lastChunk, offset);
+  return result;
+}
+
+function resolveTypedArray(response, id, buffer, lastChunk, constructor, bytesPerElement) {
+  // If the view fits into one original buffer, we just reuse that buffer instead of
+  // copying it out to a separate copy. This means that it's not always possible to
+  // transfer these values to other threads without copying first since they may
+  // share array buffer. For this to work, it must also have bytes aligned to a
+  // multiple of a size of the type.
+  const chunk = buffer.length === 0 && lastChunk.byteOffset % bytesPerElement === 0 ? lastChunk : mergeBuffer(buffer, lastChunk); // TODO: The transfer protocol of RSC is little-endian. If the client isn't little-endian
+  // we should convert it instead. In practice big endian isn't really Web compatible so it's
+  // somewhat safe to assume that browsers aren't going to run it, but maybe there's some SSR
+  // server that's affected.
+
+  const view = new constructor(chunk.buffer, chunk.byteOffset, chunk.byteLength / bytesPerElement);
+  resolveBuffer(response, id, view);
+}
+
+function processFullBinaryRow(response, id, tag, buffer, chunk) {
+  switch (tag) {
+    case 65
+    /* "A" */
+    :
+      // We must always clone to extract it into a separate buffer instead of just a view.
+      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);
+      return;
+
+    case 79
+    /* "O" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);
+      return;
+
+    case 111
+    /* "o" */
+    :
+      resolveBuffer(response, id, buffer.length === 0 ? chunk : mergeBuffer(buffer, chunk));
+      return;
+
+    case 85
+    /* "U" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);
+      return;
+
+    case 83
+    /* "S" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);
+      return;
+
+    case 115
+    /* "s" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);
+      return;
+
+    case 76
+    /* "L" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);
+      return;
+
+    case 108
+    /* "l" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);
+      return;
+
+    case 71
+    /* "G" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);
+      return;
+
+    case 103
+    /* "g" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);
+      return;
+
+    case 77
+    /* "M" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);
+      return;
+
+    case 109
+    /* "m" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);
+      return;
+
+    case 86
+    /* "V" */
+    :
+      resolveTypedArray(response, id, buffer, chunk, DataView, 1);
+      return;
+  }
+
+  const stringDecoder = response._stringDecoder;
+  let row = '';
+
+  for (let i = 0; i < buffer.length; i++) {
+    row += readPartialStringChunk(stringDecoder, buffer[i]);
+  }
+
+  row += readFinalStringChunk(stringDecoder, chunk);
+  processFullStringRow(response, id, tag, row);
+}
+
+function processFullStringRow(response, id, tag, row) {
+  switch (tag) {
+    case 73
+    /* "I" */
+    :
+      {
+        resolveModule(response, id, row);
+        return;
+      }
+
+    case 72
+    /* "H" */
+    :
+      {
+        const code = row[0];
+        resolveHint(response, code, row.slice(1));
+        return;
+      }
+
+    case 69
+    /* "E" */
+    :
+      {
+        const errorInfo = JSON.parse(row);
+        let error;
+
+        {
+          error = resolveErrorProd();
+        }
+
+        error.digest = errorInfo.digest;
+        const errorWithDigest = error;
+        const chunks = response._chunks;
+        const chunk = chunks.get(id);
+
+        if (!chunk) {
+          chunks.set(id, createErrorChunk(response, errorWithDigest));
+        } else {
+          triggerErrorOnChunk(chunk, errorWithDigest);
+        }
+
+        return;
+      }
+
+    case 84
+    /* "T" */
+    :
+      {
+        resolveText(response, id, row);
+        return;
+      }
+
+    case 78
+    /* "N" */
+    :
+
+    case 68
+    /* "D" */
+    :
+
+    case 87
+    /* "W" */
+    :
+      {
+
+        throw new Error('Failed to read a RSC payload created by a development version of React ' + 'on the server while using a production version on the client. Always use ' + 'matching versions on the server and the client.');
+      }
+
+    case 82
+    /* "R" */
+    :
+      {
+        startReadableStream(response, id, undefined);
+        return;
+      }
+    // Fallthrough
+
+    case 114
+    /* "r" */
+    :
+      {
+        startReadableStream(response, id, 'bytes');
+        return;
+      }
+    // Fallthrough
+
+    case 88
+    /* "X" */
+    :
+      {
+        startAsyncIterable(response, id, false);
+        return;
+      }
+    // Fallthrough
+
+    case 120
+    /* "x" */
+    :
+      {
+        startAsyncIterable(response, id, true);
+        return;
+      }
+    // Fallthrough
+
+    case 67
+    /* "C" */
+    :
+      {
+        stopStream(response, id, row);
+        return;
+      }
+    // Fallthrough
+
+    case 80
+    /* "P" */
+    :
+      {
+        {
+          {
+            resolvePostponeProd(response, id);
+          }
+
+          return;
+        }
+      }
+    // Fallthrough
+
+    default:
+      /* """ "{" "[" "t" "f" "n" "0" - "9" */
+      {
+        // We assume anything else is JSON.
+        resolveModel(response, id, row);
+        return;
+      }
+  }
+}
+
+function processBinaryChunk(response, chunk) {
+  let i = 0;
+  let rowState = response._rowState;
+  let rowID = response._rowID;
+  let rowTag = response._rowTag;
+  let rowLength = response._rowLength;
+  const buffer = response._buffer;
+  const chunkLength = chunk.length;
+
+  while (i < chunkLength) {
+    let lastIdx = -1;
+
+    switch (rowState) {
+      case ROW_ID:
+        {
+          const byte = chunk[i++];
+
+          if (byte === 58
+          /* ":" */
+          ) {
+              // Finished the rowID, next we'll parse the tag.
+              rowState = ROW_TAG;
+            } else {
+            rowID = rowID << 4 | (byte > 96 ? byte - 87 : byte - 48);
+          }
+
+          continue;
+        }
+
+      case ROW_TAG:
+        {
+          const resolvedRowTag = chunk[i];
+
+          if (resolvedRowTag === 84
+          /* "T" */
+          || resolvedRowTag === 65
+          /* "A" */
+          || resolvedRowTag === 79
+          /* "O" */
+          || resolvedRowTag === 111
+          /* "o" */
+          || resolvedRowTag === 85
+          /* "U" */
+          || resolvedRowTag === 83
+          /* "S" */
+          || resolvedRowTag === 115
+          /* "s" */
+          || resolvedRowTag === 76
+          /* "L" */
+          || resolvedRowTag === 108
+          /* "l" */
+          || resolvedRowTag === 71
+          /* "G" */
+          || resolvedRowTag === 103
+          /* "g" */
+          || resolvedRowTag === 77
+          /* "M" */
+          || resolvedRowTag === 109
+          /* "m" */
+          || resolvedRowTag === 86
+          /* "V" */
+          ) {
+              rowTag = resolvedRowTag;
+              rowState = ROW_LENGTH;
+              i++;
+            } else if (resolvedRowTag > 64 && resolvedRowTag < 91 ||
+          /* "A"-"Z" */
+          resolvedRowTag === 35
+          /* "#" */
+          || resolvedRowTag === 114
+          /* "r" */
+          || resolvedRowTag === 120
+          /* "x" */
+          ) {
+              rowTag = resolvedRowTag;
+              rowState = ROW_CHUNK_BY_NEWLINE;
+              i++;
+            } else {
+            rowTag = 0;
+            rowState = ROW_CHUNK_BY_NEWLINE; // This was an unknown tag so it was probably part of the data.
+          }
+
+          continue;
+        }
+
+      case ROW_LENGTH:
+        {
+          const byte = chunk[i++];
+
+          if (byte === 44
+          /* "," */
+          ) {
+              // Finished the rowLength, next we'll buffer up to that length.
+              rowState = ROW_CHUNK_BY_LENGTH;
+            } else {
+            rowLength = rowLength << 4 | (byte > 96 ? byte - 87 : byte - 48);
+          }
+
+          continue;
+        }
+
+      case ROW_CHUNK_BY_NEWLINE:
+        {
+          // We're looking for a newline
+          lastIdx = chunk.indexOf(10
+          /* "\n" */
+          , i);
+          break;
+        }
+
+      case ROW_CHUNK_BY_LENGTH:
+        {
+          // We're looking for the remaining byte length
+          lastIdx = i + rowLength;
+
+          if (lastIdx > chunk.length) {
+            lastIdx = -1;
+          }
+
+          break;
+        }
+    }
+
+    const offset = chunk.byteOffset + i;
+
+    if (lastIdx > -1) {
+      // We found the last chunk of the row
+      const length = lastIdx - i;
+      const lastChunk = new Uint8Array(chunk.buffer, offset, length);
+      processFullBinaryRow(response, rowID, rowTag, buffer, lastChunk); // Reset state machine for a new row
+
+      i = lastIdx;
+
+      if (rowState === ROW_CHUNK_BY_NEWLINE) {
+        // If we're trailing by a newline we need to skip it.
+        i++;
+      }
+
+      rowState = ROW_ID;
+      rowTag = 0;
+      rowID = 0;
+      rowLength = 0;
+      buffer.length = 0;
+    } else {
+      // The rest of this row is in a future chunk. We stash the rest of the
+      // current chunk until we can process the full row.
+      const length = chunk.byteLength - i;
+      const remainingSlice = new Uint8Array(chunk.buffer, offset, length);
+      buffer.push(remainingSlice); // Update how many bytes we're still waiting for. If we're looking for
+      // a newline, this doesn't hurt since we'll just ignore it.
+
+      rowLength -= remainingSlice.byteLength;
+      break;
+    }
+  }
+
+  response._rowState = rowState;
+  response._rowID = rowID;
+  response._rowTag = rowTag;
+  response._rowLength = rowLength;
+}
+
+function parseModel(response, json) {
+  return JSON.parse(json, response._fromJSON);
+}
+
+function createFromJSONCallback(response) {
+  // $FlowFixMe[missing-this-annot]
+  return function (key, value) {
+    if (typeof value === 'string') {
+      // We can't use .bind here because we need the "this" value.
+      return parseModelString(response, this, key, value);
+    }
+
+    if (typeof value === 'object' && value !== null) {
+      return parseModelTuple(response, value);
+    }
+
+    return value;
+  };
+}
+
+function close(response) {
+  // In case there are any remaining unresolved chunks, they won't
+  // be resolved now. So we need to issue an error to those.
+  // Ideally we should be able to early bail out if we kept a
+  // ref count of pending chunks.
+  reportGlobalError(response, new Error('Connection closed.'));
+}
+
+function createResponseFromOptions(options) {
+  return createResponse(options && options.moduleBaseURL ? options.moduleBaseURL : '', null, null, options && options.callServer ? options.callServer : undefined, undefined, // encodeFormAction
+  undefined, // nonce
+  options && options.temporaryReferences ? options.temporaryReferences : undefined);
+}
+
+function startReadingFromStream(response, stream) {
+  const reader = stream.getReader();
+
+  function progress(_ref) {
+    let done = _ref.done,
+        value = _ref.value;
+
+    if (done) {
+      close(response);
+      return;
+    }
+
+    const buffer = value;
+    processBinaryChunk(response, buffer);
+    return reader.read().then(progress).catch(error);
+  }
+
+  function error(e) {
+    reportGlobalError(response, e);
+  }
+
+  reader.read().then(progress).catch(error);
+}
+
+function createFromReadableStream(stream, options) {
+  const response = createResponseFromOptions(options);
+  startReadingFromStream(response, stream);
+  return getRoot(response);
+}
+
+function createFromFetch(promiseForResponse, options) {
+  const response = createResponseFromOptions(options);
+  promiseForResponse.then(function (r) {
+    startReadingFromStream(response, r.body);
+  }, function (e) {
+    reportGlobalError(response, e);
+  });
+  return getRoot(response);
+}
+
+function encodeReply(value, options)
+/* We don't use URLSearchParams yet but maybe */
+{
+  return new Promise((resolve, reject) => {
+    const abort = processReply(value, '', options && options.temporaryReferences ? options.temporaryReferences : undefined, resolve, reject);
+
+    if (options && options.signal) {
+      const signal = options.signal;
+
+      if (signal.aborted) {
+        abort(signal.reason);
+      } else {
+        const listener = () => {
+          abort(signal.reason);
+          signal.removeEventListener('abort', listener);
+        };
+
+        signal.addEventListener('abort', listener);
+      }
+    }
+  });
+}
+
+export { createFromFetch, createFromReadableStream, createServerReference, createTemporaryReferenceSet, encodeReply };
diff --git a/node_modules/react-server-dom-esm/esm/react-server-dom-esm-node-loader.production.js b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-node-loader.production.js
new file mode 100644
index 0000000..7c6457a
--- /dev/null
+++ b/node_modules/react-server-dom-esm/esm/react-server-dom-esm-node-loader.production.js
@@ -0,0 +1,618 @@
+/**
+* @license React
+ * react-server-dom-esm-node-loader.production.js
+ *
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+import * as acorn from 'acorn-loose';
+import readMappings from 'webpack-sources/lib/helpers/readMappings.js';
+import createMappingsSerializer from 'webpack-sources/lib/helpers/createMappingsSerializer.js';
+
+const assign = Object.assign;
+
+let warnedAboutConditionsFlag = false;
+let stashedGetSource = null;
+let stashedResolve = null;
+async function resolve(specifier, context, defaultResolve) {
+  // We stash this in case we end up needing to resolve export * statements later.
+  stashedResolve = defaultResolve;
+
+  if (!context.conditions.includes('react-server')) {
+    context = assign({}, context, {
+      conditions: [].concat(context.conditions, ['react-server'])
+    });
+
+    if (!warnedAboutConditionsFlag) {
+      warnedAboutConditionsFlag = true; // eslint-disable-next-line react-internal/no-production-logging
+
+      console.warn('You did not run Node.js with the `--conditions react-server` flag. ' + 'Any "react-server" override will only work with ESM imports.');
+    }
+  }
+
+  return await defaultResolve(specifier, context, defaultResolve);
+}
+async function getSource(url, context, defaultGetSource) {
+  // We stash this in case we end up needing to resolve export * statements later.
+  stashedGetSource = defaultGetSource;
+  return defaultGetSource(url, context, defaultGetSource);
+}
+
+function addExportedEntry(exportedEntries, localNames, localName, exportedName, type, loc) {
+  if (localNames.has(localName)) {
+    // If the same local name is exported more than once, we only need one of the names.
+    return;
+  }
+
+  exportedEntries.push({
+    localName,
+    exportedName,
+    type,
+    loc,
+    originalLine: -1,
+    originalColumn: -1,
+    originalSource: -1,
+    nameIndex: -1
+  });
+}
+
+function addLocalExportedNames(exportedEntries, localNames, node) {
+  switch (node.type) {
+    case 'Identifier':
+      addExportedEntry(exportedEntries, localNames, node.name, node.name, null, node.loc);
+      return;
+
+    case 'ObjectPattern':
+      for (let i = 0; i < node.properties.length; i++) addLocalExportedNames(exportedEntries, localNames, node.properties[i]);
+
+      return;
+
+    case 'ArrayPattern':
+      for (let i = 0; i < node.elements.length; i++) {
+        const element = node.elements[i];
+        if (element) addLocalExportedNames(exportedEntries, localNames, element);
+      }
+
+      return;
+
+    case 'Property':
+      addLocalExportedNames(exportedEntries, localNames, node.value);
+      return;
+
+    case 'AssignmentPattern':
+      addLocalExportedNames(exportedEntries, localNames, node.left);
+      return;
+
+    case 'RestElement':
+      addLocalExportedNames(exportedEntries, localNames, node.argument);
+      return;
+
+    case 'ParenthesizedExpression':
+      addLocalExportedNames(exportedEntries, localNames, node.expression);
+      return;
+  }
+}
+
+function transformServerModule(source, program, url, sourceMap, loader) {
+  const body = program.body; // This entry list needs to be in source location order.
+
+  const exportedEntries = []; // Dedupe set.
+
+  const localNames = new Set();
+
+  for (let i = 0; i < body.length; i++) {
+    const node = body[i];
+
+    switch (node.type) {
+      case 'ExportAllDeclaration':
+        // If export * is used, the other file needs to explicitly opt into "use server" too.
+        break;
+
+      case 'ExportDefaultDeclaration':
+        if (node.declaration.type === 'Identifier') {
+          addExportedEntry(exportedEntries, localNames, node.declaration.name, 'default', null, node.declaration.loc);
+        } else if (node.declaration.type === 'FunctionDeclaration') {
+          if (node.declaration.id) {
+            addExportedEntry(exportedEntries, localNames, node.declaration.id.name, 'default', 'function', node.declaration.id.loc);
+          }
+        }
+
+        continue;
+
+      case 'ExportNamedDeclaration':
+        if (node.declaration) {
+          if (node.declaration.type === 'VariableDeclaration') {
+            const declarations = node.declaration.declarations;
+
+            for (let j = 0; j < declarations.length; j++) {
+              addLocalExportedNames(exportedEntries, localNames, declarations[j].id);
+            }
+          } else {
+            const name = node.declaration.id.name;
+            addExportedEntry(exportedEntries, localNames, name, name, node.declaration.type === 'FunctionDeclaration' ? 'function' : null, node.declaration.id.loc);
+          }
+        }
+
+        if (node.specifiers) {
+          const specifiers = node.specifiers;
+
+          for (let j = 0; j < specifiers.length; j++) {
+            const specifier = specifiers[j];
+            addExportedEntry(exportedEntries, localNames, specifier.local.name, specifier.exported.name, null, specifier.local.loc);
+          }
+        }
+
+        continue;
+    }
+  }
+
+  let mappings = sourceMap && typeof sourceMap.mappings === 'string' ? sourceMap.mappings : '';
+  let newSrc = source;
+
+  if (exportedEntries.length > 0) {
+    let lastSourceIndex = 0;
+    let lastOriginalLine = 0;
+    let lastOriginalColumn = 0;
+    let lastNameIndex = 0;
+    let sourceLineCount = 0;
+    let lastMappedLine = 0;
+
+    if (sourceMap) {
+      // We iterate source mapping entries and our matched exports in parallel to source map
+      // them to their original location.
+      let nextEntryIdx = 0;
+      let nextEntryLine = exportedEntries[nextEntryIdx].loc.start.line;
+      let nextEntryColumn = exportedEntries[nextEntryIdx].loc.start.column;
+      readMappings(mappings, (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
+        if (generatedLine > nextEntryLine || generatedLine === nextEntryLine && generatedColumn > nextEntryColumn) {
+          // We're past the entry which means that the best match we have is the previous entry.
+          if (lastMappedLine === nextEntryLine) {
+            // Match
+            exportedEntries[nextEntryIdx].originalLine = lastOriginalLine;
+            exportedEntries[nextEntryIdx].originalColumn = lastOriginalColumn;
+            exportedEntries[nextEntryIdx].originalSource = lastSourceIndex;
+            exportedEntries[nextEntryIdx].nameIndex = lastNameIndex;
+          }
+
+          nextEntryIdx++;
+
+          if (nextEntryIdx < exportedEntries.length) {
+            nextEntryLine = exportedEntries[nextEntryIdx].loc.start.line;
+            nextEntryColumn = exportedEntries[nextEntryIdx].loc.start.column;
+          } else {
+            nextEntryLine = -1;
+            nextEntryColumn = -1;
+          }
+        }
+
+        lastMappedLine = generatedLine;
+
+        if (sourceIndex > -1) {
+          lastSourceIndex = sourceIndex;
+        }
+
+        if (originalLine > -1) {
+          lastOriginalLine = originalLine;
+        }
+
+        if (originalColumn > -1) {
+          lastOriginalColumn = originalColumn;
+        }
+
+        if (nameIndex > -1) {
+          lastNameIndex = nameIndex;
+        }
+      });
+
+      if (nextEntryIdx < exportedEntries.length) {
+        if (lastMappedLine === nextEntryLine) {
+          // Match
+          exportedEntries[nextEntryIdx].originalLine = lastOriginalLine;
+          exportedEntries[nextEntryIdx].originalColumn = lastOriginalColumn;
+          exportedEntries[nextEntryIdx].originalSource = lastSourceIndex;
+          exportedEntries[nextEntryIdx].nameIndex = lastNameIndex;
+        }
+      }
+
+      for (let lastIdx = mappings.length - 1; lastIdx >= 0 && mappings[lastIdx] === ';'; lastIdx--) {
+        // If the last mapped lines don't contain any segments, we don't get a callback from readMappings
+        // so we need to pad the number of mapped lines, with one for each empty line.
+        lastMappedLine++;
+      }
+
+      sourceLineCount = program.loc.end.line;
+
+      if (sourceLineCount < lastMappedLine) {
+        throw new Error('The source map has more mappings than there are lines.');
+      } // If the original source string had more lines than there are mappings in the source map.
+      // Add some extra padding of unmapped lines so that any lines that we add line up.
+
+
+      for (let extraLines = sourceLineCount - lastMappedLine; extraLines > 0; extraLines--) {
+        mappings += ';';
+      }
+    } else {
+      // If a file doesn't have a source map then we generate a blank source map that just
+      // contains the original content and segments pointing to the original lines.
+      sourceLineCount = 1;
+      let idx = -1;
+
+      while ((idx = source.indexOf('\n', idx + 1)) !== -1) {
+        sourceLineCount++;
+      }
+
+      mappings = 'AAAA' + ';AACA'.repeat(sourceLineCount - 1);
+      sourceMap = {
+        version: 3,
+        sources: [url],
+        sourcesContent: [source],
+        mappings: mappings,
+        sourceRoot: ''
+      };
+      lastSourceIndex = 0;
+      lastOriginalLine = sourceLineCount;
+      lastOriginalColumn = 0;
+      lastNameIndex = -1;
+      lastMappedLine = sourceLineCount;
+
+      for (let i = 0; i < exportedEntries.length; i++) {
+        // Point each entry to original location.
+        const entry = exportedEntries[i];
+        entry.originalSource = 0;
+        entry.originalLine = entry.loc.start.line; // We use column zero since we do the short-hand line-only source maps above.
+
+        entry.originalColumn = 0; // entry.loc.start.column;
+      }
+    }
+
+    newSrc += '\n\n;';
+    newSrc += 'import {registerServerReference} from "react-server-dom-esm/server";\n';
+
+    if (mappings) {
+      mappings += ';;';
+    }
+
+    const createMapping = createMappingsSerializer(); // Create an empty mapping pointing to where we last left off to reset the counters.
+
+    let generatedLine = 1;
+    createMapping(generatedLine, 0, lastSourceIndex, lastOriginalLine, lastOriginalColumn, lastNameIndex);
+
+    for (let i = 0; i < exportedEntries.length; i++) {
+      const entry = exportedEntries[i];
+      generatedLine++;
+
+      if (entry.type !== 'function') {
+        // We first check if the export is a function and if so annotate it.
+        newSrc += 'if (typeof ' + entry.localName + ' === "function") ';
+      }
+
+      newSrc += 'registerServerReference(' + entry.localName + ',';
+      newSrc += JSON.stringify(url) + ',';
+      newSrc += JSON.stringify(entry.exportedName) + ');\n';
+      mappings += createMapping(generatedLine, 0, entry.originalSource, entry.originalLine, entry.originalColumn, entry.nameIndex);
+    }
+  }
+
+  if (sourceMap) {
+    // Override with an new mappings and serialize an inline source map.
+    sourceMap.mappings = mappings;
+    newSrc += '//# sourceMappingURL=data:application/json;charset=utf-8;base64,' + Buffer.from(JSON.stringify(sourceMap)).toString('base64');
+  }
+
+  return newSrc;
+}
+
+function addExportNames(names, node) {
+  switch (node.type) {
+    case 'Identifier':
+      names.push(node.name);
+      return;
+
+    case 'ObjectPattern':
+      for (let i = 0; i < node.properties.length; i++) addExportNames(names, node.properties[i]);
+
+      return;
+
+    case 'ArrayPattern':
+      for (let i = 0; i < node.elements.length; i++) {
+        const element = node.elements[i];
+        if (element) addExportNames(names, element);
+      }
+
+      return;
+
+    case 'Property':
+      addExportNames(names, node.value);
+      return;
+
+    case 'AssignmentPattern':
+      addExportNames(names, node.left);
+      return;
+
+    case 'RestElement':
+      addExportNames(names, node.argument);
+      return;
+
+    case 'ParenthesizedExpression':
+      addExportNames(names, node.expression);
+      return;
+  }
+}
+
+function resolveClientImport(specifier, parentURL) {
+  // Resolve an import specifier as if it was loaded by the client. This doesn't use
+  // the overrides that this loader does but instead reverts to the default.
+  // This resolution algorithm will not necessarily have the same configuration
+  // as the actual client loader. It should mostly work and if it doesn't you can
+  // always convert to explicit exported names instead.
+  const conditions = ['node', 'import'];
+
+  if (stashedResolve === null) {
+    throw new Error('Expected resolve to have been called before transformSource');
+  }
+
+  return stashedResolve(specifier, {
+    conditions,
+    parentURL
+  }, stashedResolve);
+}
+
+async function parseExportNamesInto(body, names, parentURL, loader) {
+  for (let i = 0; i < body.length; i++) {
+    const node = body[i];
+
+    switch (node.type) {
+      case 'ExportAllDeclaration':
+        if (node.exported) {
+          addExportNames(names, node.exported);
+          continue;
+        } else {
+          const _await$resolveClientI = await resolveClientImport(node.source.value, parentURL),
+                url = _await$resolveClientI.url;
+
+          const _await$loader = await loader(url, {
+            format: 'module',
+            conditions: [],
+            importAssertions: {}
+          }, loader),
+                source = _await$loader.source;
+
+          if (typeof source !== 'string') {
+            throw new Error('Expected the transformed source to be a string.');
+          }
+
+          let childBody;
+
+          try {
+            childBody = acorn.parse(source, {
+              ecmaVersion: '2024',
+              sourceType: 'module'
+            }).body;
+          } catch (x) {
+            // eslint-disable-next-line react-internal/no-production-logging
+            console.error('Error parsing %s %s', url, x.message);
+            continue;
+          }
+
+          await parseExportNamesInto(childBody, names, url, loader);
+          continue;
+        }
+
+      case 'ExportDefaultDeclaration':
+        names.push('default');
+        continue;
+
+      case 'ExportNamedDeclaration':
+        if (node.declaration) {
+          if (node.declaration.type === 'VariableDeclaration') {
+            const declarations = node.declaration.declarations;
+
+            for (let j = 0; j < declarations.length; j++) {
+              addExportNames(names, declarations[j].id);
+            }
+          } else {
+            addExportNames(names, node.declaration.id);
+          }
+        }
+
+        if (node.specifiers) {
+          const specifiers = node.specifiers;
+
+          for (let j = 0; j < specifiers.length; j++) {
+            addExportNames(names, specifiers[j].exported);
+          }
+        }
+
+        continue;
+    }
+  }
+}
+
+async function transformClientModule(program, url, sourceMap, loader) {
+  const body = program.body;
+  const names = [];
+  await parseExportNamesInto(body, names, url, loader);
+
+  if (names.length === 0) {
+    return '';
+  }
+
+  let newSrc = 'import {registerClientReference} from "react-server-dom-esm/server";\n';
+
+  for (let i = 0; i < names.length; i++) {
+    const name = names[i];
+
+    if (name === 'default') {
+      newSrc += 'export default ';
+      newSrc += 'registerClientReference(function() {';
+      newSrc += 'throw new Error(' + JSON.stringify("Attempted to call the default export of " + url + " from the server " + "but it's on the client. It's not possible to invoke a client function from " + "the server, it can only be rendered as a Component or passed to props of a " + "Client Component.") + ');';
+    } else {
+      newSrc += 'export const ' + name + ' = ';
+      newSrc += 'registerClientReference(function() {';
+      newSrc += 'throw new Error(' + JSON.stringify("Attempted to call " + name + "() from the server but " + name + " is on the client. " + "It's not possible to invoke a client function from the server, it can " + "only be rendered as a Component or passed to props of a Client Component.") + ');';
+    }
+
+    newSrc += '},';
+    newSrc += JSON.stringify(url) + ',';
+    newSrc += JSON.stringify(name) + ');\n';
+  } // TODO: Generate source maps for Client Reference functions so they can point to their
+  // original locations.
+
+
+  return newSrc;
+}
+
+async function loadClientImport(url, defaultTransformSource) {
+  if (stashedGetSource === null) {
+    throw new Error('Expected getSource to have been called before transformSource');
+  } // TODO: Validate that this is another module by calling getFormat.
+
+
+  const _await$stashedGetSour = await stashedGetSource(url, {
+    format: 'module'
+  }, stashedGetSource),
+        source = _await$stashedGetSour.source;
+
+  const result = await defaultTransformSource(source, {
+    format: 'module',
+    url
+  }, defaultTransformSource);
+  return {
+    format: 'module',
+    source: result.source
+  };
+}
+
+async function transformModuleIfNeeded(source, url, loader) {
+  // Do a quick check for the exact string. If it doesn't exist, don't
+  // bother parsing.
+  if (source.indexOf('use client') === -1 && source.indexOf('use server') === -1) {
+    return source;
+  }
+
+  let sourceMappingURL = null;
+  let sourceMappingStart = 0;
+  let sourceMappingEnd = 0;
+  let sourceMappingLines = 0;
+  let program;
+
+  try {
+    program = acorn.parse(source, {
+      ecmaVersion: '2024',
+      sourceType: 'module',
+      locations: true,
+
+      onComment(block, text, start, end, startLoc, endLoc) {
+        if (text.startsWith('# sourceMappingURL=') || text.startsWith('@ sourceMappingURL=')) {
+          sourceMappingURL = text.slice(19);
+          sourceMappingStart = start;
+          sourceMappingEnd = end;
+          sourceMappingLines = endLoc.line - startLoc.line;
+        }
+      }
+
+    });
+  } catch (x) {
+    // eslint-disable-next-line react-internal/no-production-logging
+    console.error('Error parsing %s %s', url, x.message);
+    return source;
+  }
+
+  let useClient = false;
+  let useServer = false;
+  const body = program.body;
+
+  for (let i = 0; i < body.length; i++) {
+    const node = body[i];
+
+    if (node.type !== 'ExpressionStatement' || !node.directive) {
+      break;
+    }
+
+    if (node.directive === 'use client') {
+      useClient = true;
+    }
+
+    if (node.directive === 'use server') {
+      useServer = true;
+    }
+  }
+
+  if (!useClient && !useServer) {
+    return source;
+  }
+
+  if (useClient && useServer) {
+    throw new Error('Cannot have both "use client" and "use server" directives in the same file.');
+  }
+
+  let sourceMap = null;
+
+  if (sourceMappingURL) {
+    const sourceMapResult = await loader(sourceMappingURL, // $FlowFixMe
+    {
+      format: 'json',
+      conditions: [],
+      importAssertions: {
+        type: 'json'
+      },
+      importAttributes: {
+        type: 'json'
+      }
+    }, loader);
+    const sourceMapString = typeof sourceMapResult.source === 'string' ? sourceMapResult.source : // $FlowFixMe
+    sourceMapResult.source.toString('utf8');
+    sourceMap = JSON.parse(sourceMapString); // Strip the source mapping comment. We'll re-add it below if needed.
+
+    source = source.slice(0, sourceMappingStart) + '\n'.repeat(sourceMappingLines) + source.slice(sourceMappingEnd);
+  }
+
+  if (useClient) {
+    return transformClientModule(program, url, sourceMap, loader);
+  }
+
+  return transformServerModule(source, program, url, sourceMap);
+}
+
+async function transformSource(source, context, defaultTransformSource) {
+  const transformed = await defaultTransformSource(source, context, defaultTransformSource);
+
+  if (context.format === 'module') {
+    const transformedSource = transformed.source;
+
+    if (typeof transformedSource !== 'string') {
+      throw new Error('Expected source to have been transformed to a string.');
+    }
+
+    const newSrc = await transformModuleIfNeeded(transformedSource, context.url, (url, ctx, defaultLoad) => {
+      return loadClientImport(url, defaultTransformSource);
+    });
+    return {
+      source: newSrc
+    };
+  }
+
+  return transformed;
+}
+async function load(url, context, defaultLoad) {
+  const result = await defaultLoad(url, context, defaultLoad);
+
+  if (result.format === 'module') {
+    if (typeof result.source !== 'string') {
+      throw new Error('Expected source to have been loaded into a string.');
+    }
+
+    const newSrc = await transformModuleIfNeeded(result.source, url, defaultLoad);
+    return {
+      format: 'module',
+      source: newSrc
+    };
+  }
+
+  return result;
+}
+
+export { getSource, load, resolve, transformSource };
diff --git a/node_modules/react-server-dom-esm/index.js b/node_modules/react-server-dom-esm/index.js
new file mode 100644
index 0000000..60818c2
--- /dev/null
+++ b/node_modules/react-server-dom-esm/index.js
@@ -0,0 +1,12 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+'use strict';
+
+throw new Error('Use react-server-dom-esm/client instead.');
diff --git a/node_modules/react-server-dom-esm/package.json b/node_modules/react-server-dom-esm/package.json
index aa37e77..c1b80e9 100644
--- a/node_modules/react-server-dom-esm/package.json
+++ b/node_modules/react-server-dom-esm/package.json
@@ -1,20 +1,63 @@
 {
   "name": "react-server-dom-esm",
   "description": "React Server Components bindings for DOM using ESM. This is intended to be integrated into meta-frameworks. It is not intended to be imported directly.",
-  "version": "0.0.1",
+  "version": "0.0.0-experimental-b3a95caf-20250113",
   "keywords": [
     "react"
   ],
-  "homepage": "https://reactjs.org/",
+  "homepage": "https://react.dev/",
   "bugs": "https://github.com/facebook/react/issues",
   "license": "MIT",
   "files": [
     "LICENSE",
-    "README.md"
+    "README.md",
+    "index.js",
+    "client.js",
+    "client.browser.js",
+    "client.node.js",
+    "server.js",
+    "server.node.js",
+    "static.js",
+    "static.node.js",
+    "cjs/",
+    "esm/"
   ],
+  "exports": {
+    ".": "./index.js",
+    "./client": {
+      "node": "./client.node.js",
+      "default": "./client.browser.js"
+    },
+    "./client.browser": "./client.browser.js",
+    "./client.node": "./client.node.js",
+    "./server": {
+      "react-server": "./server.node.js",
+      "default": "./server.js"
+    },
+    "./server.node": "./server.node.js",
+    "./static": {
+      "react-server": "./static.node.js",
+      "default": "./static.js"
+    },
+    "./static.node": "./static.node.js",
+    "./node-loader": "./esm/react-server-dom-esm-node-loader.production.js",
+    "./package.json": "./package.json"
+  },
+  "main": "index.js",
   "repository": {
-    "type" : "git",
-    "url" : "https://github.com/facebook/react.git",
+    "type": "git",
+    "url": "https://github.com/facebook/react.git",
     "directory": "packages/react-server-dom-esm"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "peerDependencies": {
+    "react": "0.0.0-experimental-b3a95caf-20250113",
+    "react-dom": "0.0.0-experimental-b3a95caf-20250113"
+  },
+  "dependencies": {
+    "acorn-loose": "^8.3.0",
+    "webpack-sources": "^3.2.0"
   }
 }
\ No newline at end of file
diff --git a/node_modules/react-server-dom-esm/server.js b/node_modules/react-server-dom-esm/server.js
new file mode 100644
index 0000000..13a632e
--- /dev/null
+++ b/node_modules/react-server-dom-esm/server.js
@@ -0,0 +1,6 @@
+'use strict';
+
+throw new Error(
+  'The React Server Writer cannot be used outside a react-server environment. ' +
+    'You must configure Node.js using the `--conditions react-server` flag.'
+);
diff --git a/node_modules/react-server-dom-esm/server.node.js b/node_modules/react-server-dom-esm/server.node.js
new file mode 100644
index 0000000..579ab59
--- /dev/null
+++ b/node_modules/react-server-dom-esm/server.node.js
@@ -0,0 +1,17 @@
+'use strict';
+
+var s;
+if (process.env.NODE_ENV === 'production') {
+  s = require('./cjs/react-server-dom-esm-server.node.production.js');
+} else {
+  s = require('./cjs/react-server-dom-esm-server.node.development.js');
+}
+
+exports.renderToPipeableStream = s.renderToPipeableStream;
+exports.decodeReplyFromBusboy = s.decodeReplyFromBusboy;
+exports.decodeReply = s.decodeReply;
+exports.decodeAction = s.decodeAction;
+exports.decodeFormState = s.decodeFormState;
+exports.registerServerReference = s.registerServerReference;
+exports.registerClientReference = s.registerClientReference;
+exports.createTemporaryReferenceSet = s.createTemporaryReferenceSet;
diff --git a/node_modules/react-server-dom-esm/static.js b/node_modules/react-server-dom-esm/static.js
new file mode 100644
index 0000000..13a632e
--- /dev/null
+++ b/node_modules/react-server-dom-esm/static.js
@@ -0,0 +1,6 @@
+'use strict';
+
+throw new Error(
+  'The React Server Writer cannot be used outside a react-server environment. ' +
+    'You must configure Node.js using the `--conditions react-server` flag.'
+);
diff --git a/node_modules/react-server-dom-esm/static.node.js b/node_modules/react-server-dom-esm/static.node.js
new file mode 100644
index 0000000..7fb451a
--- /dev/null
+++ b/node_modules/react-server-dom-esm/static.node.js
@@ -0,0 +1,12 @@
+'use strict';
+
+var s;
+if (process.env.NODE_ENV === 'production') {
+  s = require('./cjs/react-server-dom-esm-server.node.production.js');
+} else {
+  s = require('./cjs/react-server-dom-esm-server.node.development.js');
+}
+
+if (s.unstable_prerenderToNodeStream) {
+  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;
+}
